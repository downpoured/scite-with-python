## ==> ada.properties <==
# Define SciTE settings for Ada files.

filter.ada=Ada (ads adb)|*.ads;*.adb|

*filter.ada=$(filter.ada)

file.patterns.ada=*.ads;*.adb

lexer.$(file.patterns.ada)=ada

#*language.ada=Ada|ads||

#indent.size.$(file.patterns.ada)=3
#use.tabs.$(file.patterns.ada)=0

# Keyword except of operator keywords
keywordclass.ada.main=abort abstract accept access aliased all array at begin body \
case constant declare delay delta digits do else elsif end entry exception exit for \
function generic goto if in is limited loop new null of others out package pragma \
private procedure protected raise range record renames requeue return reverse \
select separate subtype tagged task terminate then type until use when while with
# Keywords for operators
keywordclass.ada.operators=abs and mod not or rem xor

keywordclass.ada=$(keywordclass.ada.main) $(keywordclass.ada.operators)

keywords.$(file.patterns.ada)=$(keywordclass.ada)

# Ada styles
# Default
style.ada.0=fore:#808080
# Keyword
style.ada.1=$(colour.keyword),bold
# Identifiers
style.ada.2=
# Number
style.ada.3=$(colour.number)
# Operators (delimiters)
style.ada.4=$(colour.operator),bold
# Character
style.ada.5=$(colour.char)
# End of line where character is not closed
style.ada.6=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled
# String
style.ada.7=$(colour.string)
# End of line where string is not closed
style.ada.8=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled
# Label
style.ada.9=fore:#7F0000
# Comment
style.ada.10=$(colour.code.comment.line),$(font.code.comment.line)
# Illegal token
style.ada.11=fore:#FF0000

# Comments
comment.block.ada=--~

braces.ada.style=4

statement.indent.$(file.patterns.ada)=1 begin declare else elsif exception for if is loop while
statement.lookback.$(file.patterns.ada)=20
block.start.$(file.patterns.ada)=10 then is
block.end.$(file.patterns.ada)=10 end

calltip.ada.word.characters=._$(chars.alpha)

adagcc=gcc -c $(FileNameExt)

command.compile.*.ads=$(adagcc)
command.build.*.ads=gnatmake
command.go.*.ads=$(FileName)

command.compile.*.adb=$(adagcc)
command.build.*.adb=gnatmake
command.go.*.adb=$(FileName)

## ==> caml.properties <==
#	Define SciTE settings for Objective Caml, Standard ML 97 files
#
#	To use with Standard ML source in .ml files, select Standard ML
#	from the SciTE Language menu (or adjust the properties below).
#
# To fully enable this Scintilla lexer, make sure the following entries
#	are present and uncommented in your SciTE properties:
#
#		$(filter.caml)\
#		$(filter.sml)\
#
#		Objective Caml|ml||\
#		Standard ML|sml||\
#
#		import caml

# OCaml/SML implementation and interface files
file.patterns.caml=*.ml;*.mli
file.patterns.sml=*.sml

*filter.objectivecaml=$(filter.caml)

filter.caml=Objective Caml (ml mli)|$(file.patterns.caml)|
filter.sml=Standard ML 97 (sml ml)|$(file.patterns.sml)|

lexer.*.caml=caml
lexer.$(file.patterns.caml)=caml
lexer.$(file.patterns.sml)=caml

#*language.objectivecaml=Objective Caml|ml||

# the line below is ONLY used as part of "external" lexer support
#lexerpath.$(file.patterns.caml)=LexCaml.dll
#lexerpath.$(file.patterns.sml)=LexCaml.dll

# the standard Objective Caml 3.09/3.10/3.11 language "textual" keywords
keywordstandard.caml= \
and as assert asr begin class \
constraint do done downto else end \
exception external false for fun function \
functor if in include inherit initializer \
land lazy let lor lsl lsr \
lxor match method mod module mutable \
new object of open or private \
rec sig struct then to true \
try type val virtual when while \
with
keywords.$(file.patterns.caml)=$(keywordstandard.caml)

# the standard Standard ML '97 language "textual" keywords
keywordstandard.sml= \
abstype andalso and as case datatype div do \
else end eqtype exception \
false fn fun functor handle if infixr infix include in let local \
mod nonfix not of open op orelse raise rec \
sharing signature sig structure struct then true type use \
val while withtype with
keywords.$(file.patterns.sml)=$(keywordstandard.sml)

# "optional" Objective Caml / library keywords; some suggested entries are here,
# more could come from, say, Pervasives ('parser' is from Camlp4)
keywordoptional1.caml= \
option Some None ignore ref lnot succ pred parser
keywords2.$(file.patterns.caml)=$(keywordoptional1.caml)

# "optional" Standard ML '97 / library keywords; some suggested entries are here,
# more could come from, say, Standard Basis Library
keywordoptional1.sml= \
option SOME NONE ignore ref \
chr explode implode ord size
keywords2.$(file.patterns.sml)=$(keywordoptional1.sml)

# "optional" Objective Caml / library keywords; some suggested entries are here,
# more could come from, say, user-defined types
keywordoptional2.caml= \
array bool char float int list string unit
keywords3.$(file.patterns.caml)=$(keywordoptional2.caml)

# "optional" Standard ML '97 / library keywords; some suggested entries are here,
# more could come from, say, user-defined types
keywordoptional2.sml= \
array bool char int list nil real string unit vector word
keywords3.$(file.patterns.sml)=$(keywordoptional2.sml)

word.characters.$(file.patterns.caml)=$(chars.alpha)$(chars.numeric)_'`
word.characters.$(file.patterns.sml)=$(chars.alpha)$(chars.numeric)_'

comment.stream.start.caml=(*
comment.stream.end.caml=*)
comment.box.start.caml=(*
comment.box.middle.caml= *
comment.box.end.caml= *)

# "folding" support not currently implemented

# "Out-of-the-box" syntax colors are defined here - I like having
# my literals (number, char, and string), tag-names, and "optional"
# keywords stand out - you might not, so adjust accordingly!
# Default
style.caml.32=$(font.base)
# White space
style.caml.0=fore:#808080
# Identifiers
style.caml.1=
# Tag-names
#style.caml.2=
style.caml.2=fore:#000000,back:#ffe0ff
# Keywords (builtin language-defined keywords)
style.caml.3=$(colour.keyword),bold
# Keywords2 (season to taste - use for option, Some, None, etc)
#style.caml.4=
style.caml.4=fore:#000000,back:#e0e0ff
# Keywords3 (season to taste - use for bool, char, float, etc)
#style.caml.5=
#style.caml.5=fore:#000000,back:#ffe0e0
style.caml.5=fore:#a0000,bold
# Linenum directive
style.caml.6=back:#C0C0C0,$(font.base)
# Operators
style.caml.7=$(colour.operator),bold
# Number
#style.caml.8=$(colour.number)
style.caml.8=fore:#000000,back:#ffff00
# Single quoted string (character constant)
#style.caml.9=$(colour.char)
style.caml.9=fore:#000000,back:#ffff00
# Embedded whitespace (SML character/string constant)
#style.caml.10=
style.caml.10=fore:#000000,back:#e0e0e0
# Double quoted string (string constant)
#style.caml.11=$(colour.string)
style.caml.11=fore:#000000,back:#ffff00
# Comment (NOT nested)
style.caml.12=$(colour.code.comment.box),$(font.code.comment.box)
# Comment (SINGLY nested)
#style.caml.13=$(colour.code.comment.box),$(font.code.comment.box)
style.caml.13=$(colour.embedded.comment),$(font.code.comment.box)
# Comment (DOUBLY nested)
#style.caml.14=$(colour.code.comment.box),$(font.code.comment.box)
style.caml.14=$(colour.embedded.comment),$(font.code.comment.box)
# Comment (TRIPLY nested)
#style.caml.15=$(colour.code.comment.box),$(font.code.comment.box)
style.caml.15=$(colour.embedded.comment),$(font.code.comment.box)

# Braces are only matched in operator style
braces.caml.style=7

# The below command(s) can and should be adjusted to reflect your environment;
# in addition, per-directory overrides are possible, so that project-specific "build"
# commands may be used for more complex cases - see the SciTE documentation.
command.compile.$(file.patterns.caml)=ocamlc -c $(FileNameExt)

## ==> d.properties <==
# Define SciTE settings for D

file.patterns.d=*.d
filter.d=D (d)|$(file.patterns.d)|
*filter.d=$(filter.d)
lexer.$(file.patterns.d)=d
#*language.d=D|d||

word.chars.d=$(chars.alpha)$(chars.numeric)_#
word.characters.$(file.patterns.d)=$(word.chars.d)
#~ word.characters.$(file.patterns.cs)=$(word.chars.d)
calltip.d.word.characters=$(chars.alpha)$(chars.numeric)_


#comment.block.at.line.start.d=1
comment.block.d=//~
comment.stream.start.d=/+
comment.stream.end.d=+/
comment.box.start.d=/*
comment.box.middle.d= *
comment.box.end.d= */
#lexer.d.fold.at.else=1

statement.indent.$(file.patterns.d)=6 case catch class debug default do else \
finally for foreach foreach_reverse if private protected public scope struct \
try union while with
statement.end.$(file.patterns.d)=13 ;
statement.lookback.$(file.patterns.d)=20
block.start.$(file.patterns.d)=13 {
block.end.$(file.patterns.d)=13 }

# D keywords
keywords.$(file.patterns.d)=abstract alias align asm assert auto \
 body bool break byte \
 case cast catch cdouble cent cfloat char class const continue creal \
 dchar debug default delegate delete deprecated do double \
 else enum export extern \
 false final finally float for foreach foreach_reverse function \
 goto \
 idouble if ifloat import in inout int interface invariant ireal is \
 lazy long \
 mixin module \
 new null \
 out override \
 package pragma private protected public \
 real return \
 scope short static struct super switch synchronized \
 template this throw true try typedef typeid typeof \
 ubyte ucent uint ulong union unittest ushort \
 version void volatile \
 wchar while with

# keywords2 are intended for embedded ASM

# keywords3 are intended for doxygen
keywords3.$(file.patterns.d)=a addindex addtogroup anchor arg attention \
author b brief bug c class code date def defgroup deprecated dontinclude \
e em endcode endhtmlonly endif endlatexonly endlink endverbatim enum example exception \
f$ f[ f] file fn hideinitializer htmlinclude htmlonly \
if image include ingroup internal invariant interface latexonly li line link \
mainpage name namespace nosubgrouping note overload \
p page par param post pre ref relates remarks return retval \
sa section see showinitializer since skip skipline struct subsection \
test throw todo typedef union until \
var verbatim verbinclude version warning weakgroup $ @ \ & < > # { }

# keywords4 are intended for syntax driven or custom highlighting


# Styles

# 0 - whitespace
# 1, 2, 3, 4 - comments:  /* */,  //,  /** */ or /*! */,  /+ +/
# 5 - number
# 6, 7, 8, 9 - keywords: standard, secondary, doc keywords, typedefs and aliases
# 10 - string
# 11 - string not closed
# 12 - char
# 13 - operator
# 14 - identifier
# 15, 16, 17 - Doc comments: line doc /// or //!, doc keyword, doc keyword err
# 18, 19 stringb, stringr
# 20, 21, 22 keywords 5, 6, and 7

style.d.32=$(font.base)
style.d.0=fore:#808080
style.d.1=$(colour.code.comment.box),$(font.code.comment.box)
style.d.2=$(colour.code.comment.line),$(font.code.comment.line)
style.d.3=$(colour.code.comment.doc),$(font.code.comment.doc)
style.d.4=$(colour.code.comment.nested),$(font.code.comment.nested)
style.d.5=$(colour.number)
style.d.6=$(colour.keyword),bold
style.d.7=$(colour.keyword),bold
style.d.8=$(colour.keyword),bold
style.d.9=$(colour.keyword),bold
style.d.10=$(colour.string)
style.d.11=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled
style.d.12=$(colour.char)
style.d.13=$(colour.operator),bold
style.d.14=
style.d.15=$(colour.code.comment.doc),$(font.code.comment.doc)
style.d.16=fore:#3060A0,$(font.code.comment.doc)
style.d.17=fore:#804020,$(font.code.comment.doc)
style.d.18=fore:#DD9900
style.d.19=fore:#DD9900
style.d.20=fore:#DD9900
style.d.21=fore:#DD9900
style.d.22=fore:#DD9900
# breaces must be operator style to allow matching
braces.d.style=13


command.compile.*.d=dmd -O $(FileNameExt)
command.build.*.d=$(make.command)
command.go.*.d=$(FileName)


## ==> fortran.properties <==
# Define SciTE settings for Fortran files.

filter.fortran=Fortran (f for f90 f95 f2k)|*.f;*.for;*.f90;*.f95;*.f2k|

*filter.fortran=$(filter.fortran)

file.patterns.f95=*.f90;*.f95;*.f2k
file.patterns.f77=*.f;*.for
file.patterns.fortran=$(file.patterns.f95);$(file.patterns.f77)

lexer.$(file.patterns.f95)=fortran
lexer.$(file.patterns.f77)=f77

#*language.fortran=&Fortran|f90||

# keywords and input/output specifiers
keywordclass.fortran=access action advance allocatable allocate \
apostrophe assign assignment associate asynchronous backspace \
bind blank blockdata call case character class close common \
complex contains continue critical cycle data deallocate decimal delim \
default dimension direct do dowhile double doubleprecision else \
elseif elsewhere encoding end endassociate endblockdata enddo \
endfile endforall endfunction endif endinterface endmodule endprogram \
endselect endsubroutine endtype endwhere entry eor equivalence \
err errmsg exist exit external file flush fmt forall form format \
formatted function go goto id if implicit in include inout \
integer inquire intent interface intrinsic iomsg iolength \
iostat is kind len logical module name named namelist nextrec nml \
none nullify number only open opened operator optional out pad \
parameter pass pause pending pointer pos position precision \
print private procedure program protected public quote read readwrite \
real rec recl recursive result return rewind save select \
selectcase selecttype sequential sign size stat status stop stream \
subroutine target then to type unformatted unit use value \
volatile wait where while write

keywords.$(file.patterns.f95)=$(keywordclass.fortran)
keywords.$(file.patterns.f77)=$(keywordclass.fortran)

# keywords2 is for highlighting intrinsic and extended functions
keywords2.$(file.patterns.fortran)=abs achar acos acosd adjustl adjustr \
aimag aimax0 aimin0 aint ajmax0 ajmin0 akmax0 akmin0 all allocated alog \
alog10 amax0 amax1 amin0 amin1 amod anint any asin asind associated \
atan atan2 atan2d atand bitest bitl bitlr bitrl bjtest bit_size bktest break \
btest cabs ccos cdabs cdcos cdexp cdlog cdsin cdsqrt ceiling cexp char \
clog cmplx conjg cos cosd cosh count cpu_time cshift csin csqrt dabs \
dacos dacosd dasin dasind datan datan2 datan2d datand date \
date_and_time dble dcmplx dconjg dcos dcosd dcosh dcotan ddim dexp \
dfloat dflotk dfloti dflotj digits dim dimag dint dlog dlog10 dmax1 dmin1 \
dmod dnint dot_product dprod dreal dsign dsin dsind dsinh dsqrt dtan dtand \
dtanh eoshift epsilon errsns exp exponent float floati floatj floatk floor fraction \
free huge iabs iachar iand ibclr ibits ibset ichar idate idim idint idnint ieor ifix \
iiabs iiand iibclr iibits iibset iidim iidint iidnnt iieor iifix iint iior iiqint iiqnnt iishft \
iishftc iisign ilen imax0 imax1 imin0 imin1 imod index inint inot int int1 int2 int4 \
int8 iqint iqnint ior ishft ishftc isign isnan izext jiand jibclr jibits jibset jidim jidint \
jidnnt jieor jifix jint jior jiqint jiqnnt jishft jishftc jisign jmax0 jmax1 jmin0 jmin1 \
jmod jnint jnot jzext kiabs kiand kibclr kibits kibset kidim kidint kidnnt kieor kifix \
kind kint kior kishft kishftc kisign kmax0 kmax1 kmin0 kmin1 kmod knint knot kzext \
lbound leadz len len_trim lenlge lge lgt lle llt log log10 logical lshift malloc matmul \
max max0 max1 maxexponent maxloc maxval merge min min0 min1 minexponent minloc \
minval mod modulo mvbits nearest nint not nworkers number_of_processors pack popcnt \
poppar precision present product radix random random_number random_seed range real \
repeat reshape rrspacing rshift scale scan secnds selected_int_kind \
selected_real_kind set_exponent shape sign sin sind sinh size sizeof sngl snglq spacing \
spread sqrt sum system_clock tan tand tanh tiny transfer transpose trim ubound unpack verify

# keywords3 are nonstardard, extended and user defined functions
keywords3.$(file.patterns.fortran)=cdabs cdcos cdexp cdlog cdsin cdsqrt cotan cotand \
dcmplx dconjg dcotan dcotand decode dimag dll_export dll_import doublecomplex dreal \
dvchk encode find flen flush getarg getcharqq getcl getdat getenv gettim hfix ibchng \
identifier imag int1 int2 int4 intc intrup invalop iostat_msg isha ishc ishl jfix \
lacfar locking locnear map nargs nbreak ndperr ndpexc offset ovefl peekcharqq precfill \
prompt qabs qacos qacosd qasin qasind qatan qatand qatan2 qcmplx qconjg qcos qcosd \
qcosh qdim qexp qext qextd qfloat qimag qlog qlog10 qmax1 qmin1 qmod qreal qsign qsin \
qsind qsinh qsqrt qtan qtand qtanh ran rand randu rewrite segment setdat settim system \
timer undfl unlock union val virtual volatile zabs zcos zexp zlog zsin zsqrt

#fold.comment.fortran=1
#fold.quotes.fortran=1

comment.block.fortran=!~

# These setting do not work very well for FORTRAN, uncoment to use it
# statement.indent.$(file.patterns.fortran)=8 associate block blockdata case do enum \
# 	function interface module program subroutine then type where

# Fortran styles
# Default
style.fortran.0=fore:#808080
style.f77.0=fore:#808080
style.fortran.32=
style.f77.32=
# Comment
style.fortran.1=$(colour.code.comment.line),$(font.code.comment.line)
style.f77.1=$(colour.code.comment.line),$(font.code.comment.line)
# Number
style.fortran.2=$(colour.number)
style.f77.2=$(colour.number)
# Single quoted string
style.fortran.3=$(colour.string)
style.f77.3=$(colour.string)
# Double quoted string
style.fortran.4=$(colour.string)
style.f77.4=$(colour.string)
# End of line where string is not closed
style.fortran.5=fore:#000000,back:#E0C0E0,eolfilled
style.f77.5=fore:#000000,back:#E0C0E0,eolfilled
# Operators
style.fortran.6=$(colour.operator),bold
style.f77.6=$(colour.operator),bold
# Identifiers
style.fortran.7=
style.f77.7=
# Keywords
style.fortran.8=$(colour.keyword),case:u
style.f77.8=$(colour.keyword),case:u
# Keywords2
style.fortran.9=fore:#B00040
style.f77.9=fore:#B00040
# Keywords3
style.fortran.10=fore:#B04080
style.f77.10=fore:#B04080
# Preprocessor
style.fortran.11=$(colour.preproc)
style.f77.11=$(colour.preproc)
# Operators in .NAME. format
style.fortran.12=$(colour.operator),bold
style.f77.12=$(colour.operator),bold
# Labels
style.fortran.13=fore:#E0C0E0
style.f77.13=fore:#E0C0E0
# Continuation
style.fortran.14=fore:#000000,back:#F0E080
style.f77.14=fore:#000000,back:#F0E080
# Braces are matched in all cases
braces.fortran.style=0

if PLAT_WIN
	fc77=lf95 $(FileNameExt) -c -fix
	fc90=lf95 $(FileNameExt) -c
if PLAT_GTK
	fc77=f77 -c -o $(FileName).o $(FileNameExt)
	fc90=f90 -c -o $(FileName).o $(FileNameExt)

command.compile.*.f=$(fc77)
command.build.*.f=make
command.go.*.f=$(FileName)

command.compile.*.for=$(fc77)
command.build.*.for=make
command.go.*.for=$(FileName)

command.compile.*.f90=$(fc90)
command.build.*.f90=make
command.go.*.f90=$(FileName)

command.compile.*.f95=$(fc90)
command.build.*.f95=make
command.go.*.f95=$(FileName)

if PLAT_WIN
    api.$(file.patterns.fortran)=$(SciteDefaultHome)\fortran.api

autocomplete.fortran.ignorecase=1
autocomplete.f77.ignorecase=1
calltip.fortran.ignorecase=1
calltip.f77.ignorecase=1

## ==> matlab.properties <==
# Define SciTE settings for Octave and Matlab (see below) files.

# set the default lexer for .m files
DEFAULT_M_LEXER_OCTAVE=1
DEFAULT_M_LEXER_MATLAB=0

#-----------------------------------------------------------------------
# Octave
#-----------------------------------------------------------------------

# M: Octave M-Files (we nee .m.octave for distinguishing it from matlab)
file.patterns.octave=*.m.octave
#~ if DEFAULT_M_LEXER_OCTAVE
	#~ file.patterns.octave=*.m;$(file.patterns.octave)
file.patterns.matlab=*.m;*.m.octave

# M: Octave M-Files
filter.octave=Octave (m)|$(file.patterns.octave)|

lexer.$(file.patterns.octave)=octave

#*language.octave=Octave|m.octave||

keywordclass.octave=\
__FILE__ \
__LINE__ \
break \
case \
catch \
classdef \
continue \
do \
else \
elseif \
end \
end_try_catch \
end_unwind_protect \
endclassdef \
endenumeration \
endevents \
endfor \
endif \
endmethods \
endparfor \
endproperties \
endswitch \
endwhile \
enumeration \
events \
for \
function endfunction \
get \
global \
if \
methods \
otherwise \
parfor \
persistent \
properties \
return \
set \
static \
switch \
try \
until \
unwind_protect \
unwind_protect_cleanup \
while

keywords.$(file.patterns.octave)=$(keywordclass.octave)

comment.block.octave=#

# Octave styles
# White space
style.octave.0=fore:#000000
# Comment
style.octave.1=$(colour.code.comment.line),$(font.code.comment.line)
# Command
style.octave.2=$(colour.preproc)
# Number
style.octave.3=$(colour.number)
# Keyword
style.octave.4=$(colour.keyword),bold
# String (5: single quoted, 8: double quoted)
style.octave.5=$(colour.string)
style.octave.8=$(colour.string)
# Operator
style.octave.6=$(colour.operator),bold
# Identifier
style.octave.7=

#-----------------------------------------------------------------------
# Matlab
#-----------------------------------------------------------------------

# M: Matlab M-Files (we need .m.matlab to distinguish it from octave)
file.patterns.matlab=*.m.matlab
#~ if DEFAULT_M_LEXER_MATLAB
	#~ file.patterns.matlab=*.m;$(file.patterns.matlab)
# M: Matlab M-Files
filter.matlab=Matlab (m)|$(file.patterns.matlab)|

*filter.matlab=$(filter.matlab)

lexer.$(file.patterns.matlab)=matlab

#*language.matlab=Matlab|m.matlab||

keywordclass.matlab=break case catch continue else elseif end for function \
global if otherwise persistent return switch try while

keywords.$(file.patterns.matlab)=$(keywordclass.matlab)

comment.block.matlab=%~

# Matlab styles
# White space
style.matlab.0=fore:#000000
# Comment
style.matlab.1=$(colour.code.comment.line),$(font.code.comment.line)
# Command
style.matlab.2=$(colour.preproc)
# Number
style.matlab.3=$(colour.number)
# Keyword
style.matlab.4=$(colour.keyword),bold
# String (5=single quoted, 8=double quoted)
style.matlab.5=$(colour.string)
style.matlab.8=$(colour.string)
# Operator
style.matlab.6=$(colour.operator),bold
# Identifier
style.matlab.7=


## ==> others.properties <==
# Define SciTE settings for other simple files.

file.patterns.props=*.properties;*.session;*.ini;*.inf;*.url;*.cfg;*.cnf;*.aut
file.patterns.text=*.txt;*.log;*.lst;*.doc;*.diz;*.nfo
file.patterns.batch=*.bat;*.cmd;*.nt
file.patterns.diff=*.diff;*.patch
file.patterns.make=makefile;Makefile;*.mak;configure

*source.patterns.props=$(file.patterns.props);
*source.patterns.batch=$(file.patterns.batch);
*source.patterns.diff=$(file.patterns.diff);
*source.patterns.make=$(file.patterns.make);*.iface;

filter.properties=Properties (ini inf reg url cfg cnf)|$(file.patterns.props)|
filter.text=Text (txt log lst doc diz nfo)|$(file.patterns.text);make*|
filter.batch=Batch (bat cmd nt)|$(file.patterns.batch)|
filter.diff=Difference (diff patch)|$(file.patterns.diff)|

*filter.properties=$(filter.properties)
*filter.text=$(filter.text)

lexer.$(file.patterns.props)=props
lexer.$(file.patterns.batch)=batch
lexer.*.err=errorlist
lexer.$(file.patterns.make)=makefile
lexer.*.iface=makefile
lexer.$(file.patterns.diff)=diff

# *language.batch=&Batch|bat||
# *language.difference=&Difference|diff||
# *language.errorlist=&Errorlist|err||
# *language.properties=&Properties|properties||
*language.makefile=&Makefile|mak|$(keyMake)|
*language._text=Text|txt|$(keyText)|

word.characters.$(file.patterns.text)=$(chars.alpha)$(chars.numeric)$(chars.accented)-'

colour.other.operator=fore:#B06000

# Properties styles

# Default
style.props.0=
# Comment
style.props.1=fore:#007F7F,$(font.comment)
# Section
style.props.2=$(colour.string),back:#E0F0F0,eolfilled
# Assignment operator
style.props.3=$(colour.other.operator)
# Default value (@)
style.props.4=$(colour.preproc)
# Key
style.props.5=
# Matched Operators
style.props.34=fore:#0000FF,notbold
style.props.35=fore:#FF0000,notbold
comment.block.props=#~
preprocessor.symbol.$(file.patterns.make)=!
preprocessor.start.$(file.patterns.make)=IF IFDEF IFNDEF
preprocessor.middle.$(file.patterns.make)=ELSE ELSEIF ELSEIFDEF ELSEIFNDEF
preprocessor.end.$(file.patterns.make)=ENDIF

# Batch styles

# List from http://www.easydos.com/dosindex.html and https://sourceforge.net/p/scintilla/bugs/1686/
# I limit here the commands to those built in command.com, ie. I don't list external Dos commands
# if [no] (test) (command) -- test is EXIST (filename) | (string1)==(string2) | ERRORLEVEL (number)
# for %%(variable) IN (set) DO (command) -- variable is [a-zA-Z] -- eg for %%X in (*.txt) do type %%X
# Also includes device names.
keywordclass.batch=\
assoc aux break call cd chcp chdir choice cls cmdextversion \
color com1 com2 com3 com4 con copy ctty date defined \
del dir do dpath echo else endlocal erase errorlevel exist \
exit for ftype goto if in lpt1 lpt2 lpt3 lpt4 md mkdir move \
not nul path pause popd prompt prn pushd rd rem ren \
rename rmdir set setlocal shift start time title type ver \
verify vol
keywords.$(file.patterns.batch)=$(keywordclass.batch)

# Optional list of external commands to highlight in style 5.
# If not set all commands are highlighted in style 5.
#keywords2.$(file.patterns.batch)=append attrib chkdsk comp diskcomp

# Default
style.batch.0=fore:#000000
# Comment (rem or ::)
style.batch.1=fore:#007F00,$(font.comment)
# Keywords
style.batch.2=$(colour.keyword),bold
# Label (line beginning with ':')
style.batch.3=$(colour.string),back:#606060,fore:#FFFF00,eolfilled
# Hide command character ('@')
style.batch.4=$(colour.preproc)
# External commands
style.batch.5=fore:#007090,$(font.monospace),bold
# Variable: %%x (x is almost whatever, except space and %), %n (n in [0-9]), %EnvironmentVar%
style.batch.6=fore:#800080
# Operator: * ? < > |
style.batch.7=fore:#000000

comment.block.batch=REM ~

# Makefile styles

# Default
style.makefile.0=fore:#000000
# Comment: #
style.makefile.1=$(colour.other.comment),$(font.code.comment.box)
# Pre-processor or other comment: !
style.makefile.2=$(colour.preproc)
# Variable: $(x)
style.makefile.3=fore:#000080
# Operator
style.makefile.4=$(colour.other.operator)
# Target
style.makefile.5=fore:#A00000
# Error
style.makefile.9=$(colour.error),eolfilled
# Matched Operators
style.makefile.34=fore:#0000FF,notbold
style.makefile.35=fore:#FF0000,notbold

comment.block.makefile=#~

# Error list styles

style.errorlist.32=fore:#B06000,$(font.small)
# Default
style.errorlist.0=fore:#000000
# python Error
style.errorlist.1=fore:#FF0000
# gcc Error
style.errorlist.2=fore:#800080
# Microsoft Error
style.errorlist.3=fore:#808000
# command or return status
style.errorlist.4=fore:#0000FF
# Borland error and warning messages
style.errorlist.5=fore:#B06000
# perl error and warning messages
style.errorlist.6=fore:#FF0000
# .NET tracebacks
style.errorlist.7=fore:#FF0000
# Lua error and warning messages
style.errorlist.8=fore:#FF0000
# ctags
style.errorlist.9=fore:#FF00FF
# diff changed !
style.errorlist.10=fore:#007F00
# diff addition +
style.errorlist.11=fore:#00007F
# diff deletion -
style.errorlist.12=fore:#007F7F
# diff message ---
style.errorlist.13=fore:#7F0000
# PHP error
style.errorlist.14=fore:#FF0000
# Essential Lahey Fortran 90 error
style.errorlist.15=fore:#FF0000
# Intel Fortran Compiler error
style.errorlist.16=fore:#FF0000
# Intel Fortran Compiler v8.0 error/warning
style.errorlist.17=fore:#FF0000
# Absoft Pro Fortran 90/95 v8.2 error or warning
style.errorlist.18=fore:#FF0000
# HTML Tidy
style.errorlist.19=fore:#FF0000
# Java runtime stack trace
style.errorlist.20=fore:#FF0000
# Text matched with find in files and message part of GCC errors
style.errorlist.21=fore:#000000
# GCC showing include path to following error
style.errorlist.22=fore:#800080
# Escape sequence
style.errorlist.23=fore:#000000,notvisible,back:#FFFFFF,$(error.background)
# Escape sequence unknown
style.errorlist.24=back:#FFE0A0
# Ensures that spacing is not affected by line number styles
style.errorlist.33=$(font.small)
# Basic colours
style.errorlist.40=fore:#000000,$(error.background)
style.errorlist.41=fore:#800000,$(error.background)
style.errorlist.42=fore:#008000,$(error.background)
style.errorlist.43=fore:#808000,$(error.background)
style.errorlist.44=fore:#000080,$(error.background)
style.errorlist.45=fore:#800080,$(error.background)
style.errorlist.46=fore:#008080,$(error.background)
style.errorlist.47=fore:#A0A0A0,$(error.background)
# Intense colours
style.errorlist.48=fore:#000000,bold,$(error.background)
style.errorlist.49=fore:#800000,bold,$(error.background)
style.errorlist.50=fore:#008000,bold,$(error.background)
style.errorlist.51=fore:#808000,bold,$(error.background)
style.errorlist.52=fore:#000080,bold,$(error.background)
style.errorlist.53=fore:#800080,bold,$(error.background)
style.errorlist.54=fore:#008080,bold,$(error.background)
style.errorlist.55=fore:#A0A0A0,bold,$(error.background)

error.background=back:#FFF7E7,eolfilled

lexer.errorlist.value.separate=1
#lexer.errorlist.escape.sequences=1

# Difference styles

# Default
style.diff.0=fore:#000000
# Comment (part before "diff ..." or "--- ..." and , Only in ..., Binary file...)
style.diff.1=fore:#007F00
# Command (diff ...)
style.diff.2=fore:#7F7F00
# Source file (--- ...) and Destination file (+++ ...)
style.diff.3=fore:#7F0000
# Position setting (@@ ...)
style.diff.4=fore:#7F007F
# Line removal (-...)
style.diff.5=fore:#007F7F
# Line addition (+...)
style.diff.6=fore:#00007F
# Line change (!...)
style.diff.7=fore:#7F7F7F

command.build.makefile=make
command.build.*.mak=make

command.help.*.properties="file://$(SciteDefaultHome)/SciTEDoc.html#property-$(CurrentSelection)"
command.help.subsystem.*.properties=2

if PLAT_WIN
	command.go.*.bat="$(FileNameExt)"
	command.name.0.*.bat=Execute Selection
	command.0.*.bat=$(CurrentSelection)
	command.name.9.*.mak=nmake
	command.9.*.mak=nmake -f $(FileNameExt)

## ==> pascal.properties <==
# Define SciTE settings for Pascal files.
# Changed by Fernando Lozano <fsl@centroin.com.br> for Free Pascal
# Changed by Mathias Rauen <scite@madshi.net> for Delphi
# Changed by Marko Njezic <sf@maxempire.com> to match new LexPascal lexer and updated for Delphi XE4

filter.pascal=Pascal (dpr dpk pas dfm inc pp)|*.dpr;*.dpk;*.pas;*.dfm;*.inc;*.pp|

*filter.pascal=$(filter.pascal)

file.patterns.pascal=*.dpr;*.pas;*.dfm;*.inc;*.pp
file.patterns.pascal.package=*.dpk
file.patterns.pascal.all=$(file.patterns.pascal);$(file.patterns.pascal.package)
lexer.$(file.patterns.pascal.all)=pascal
#*language.pascal=Pascal|pas||

keywordclass.pascal=absolute abstract and array as asm assembler automated begin case \
cdecl class const constructor delayed deprecated destructor dispid dispinterface \
div do downto dynamic else end except experimental export exports external far \
file final finalization finally for forward function goto helper if \
implementation in inherited initialization inline interface is label library \
message mod near nil not object of on operator or out overload override packed \
pascal platform private procedure program property protected public published \
raise record reference register reintroduce repeat resourcestring safecall \
sealed set shl shr static stdcall strict string then threadvar to try type unit \
unsafe until uses var varargs virtual while winapi with xor

keywordclass.pascal.smart=add default implements index name nodefault read readonly \
remove stored write writeonly

keywordclass.pascal.package=package contains requires

keywords.$(file.patterns.pascal)=$(keywordclass.pascal) $(keywordclass.pascal.smart)
keywords.$(file.patterns.pascal.package)=$(keywordclass.pascal) $(keywordclass.pascal.smart) $(keywordclass.pascal.package)

# If enabled some keywords will only be highlightend in appropriate context.
# As implemented those are keywords related to property and DLL exports declarations
lexer.pascal.smart.highlighting=1

# Pascal styles

# Default
style.pascal.32=$(font.base)
# White space
style.pascal.0=fore:#808080
# Identifiers
style.pascal.1=
# Comment: { ... }
style.pascal.2=$(colour.code.comment.box),$(font.code.comment.box)
# Comment: (* ... *)
style.pascal.3=$(colour.code.comment.box),$(font.code.comment.box)
# Line Comment: // ...
style.pascal.4=$(colour.code.comment.line),$(font.code.comment.line)
# Preprocessor: {$ ... }
style.pascal.5=$(colour.preproc)
# Preprocessor: (*$ ... *)
style.pascal.6=$(colour.preproc)
# Number
style.pascal.7=$(colour.number)
# Hex Number
style.pascal.8=$(colour.number)
# Keyword
style.pascal.9=$(colour.keyword),bold
# String
style.pascal.10=$(colour.string)
# End of line where string is not closed
style.pascal.11=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled
# Character
style.pascal.12=$(colour.char)
# Operators
style.pascal.13=$(colour.operator),bold
# Inline Asm
style.pascal.14=fore:#804080

# Braces are only matched in operator style
braces.pascal.style=13

comment.block.pascal=//~
comment.stream.start.pascal={
comment.stream.end.pascal=}
comment.box.start.pascal=(*
comment.box.middle.pascal= *
comment.box.end.pascal= *)

statement.indent.$(file.patterns.pascal)=9 case class do else for then \
private protected public published repeat try while type
statement.end.$(file.patterns.pascal)=13 ;
statement.lookback.$(file.patterns.pascal)=20
block.start.$(file.patterns.pascal)=9 begin
block.end.$(file.patterns.pascal)=9 end

#using virtual pascal
#pc=C:\Vp21\Bin.w32\Vpc.exe -VC:\Vp21\Bin.w32\Vp.vpo "$(FilePath)"

#using free pascal

# compile
command.compile.*.pas=fpc "$(FilePath)"

# normal execute
if PLAT_WIN
	command.go.*.pas="$(FileName).exe"
	command.go.subsystem.*.pas=2
if PLAT_GTK
	command.go.*.pas="kvt -e $(FileName)"

# build
command.build.*.pas=fpc -B "$(FilePath)"
command.build.subsystem.*.pas=1

command.name.0.*.pas=Debug Compile
command.0.*.pas=fpc -g "$(FilePath)"
command.name.9.*.pas=Debug Build
command.9.*.pas=fpc -g -B "$(FilePath)"
command.name.2.*.pas=GDB
if PLAT_WIN
	command.2.*.pas=gdbpasw "$(FileName)"
if PLAT_GTK
	command.2.*.pas=gdb "$(FileName)"
	command.name.3.*.pas=DDD
	command.3.*.pas=ddd "$(FileName)"


## ==> registry.properties <==
# Define SciTE settings for registry files.

file.patterns.registry=*.reg
filter.registry=Registration files (reg)|$(file.patterns.registry)|
lexer.$(file.patterns.registry)=registry

comment.block.registry=;;

[Styles]

style.registry.32=$(font.text)
# Default
style.registry.0=fore:#000000
# Comment: ;;
style.registry.1=$(colour.code.comment.line)
# Value name: "Icon"="cmd.exe,-1"
style.registry.2=fore:#0000FF
# String
style.registry.3=$(colour.string)
# Hex digit
style.registry.4=fore:#7F0B0C
# Value type: dword, hex(2), hex(7)
style.registry.5=fore:#00007F,bold
# Added key, [HKLM\*\shell\notepad]
style.registry.6=fore:#530155
# Removed key, [-HKLM\*\shell\notepad]
style.registry.7=fore:#FF0000
# Escaped characters in strings
style.registry.8=fore:#7D8187,bold
# GUID in key path, [HKCU\{C4ACBD3E-6114-4618-904C-B206ABA9DEB0}]
style.registry.9=fore:#7B5F15
# GUID in string, @="{C4ACBD3E-6114-4618-904C-B206ABA9DEB0}"
style.registry.10=$(style.registry.9)
# Parameter: "notepad.exe %1 %*"
style.registry.11=fore:#0B6561
# Operators
style.registry.12=bold

## ==> sql.properties <==
# Define SciTE settings for SQL and PL/SQL files.

filter.sql=SQL (sql)|*.sql|

*filter.sql=$(filter.sql)

file.patterns.sql=*.sql
file.patterns.plsql=*.spec;*.body;*.sps;*.spb;*.sf;*.sp

lexer.$(file.patterns.sql)=sql
lexer.$(file.patterns.plsql)=sql

#*language.sql=S&QL|sql||

#*language.plsql=P&LSQL|spec||

# SQL styles
# White space
style.sql.0=fore:#808080
# Comment
style.sql.1=fore:#007F00,$(font.comment)
# Line Comment
style.sql.2=fore:#007F00,$(font.comment)
# Doc comment
style.sql.3=fore:#7F7F7F
# Number
style.sql.4=fore:#007F7F
# Keyword
style.sql.5=fore:#00007F,bold
# Double quoted string
style.sql.6=fore:#7F007F,$(font.monospace)
# Single quoted string
style.sql.7=fore:#7F007F,$(font.monospace)
# SQL*Plus
style.sql.8=$(colour.preproc)
# SQL*Plus PROMPT
style.sql.9=fore:#007F00,$(font.monospace),back:#E0FFE0,eolfilled
# Operators
style.sql.10=bold
# Identifiers
style.sql.11=
# Not used
#style.sql.12=fore:#000000,$(font.monospace),back:#E0C0E0,eolfilled
# SQL*Plus Comment
style.sql.13=fore:#007F00,$(font.comment)
# not used
# style.sql.14=
# Hash Line Comment
style.sql.15=fore:#007F00,$(font.comment)
# Keywords2: Database objects
style.sql.16=fore:#B00040
# Comment Doc Keyword
style.sql.17=fore:#3060A0,$(font.code.comment.doc)
# Comment Doc Keyword Error
style.sql.18=fore:#804020,$(font.code.comment.doc)
# Keywords5: User Keywords 1
style.sql.19=fore:#4B0082
# Keywords6: User Keywords 2
style.sql.20=fore:#B00040
# Keywords7: User Keywords 3
style.sql.21=fore:#8B0000
# Keywords8: User Keywords 4
style.sql.22=fore:#800080
# Quoted identifier
style.sql.23=fore:#DD9900
# Q operator
style.sql.24=fore:#EE00AA

# Braces are only matched in operator style
braces.sql.style=10
# Enables backslash as an escape character
#sql.backslash.escapes=1

# Activate '#' based comments for MySQL with 1 or disable for Oracle with 0:
#lexer.sql.numbersign.comment=0

# Set to 1 to colourise recognized words with dots
# (recommended for Oracle PL/SQL objects)
#lexer.sql.allow.dotted.word=1

#lexer.sql.backticks.identifier=1

keywords.$(file.patterns.sql)=\
absolute action add admin after aggregate \
alias all allocate alter and any are array as asc \
assertion at authorization \
before begin binary bit blob body boolean both breadth by \
call cascade cascaded case cast catalog char character \
check class clob close collate collation column commit \
completion connect connection constraint constraints \
constructor continue corresponding create cross cube current \
current_date current_path current_role current_time current_timestamp \
current_user cursor cycle \
data date day deallocate dec decimal declare default \
deferrable deferred delete depth deref desc describe descriptor \
destroy destructor deterministic dictionary diagnostics disconnect \
distinct domain double drop dynamic \
each else end end-exec equals escape every except \
exception exec execute exists exit external \
false fetch first float for foreign found from free full \
function \
general get global go goto grant group grouping \
having host hour \
identity if ignore immediate in indicator initialize initially \
inner inout input insert int integer intersect interval \
into is isolation iterate \
join \
key \
language large last lateral leading left less level like \
limit local localtime localtimestamp locator \
map match merge minute modifies modify module month \
names national natural nchar nclob new next no none \
not null numeric \
object of off old on only open operation option \
or order ordinality out outer output \
package pad parameter parameters partial path postfix precision prefix \
preorder prepare preserve primary \
prior privileges procedure public \
read reads real recursive ref references referencing relative \
restrict result return returns revoke right \
role rollback rollup routine row rows \
savepoint schema scroll scope search second section select \
sequence session session_user set sets size smallint some| space \
specific specifictype sql sqlexception sqlstate sqlwarning start \
state statement static structure system_user \
table temporary terminate than then time timestamp \
timezone_hour timezone_minute to trailing transaction translation \
treat trigger true \
under union unique unknown \
unnest update usage user using \
value values varchar variable varying view \
when whenever where with without work write \
year \
zone

keywords.$(file.patterns.plsql)=\
all alter and any array as asc at authid avg begin between \
binary_integer \
body boolean bulk by char char_base check close cluster collect \
comment commit compress connect constant create current currval \
cursor date day declare decimal default delete desc distinct \
do drop else elsif end exception exclusive execute exists exit \
extends false fetch float for forall from function goto group \
having heap hour if immediate in index indicator insert integer \
interface intersect interval into is isolation java level like \
limited lock long loop max min minus minute mlslabel mod mode \
month natural naturaln new nextval nocopy not nowait null number \
number_base ocirowid of on opaque open operator option or order \
organization others out package partition pctfree pls_integer \
positive positiven pragma prior private procedure public raise \
range raw real record ref release return reverse rollback row \
rowid rownum rowtype savepoint second select separate set share \
smallint space sql sqlcode sqlerrm start stddev subtype successful \
sum synonym sysdate table then time timestamp to trigger true \
type uid union unique update use user validate values varchar \
varchar2 variance view when whenever where while with work write \
year zone

# Keywords for PlDoc comments
keywords3.$(file.patterns.sql)=\
param author since return see deprecated todo

# Keywords for SQL*Plus
keywords4.$(file.patterns.sql)=\
acc~ept a~ppend archive log attribute \
bre~ak bti~tle \
c~hange cl~ear col~umn comp~ute conn~ect copy \
def~ine del desc~ribe disc~onnect \
e~dit exec~ute exit \
get \
help ho~st \
i~nput \
l~ist \
passw~ord pau~se pri~nt pro~mpt \
quit \
recover rem~ark repf~ooter reph~eader r~un \
sav~e set sho~w shutdown spo~ol sta~rt startup store \
timi~ng tti~tle \
undef~ine \
var~iable \
whenever oserror whenever sqlerror \

# User keywords 1
# Keywords for Standard packages
keywords5.$(file.patterns.sql)=\
dbms_output.disable dbms_output.enable dbms_output.get_line \
dbms_output.get_lines dbms_output.new_line dbms_output.put \
dbms_output.put_line \

## ==> tcl.properties <==
# Define SciTE settings for tcl and itcl files.

file.patterns.tcl=*.tcl;*.exp
file.patterns.itcl=*.itcl
file.patterns.tcl.like=$(file.patterns.tcl);$(file.patterns.itcl);

filter.tcl=Tcl (tcl)|$(file.patterns.tcl)|
filter.itcl=itcl (itcl)|$(file.patterns.itcl)|

*filter.tcl=$(filter.tcl)

lexer.$(file.patterns.tcl)=tcl
lexer.$(file.patterns.itcl)=tcl

#*language.tcl=&TCL|tcl||

keywordclass.tcl=after append array auto_execok \
auto_import auto_load auto_load_index auto_qualify \
beep bgerror binary break case catch cd clock \
close concat continue dde default echo else elseif \
encoding eof error eval exec exit expr fblocked \
fconfigure fcopy file fileevent flush for foreach format \
gets glob global history http if incr info \
interp join lappend lindex linsert list llength load \
loadTk lrange lreplace lsearch lset lsort memory msgcat \
namespace open package pid pkg::create pkg_mkIndex Platform-specific proc \
puts pwd re_syntax read regexp registry regsub rename \
resource return scan seek set socket source split \
string subst switch tclLog tclMacPkgSearch tclPkgSetup tclPkgUnknown tell \
time trace unknown unset update uplevel upvar variable \
vwait while

keywordclass.tk=bell bind bindtags bitmap button canvas checkbutton clipboard \
colors console cursors destroy entry event focus font \
frame grab grid image Inter-client keysyms label labelframe \
listbox lower menu menubutton message option options pack \
panedwindow photo place radiobutton raise scale scrollbar selection \
send spinbox text tk tk_chooseColor tk_chooseDirectory tk_dialog tk_focusNext \
tk_getOpenFile tk_messageBox tk_optionMenu tk_popup tk_setPalette tkerror tkvars tkwait \
toplevel winfo wish wm

keywordclass.itcl=@scope body class code common component configbody \
constructor define destructor hull import inherit itcl itk itk_component \
itk_initialize itk_interior itk_option iwidgets keep method \
private protected public

keywordclass.TkCommands=tk_bisque tk_chooseColor tk_dialog tk_focusFollowsMouse tk_focusNext \
tk_focusPrev tk_getOpenFile tk_getSaveFile tk_messageBox tk_optionMenu \
tk_popup tk_setPalette tk_textCopy tk_textCut tk_textPaste \
tkButtonAutoInvoke tkButtonDown tkButtonEnter tkButtonInvoke tkButtonLeave \
tkButtonUp tkCancelRepeat tkCheckRadioDown tkCheckRadioEnter tkCheckRadioInvoke \
tkColorDialog tkColorDialog_BuildDialog tkColorDialog_CancelCmd tkColorDialog_Config tkColorDialog_CreateSelector \
tkColorDialog_DrawColorScale tkColorDialog_EnterColorBar tkColorDialog_HandleRGBEntry tkColorDialog_HandleSelEntry tkColorDialog_InitValues \
tkColorDialog_LeaveColorBar tkColorDialog_MoveSelector tkColorDialog_OkCmd tkColorDialog_RedrawColorBars tkColorDialog_RedrawFinalColor \
tkColorDialog_ReleaseMouse tkColorDialog_ResizeColorBars tkColorDialog_RgbToX tkColorDialog_SetRGBValue tkColorDialog_StartMove \
tkColorDialog_XToRgb tkConsoleAbout tkConsoleBind tkConsoleExit tkConsoleHistory \
tkConsoleInit tkConsoleInsert tkConsoleInvoke tkConsoleOutput tkConsolePrompt \
tkConsoleSource tkDarken tkEntryAutoScan tkEntryBackspace tkEntryButton1 \
tkEntryClosestGap tkEntryGetSelection tkEntryInsert tkEntryKeySelect tkEntryMouseSelect \
tkEntryNextWord tkEntryPaste tkEntryPreviousWord tkEntrySeeInsert tkEntrySetCursor \
tkEntryTranspose tkEventMotifBindings tkFDGetFileTypes tkFirstMenu tkFocusGroup_BindIn \
tkFocusGroup_BindOut tkFocusGroup_Create tkFocusGroup_Destroy tkFocusGroup_In tkFocusGroup_Out \
tkFocusOK tkGenerateMenuSelect tkIconList tkIconList_Add tkIconList_Arrange \
tkIconList_AutoScan tkIconList_Btn1 tkIconList_Config tkIconList_Create tkIconList_CtrlBtn1 \
tkIconList_Curselection tkIconList_DeleteAll tkIconList_Double1 tkIconList_DrawSelection tkIconList_FocusIn \
tkIconList_FocusOut tkIconList_Get tkIconList_Goto tkIconList_Index tkIconList_Invoke \
tkIconList_KeyPress tkIconList_Leave1 tkIconList_LeftRight tkIconList_Motion1 tkIconList_Reset \
tkIconList_ReturnKey tkIconList_See tkIconList_Select tkIconList_Selection tkIconList_ShiftBtn1 \
tkIconList_UpDown tkListbox tkListboxAutoScan tkListboxBeginExtend tkListboxBeginSelect \
tkListboxBeginToggle tkListboxCancel tkListboxDataExtend tkListboxExtendUpDown tkListboxKeyAccel_Goto \
tkListboxKeyAccel_Key tkListboxKeyAccel_Reset tkListboxKeyAccel_Set tkListboxKeyAccel_Unset tkListboxMotion \
tkListboxSelectAll tkListboxUpDown tkMbButtonUp tkMbEnter tkMbLeave \
tkMbMotion tkMbPost tkMenuButtonDown tkMenuDownArrow tkMenuDup \
tkMenuEscape tkMenuFind tkMenuFindName tkMenuFirstEntry tkMenuInvoke \
tkMenuLeave tkMenuLeftArrow tkMenuMotion tkMenuNextEntry tkMenuNextMenu \
tkMenuRightArrow tkMenuUnpost tkMenuUpArrow tkMessageBox tkMotifFDialog \
tkMotifFDialog_ActivateDList tkMotifFDialog_ActivateFEnt tkMotifFDialog_ActivateFList tkMotifFDialog_ActivateSEnt tkMotifFDialog_BrowseDList \
tkMotifFDialog_BrowseFList tkMotifFDialog_BuildUI tkMotifFDialog_CancelCmd tkMotifFDialog_Config tkMotifFDialog_Create \
tkMotifFDialog_FileTypes tkMotifFDialog_FilterCmd tkMotifFDialog_InterpFilter tkMotifFDialog_LoadFiles tkMotifFDialog_MakeSList \
tkMotifFDialog_OkCmd tkMotifFDialog_SetFilter tkMotifFDialog_SetListMode tkMotifFDialog_Update tkPostOverPoint \
tkRecolorTree tkRestoreOldGrab tkSaveGrabInfo tkScaleActivate tkScaleButton2Down \
tkScaleButtonDown tkScaleControlPress tkScaleDrag tkScaleEndDrag tkScaleIncrement \
tkScreenChanged tkScrollButton2Down tkScrollButtonDown tkScrollButtonDrag tkScrollButtonUp \
tkScrollByPages tkScrollByUnits tkScrollDrag tkScrollEndDrag tkScrollSelect \
tkScrollStartDrag tkScrollTopBottom tkScrollToPos tkTabToWindow tkTearOffMenu \
tkTextAutoScan tkTextButton1 tkTextClosestGap tkTextInsert tkTextKeyExtend \
tkTextKeySelect tkTextNextPara tkTextNextPos tkTextNextWord tkTextPaste \
tkTextPrevPara tkTextPrevPos tkTextPrevWord tkTextResetAnchor tkTextScrollPages \
tkTextSelectTo tkTextSetCursor tkTextTranspose tkTextUpDownLine tkTraverseToMenu \
tkTraverseWithinMenu

keywords.$(file.patterns.tcl.like)=$(keywordclass.tcl)
keywords2.$(file.patterns.tcl.like)=$(keywordclass.tk)
keywords3.$(file.patterns.tcl.like)= $(keywordclass.TkCommands)
keywords4.$(file.patterns.itcl)=$(keywordclass.itcl)
keywords5.$(file.patterns.tcl.like)=expand

comment.block.tcl=#~
# also suported is #- for start/end of box, box.middle # can be in column 1
comment.box.start.tcl=##
comment.box.middle.tcl= #
comment.box.end.tcl= ##

# tcl styles
# Default
style.tcl.32=$(font.base)
# White space
style.tcl.0=fore:#808080
# Comment:.....; #comment
style.tcl.1=$(colour.code.comment.line),$(font.comment),back:#f0FFE0
# Line Comment:  #comment
style.tcl.2=$(colour.code.comment.line),$(font.code.comment.line)
# Number and hex number (syntax #[0-f]+)
style.tcl.3=$(colour.number)
# Keyword in quote
style.tcl.4=$(colour.string),bold,back:#FFF0F0
# In quote
style.tcl.5=$(colour.string),back:#FFf0f0,eolfilled
# operator
style.tcl.6=$(colour.operator),bold
# Identifiers
style.tcl.7=$(colour.keyword)
# Substitution
style.tcl.8=$(colour.preproc)
# Substitution starts with a brace ${woow}
style.tcl.9=$(colour.preproc),back:#effff0
# Modifier -xxx
style.tcl.10=$(colour.char)
# Expand (what and odd syntax)
style.tcl.11=$(colour.keyword),back:#FFFF80,bold
# Keywords
style.tcl.12=$(colour.keyword),bold
# Keywords 2
style.tcl.13=$(colour.keyword),back:#e0ffff,bold
# Keywords 3
style.tcl.14=$(colour.keyword),back:#FFf0f0,bold
# Keywords 4
style.tcl.15=$(colour.keyword),back:#FFD0D0,bold
# Other keywords (bozo test colors :-)
# Keywords 5
style.tcl.16=$(style.tcl.7),back:#FFD0FF,bold
# Keywords 6
style.tcl.17=$(style.tcl.7),back:#FFFFD0,bold
# Keywords 7
style.tcl.18=$(style.tcl.7),back:#FFA0A0,bold,
# Keywords 8
style.tcl.19=$(style.tcl.7),back:#FFD0D0
#comment box
style.tcl.20=$(colour.code.comment.box),$(font.code.comment.box),back:#f0FFf0,eolfilled
#comment block
style.tcl.21=$(colour.embedded.comment),$(font.embedded.comment),back:#f0FFf0

# Matched Operators
style.tcl.34=fore:#f0f0f0,bold,back:#7070ff
style.tcl.35=fore:#FF0000,bold,back:#FF00FF

# Braces are only matched in operator style
braces.tcl.style=6

## ==> vb.properties <==
# Define SciTE settings for VB files.

# BAS: Module, FRM: Form, CLS: Class Module, CTL: User Control
# PAG: Property Page, DSR: Data Report, DOB: User Document
file.patterns.vb=*.vb;*.bas;*.frm;*.cls;*.ctl;*.pag;*.dsr;*.dob
# VBS: VBScript, DSM: Visual[ex. Dev] Studio macro
file.patterns.wscript=*.vbs;*.dsm

*source.patterns.vb=$(file.patterns.vb);$(file.patterns.wscript);

# VBP: VB Project, VBG: VB Project Group (ActiveX), MAK: old (VB3) project file, VBW: VB Workspace
filter.vb=VB (vb vbp vbs bas frm cls ctl pag dsr dob)|$(file.patterns.vb);$(file.patterns.wscript);*.vbp;*.vbg;*.mak;*.vbw|

*filter.vb=$(filter.vb)

lexer.$(file.patterns.vb)=vb
lexer.$(file.patterns.wscript)=vbscript

#*language.vb=&VB|vb||
#*language.vbscript=VBScr&ipt|vbs||

# Keywords, operators, statements, data types and some words in .frm files
keywordclass.vb6=\
addressof alias and as attribute base begin binary boolean byref byte byval call case cdbl \
cint clng compare const csng cstr currency date decimal declare defbool defbyte defcur \
defdate defdbl defdec defint deflng defobj defsng defstr defvar dim do double each else \
elseif empty end enum eqv erase error event exit explicit false for friend function get \
global gosub goto if imp implements in input integer is len let lib like load lock long \
loop lset me mid midb mod new next not nothing null object on option optional or paramarray \
preserve print private property public raiseevent randomize redim rem resume return rset \
seek select set single static step stop string sub text then time to true type typeof \
unload until variant wend while with withevents xor

# html.properties picks up VB keywords from keywordclass.vb
keywordclass.vb=$(keywordclass.vb6)

# Mostly system statements (files, registry, I/O...) that
# I am not sure to include with the regular statements.
keywordclass.vbotherstatements=\
appactivate beep chdir chdrive close filecopy get input kill line unlock mkdir name \
open print put reset rmdir savepicture savesetting seek sendkeys setattr width write

# VBNet specific keywords
keywordclass.vbnet=\
addhandler andalso ansi assembly auto catch cbool cbyte cchar cdate cdec char class \
cobj continue csbyte cshort ctype cuint culng cushort custom default delegate directcast \
endif externalsource finally gettype handles imports inherits interface isfalse isnot \
istrue module mustinherit mustoverride my mybase myclass namespace narrowing notinheritable \
notoverridable of off operator orelse overloads overridable overrides partial protected \
readonly region removehandler sbyte shadows shared short strict structure synclock \
throw try trycast uinteger ulong unicode ushort using when widening writeonly

keywords.$(file.patterns.vb)=$(keywordclass.vb6) $(keywordclass.vbnet)
keywords.$(file.patterns.wscript)=$(keywordclass.vb6)

keywords2.$(file.patterns.vb)=$(keywordclass.vbotherstatements)

comment.block.vb='~
comment.block.vbscript='~
# VB styles

# Default
style.vb.32=$(font.base)
# White space
style.vb.0=
# Comment
style.vb.1=$(colour.code.comment.line),$(font.code.comment.line)
# Number
style.vb.2=$(colour.number)
# Keyword
style.vb.3=$(colour.keyword)
# String
style.vb.4=$(colour.string)
# Preprocessor (directives)
style.vb.5=$(colour.preproc)
# Operator
style.vb.6=$(colour.operator)
# Identifier
style.vb.7=
# Date
style.vb.8=$(colour.number)
# End of line where string is not closed
style.vb.9=$(style.stringeol)
# Other keywords (bozo test colors :-)
style.vb.10=$(style.vb.5),back:#D0FFD0
style.vb.11=$(style.vb.5),back:#D0D0FF
style.vb.12=$(style.vb.5),back:#FFD0D0

# VBScript styles same as VB styles
style.vbscript.0=$(style.vb.0)
style.vbscript.1=$(style.vb.1)
style.vbscript.2=$(style.vb.2)
style.vbscript.3=$(style.vb.3)
style.vbscript.4=$(style.vb.4)
style.vbscript.5=$(style.vb.5)
style.vbscript.6=$(style.vb.6)
style.vbscript.7=$(style.vb.7)
style.vbscript.8=$(style.vb.8)
style.vbscript.9=$(style.vb.9)
style.vbscript.10=$(style.vb.10)
style.vbscript.11=$(style.vb.11)
style.vbscript.12=$(style.vb.12)

# wscript
# normal execute
command.go.$(file.patterns.wscript)="$(FilePath)"
command.go.subsystem.$(file.patterns.wscript)=2

# note we have no real "build"; rather "execute and capture
# compiletime and runtime errors"
command.build.$(file.patterns.wscript)=cscript "$(FilePath)"
command.build.subsystem.$(file.patterns.wscript)=1

command.help.$(file.patterns.wscript)=$(CurrentWord)!C:\Program Files\Microsoft Visual Studio\MSDN\2001OCT\1033\MSDN130.COL
command.help.subsystem.$(file.patterns.wscript)=4
command.help.$(file.patterns.vb)=$(CurrentWord)!C:\Program Files\Microsoft Visual Studio\MSDN\2001OCT\1033\MSDN130.COL
command.help.subsystem.$(file.patterns.vb)=4

## ==> yaml.properties <==
# Define SciTE settings for YAML files.

# associate YAML file patter with the YAML lexer
file.patterns.yaml=*.yaml;*.yml
filter.yaml=YAML (yaml)|$(file.patterns.yaml)|
*filter.yaml=$(filter.yaml)
lexer.$(file.patterns.yaml)=yaml
#*language.yaml=YAML|yaml||

# YAML requires spaces for tabs
tabsize.$(file.patterns.yaml)=2
indent.size.$(file.patterns.yaml)=2
use.tabs.$(file.patterns.yaml)=0

# YAML comment character
comment.block.yaml=#~

# YAML convertible values
keywords.$(file.patterns.yaml)=true false yes no

# YAML font styles
# default
style.yaml.0=$(font.text),fore:#000000
# comment line
style.yaml.1=$(font.comment),fore:#008800
# value identifier
style.yaml.2=$(font.base),fore:#000088,bold
# keyword value
style.yaml.3=$(font.base),fore:#880088
# numerical value
style.yaml.4=$(font.base),fore:#880000
# reference/repeating value
style.yaml.5=$(font.base),fore:#008888
# document delimiting line
style.yaml.6=$(font.comment),fore:#FFFFFF,bold,back:#000088,eolfilled
# text block marker
style.yaml.7=$(font.text),fore:#333366
# syntax error marker
style.yaml.8=$(font.text),fore:#FFFFFF,italics,bold,back:#FF0000,eolfilled
# operator
style.yaml.9=$(colour.operator)

## ==> conf.properties <==
# Define SciTE settings for Apache Configuration files.
# contributed by Ahmad Zawawi <zeus_go64@hotmail.com>

file.patterns.conf=*.conf;.htaccess
*source.patterns.conf=$(file.patterns.conf);
filter.conf=Apache Conf (conf)|$(file.patterns.conf)|
*filter.apacheconfig=$(filter.conf)
lexer.$(file.patterns.conf)=conf
#*language.apacheconfig=Apache Confi&g|conf||
# for future implemention...
#api.$(file.patterns.conf)=conf.api

# Keywords for Apache's Runtime directives
keywords.$(file.patterns.conf)=\
acceptmutex acceptpathinfo accessconfig accessfilename \
action addalt addaltbyencoding addaltbytype addcharset \
adddefaultcharset adddescription addencoding \
addhandler addicon addiconbyencoding addiconbytype \
addinputfilter addlanguage addmodule addmoduleinfo \
addoutputfilter addoutputfilterbytype addtype agentlog \
alias aliasmatch all allow allowconnect \
allowencodedslashes allowoverride anonymous \
anonymous_authoritative anonymous_logemail \
anonymous_mustgiveemail anonymous_nouserid \
anonymous_verifyemail assignuserid authauthoritative \
authdbauthoritative authdbgroupfile \
authdbmauthoritative authdbmgroupfile authdbmtype \
authdbmuserfile authdbuserfile authdigestalgorithm \
authdigestdomain authdigestfile authdigestgroupfile \
authdigestnccheck authdigestnonceformat \
authdigestnoncelifetime authdigestqop \
authdigestshmemsize authgroupfile \
authldapauthoritative authldapbinddn \
authldapbindpassword authldapcharsetconfig \
authldapcomparednonserver authldapdereferencealiases \
authldapenabled authldapfrontpagehack \
authldapgroupattribute authldapgroupattributeisdn \
authldapremoteuserisdn authldapurl authname authtype \
authuserfile bindaddress browsermatch \
browsermatchnocase bs2000account bufferedlogs \
cachedefaultexpire cachedirlength cachedirlevels \
cachedisable cacheenable cacheexpirycheck cachefile \
cacheforcecompletion cachegcclean cachegcdaily \
cachegcinterval cachegcmemusage cachegcunused \
cacheignorecachecontrol cacheignoreheaders \
cacheignorenolastmod cachelastmodifiedfactor \
cachemaxexpire cachemaxfilesize cacheminfilesize \
cachenegotiateddocs cacheroot cachesize \
cachetimemargin cgimapextension charsetdefault \
charsetoptions charsetsourceenc checkspelling \
childperuserid clearmodulelist contentdigest \
cookiedomain cookieexpires cookielog cookiename \
cookiestyle cookietracking coredumpdirectory customlog \
dav davdepthinfinity davlockdb davmintimeout \
defaulticon defaultlanguage defaulttype define \
deflatebuffersize deflatecompressionlevel \
deflatefilternote deflatememlevel deflatewindowsize \
deny directory directoryindex directorymatch \
directoryslash documentroot dumpioinput dumpiooutput \
enableexceptionhook enablemmap enablesendfile \
errordocument errorlog example expiresactive \
expiresbytype expiresdefault extendedstatus \
extfilterdefine extfilteroptions fancyindexing \
fileetag files filesmatch forcelanguagepriority \
forcetype forensiclog from group header headername \
hostnamelookups identitycheck ifdefine ifmodule \
imapbase imapdefault imapmenu include indexignore \
indexoptions indexorderdefault isapiappendlogtoerrors \
isapiappendlogtoquery isapicachefile isapifakeasync \
isapilognotsupported isapireadaheadbuffer keepalive \
keepalivetimeout languagepriority ldapcacheentries \
ldapcachettl ldapconnectiontimeout ldapopcacheentries \
ldapopcachettl ldapsharedcachefile ldapsharedcachesize \
ldaptrustedca ldaptrustedcatype limit limitexcept \
limitinternalrecursion limitrequestbody \
limitrequestfields limitrequestfieldsize \
limitrequestline limitxmlrequestbody listen \
listenbacklog loadfile loadmodule location \
locationmatch lockfile logformat loglevel maxclients \
maxkeepaliverequests maxmemfree maxrequestsperchild \
maxrequestsperthread maxspareservers maxsparethreads \
maxthreads maxthreadsperchild mcachemaxobjectcount \
mcachemaxobjectsize mcachemaxstreamingbuffer \
mcacheminobjectsize mcacheremovalalgorithm mcachesize \
metadir metafiles metasuffix mimemagicfile \
minspareservers minsparethreads mmapfile \
modmimeusepathinfo multiviewsmatch namevirtualhost \
nocache noproxy numservers nwssltrustedcerts \
nwsslupgradeable options order passenv pidfile port \
protocolecho proxy proxybadheader proxyblock \
proxydomain proxyerroroverride proxyiobuffersize \
proxymatch proxymaxforwards proxypass proxypassreverse \
proxypreservehost proxyreceivebuffersize proxyremote \
proxyremotematch proxyrequests proxytimeout proxyvia \
qsc readmename redirect redirectmatch \
redirectpermanent redirecttemp refererignore \
refererlog removecharset removeencoding removehandler \
removeinputfilter removelanguage removeoutputfilter \
removetype requestheader require resourceconfig \
rewritebase rewritecond rewriteengine rewritelock \
rewritelog rewriteloglevel rewritemap rewriteoptions \
rewriterule rlimitcpu rlimitmem rlimitnproc satisfy \
scoreboardfile script scriptalias scriptaliasmatch \
scriptinterpretersource scriptlog scriptlogbuffer \
scriptloglength scriptsock securelisten sendbuffersize \
serveradmin serveralias serverlimit servername \
serverpath serverroot serversignature servertokens \
servertype setenv setenvif setenvifnocase sethandler \
setinputfilter setoutputfilter singlelisten ssiendtag \
ssierrormsg ssistarttag ssitimeformat ssiundefinedecho \
sslcacertificatefile sslcacertificatepath \
sslcarevocationfile sslcarevocationpath \
sslcertificatechainfile sslcertificatefile \
sslcertificatekeyfile sslciphersuite sslengine \
sslmutex ssloptions sslpassphrasedialog sslprotocol \
sslproxycacertificatefile sslproxycacertificatepath \
sslproxycarevocationfile sslproxycarevocationpath \
sslproxyciphersuite sslproxyengine \
sslproxymachinecertificatefile \
sslproxymachinecertificatepath sslproxyprotocol \
sslproxyverify sslproxyverifydepth sslrandomseed \
sslrequire sslrequiressl sslsessioncache \
sslsessioncachetimeout sslusername sslverifyclient \
sslverifydepth startservers startthreads \
suexecusergroup threadlimit threadsperchild \
threadstacksize timeout transferlog typesconfig \
unsetenv usecanonicalname user userdir \
virtualdocumentroot virtualdocumentrootip virtualhost \
virtualscriptalias virtualscriptaliasip \
win32disableacceptex xbithack

#common parameters for Apache runtime configuration
keywords2.$(file.patterns.conf)=\
on off standalone inetd \
force-response-1.0 downgrade-1.0 nokeepalive \
indexes includes followsymlinks none \
x-compress x-gzip

# whitespace (SCE_CONF_DEFAULT)
style.conf.0=fore:#808080,$(font.base)
# Comment (SCE_CONF_COMMENT)
style.conf.1=fore:#007F00,$(font.comment)
# Number (SCE_CONF_NUMBER)
style.conf.2=fore:#007F7F
# identifier (SCE_CONF_IDENTIFIER)
style.conf.9=fore:#00007F,bold
# extensions (like .gz, .tgz, .html) (SCE_CONF_EXTENSION)
style.conf.4=fore:#000000,back:#FFE0FF
# parameters for Apache Runtime directives (SCE_CONF_PARAMETER)
style.conf.5=fore:#000000,back:#FFE0FF
# Double quoted string (SCE_CONF_STRING)
style.conf.6=fore:#7F007F,$(font.monospace)
# Operators (SCE_CONF_OPERATOR)
style.conf.7=bold
# IP address (SCE_CONF_IP)
style.conf.8=fore:#007F7F,bold
# Apache Runtime Directive (SCE_CONF_DIRECTIVE)
style.conf.3=fore:#000000,back:#A0FFA0

# compiling/building simply checks for the correct symantics....
command.compile.$(file.patterns.conf)=httpd -t -f $(FilePath)
command.build.$(file.patterns.conf)=httpd -t -f $(FilePath)
