
from __future__ import with_statement
import IFaceTableGen
import sys
import os
from collections import OrderedDict

srcRoot = "../.."
sys.path.append(srcRoot + "/scintilla/scripts")

import Face
from FileGenerator import Regenerate

knownSkipped = dict(
	SCI_GETTEXTRANGE=1, # use PaneGetText instead
	SCI_GETSTYLEDTEXT=1,
	SCI_ADDSTYLEDTEXT=1,
	SCI_FINDTEXT=1, # use PaneFindText instead
	SCI_FORMATRANGE=1,
	SCI_SETUSEPALETTE=1, # deprecated
	SCI_GETUSEPALETTE=1, # deprecated
	SCI_GETKEYSUNICODE=1, # deprecated
	SCI_SETKEYSUNICODE=1, # deprecated
	StyleByteIndicators=1, # no longer supported
	message=1
	)

def cell(s):
	return "<td>%s</td>" % s

def CommentString(prop):
	if prop and prop["Comment"]:
		return (" ".join(prop["Comment"])).replace("<", "&lt;")
	return ""

def replaceWholeWord(starget, sin, srep):
    import re
    sin = '\\b' + re.escape(sin) + '\\b'
    return re.sub(sin, srep, starget)

def getConstantsFromIFaceTableSrc():
	# returns list of strings
	results = []
	with open(os.path.join("..", "src", "IFaceTable.cxx"), "rt") as f:
		readingState = 'before'
		for l in f:
			l = l.strip()
			if l.startswith('static IFaceConstant ifaceConstants[] = {'):
				readingState = 'inside'
			elif readingState == 'inside' and l.startswith('};'):
				readingState = 'after'
			elif readingState == 'inside':
				parts = l.split(',')
				constantname = parts[0]
				constantname = constantname.lstrip(' {"')
				constantname = constantname.rstrip(' "')
				if not (constantname.startswith('IDM_') or constantname.startswith('SCE_') or \
					constantname.startswith('SCI_') or constantname.startswith('SCK_') or \
					constantname.startswith('SCLEX')):
					results.append(constantname)
	return results

def getLinesFromPythonExtensionSrc():
	# returns list of tuples (idm_name, methodName)
	results = []
	with open(os.path.join("..", "src", "PythonExtension.cxx"), "rt") as f:
		readingState = 'before'
		for l in f:
			l = l.strip()
			if l.startswith('//++Autogenerated -- run'):
				readingState = 'inside'
			elif readingState == 'inside' and l.startswith('//--Autogenerated -- end'):
				readingState = 'after'
			elif readingState == 'inside':
				method, idm, _ = l.split(',')
				method = method.lstrip(' {"')
				method = method.rstrip(' "')
				method = 'Cmd' + method
				idm = idm.lstrip(' ')
				idm = idm.rstrip(' }')
				results.append((idm, method))
	return results

def getMapFromIdmToMenuText():
	map = dict()
	with open(os.path.join("..", "win32", "SciTERes.rc"), "rt") as f:
		for l in f:
			l = l.strip()
			if l.startswith("MENUITEM") and "SEPARATOR" not in l:
				l = l.replace("MENUITEM", "").strip()
				text, symbol = l.split('",', 1)
				symbol = symbol.strip()
				text = text[1:].replace("&", "").replace("...", "")
				if "\\t" in text:
					text = text.split("\\t",1)[0]
				map[symbol] = text
	return map

def addPythonDefinedAppMethods(mapIdmToText, methodsIdm):
	manuallyAddMethods = '''MsgBox(s)|Show message box with text s
GetProperty(propname)|Returns value of property
SetProperty(propname, val)|Set value of property
UnsetProperty(propname)|Unset property
OpenFile(filename)|Open File
LocationNext|Go to next location
LocationPrev|Go to previous location
GetFilePath|Returns full file path
GetFileName|Returns file name
GetFileDirectory|Returns directory of file
GetSciteDirectory|Returns SciTE location
GetSciteUserDirectory|Returns SciTE user dir location'''.replace('\r\n','\n').split('\n')
	manuallyAddMethods.reverse()
	for line in manuallyAddMethods:
		methodName, desc = line.split('|')
		fakeidm = 'fake_idm_' + methodName
		mapIdmToText[fakeidm] = desc
		methodsIdm.insert(0, (fakeidm, methodName))
		
def addPythonDefinedConstants(currentList):
	manuallyAddConstants = '''MakeKeymod(keycode, shift=False, ctrl=False, alt=False)
MakeColor(red, green, blue)
GetColor(val)
StopEventPropagation'''.replace('\r\n','\n').split('\n')
	manuallyAddConstants.reverse()
	for added in manuallyAddConstants:
		currentList.insert(0, added)

def addPythonDefinedPaneMethods(idsInOrder, mapSymbolNameToExplanation):
	manuallyAdd = '''Line endings|string|Utils.GetEolCharacter()|Return current EOL character, e.g. \\r\\n
Selection and information||Utils.ExpandSelectionToIncludeEntireLines()|Ensure entire lines are selected
Text retrieval and modification||PaneAppend(string txt)|Append text
Text retrieval and modification||PaneInsertText(string txt, int pos)|Insert text (without changing selection)
Text retrieval and modification||PaneWrite(string txt, int pos=None)|Write text, and update selection
Text retrieval and modification||PaneRemoveText(int pos1, int pos2)|Remove text between these positions
Text retrieval and modification|string|PaneGetText(int pos1, int pos2)|Get text between these positions
Searching|int,int|PaneFindText(string s, int pos1=0, int pos2=-1, wholeWord=False, matchCase=False, regExp=False, flags=0)|Find text
Text retrieval and modification|string|GetLineText(int line)|Returns text of specified line
Text retrieval and modification|string|GetSelectedText()|Returns selected text
Text retrieval and modification|string|GetCurrentLineText()|Returns text of current line'''.replace('\r\n','\n').split('\n')
	for line in manuallyAdd:
		sectionName, returnType, methodName, comment = line.split('|')
		fakeFeatureNameId = 'SCI_FAKE_' + methodName
		explanation = (returnType + ' ' if returnType else '') + 'ScEditor.' + methodName
		mapSymbolNameToExplanation[fakeFeatureNameId] = [methodName, explanation, comment, 'Function', False]
		idsInOrder.append((sectionName, fakeFeatureNameId))

def writeScAppMethodsToFile(out):
	mapIdmToText = getMapFromIdmToMenuText()
	methodsIdm = getLinesFromPythonExtensionSrc()
	addPythonDefinedAppMethods(mapIdmToText, methodsIdm)
	includeEvenWithNoText = dict(CmdFindNextBackSel=1, CmdFindNextSel=1, CmdMoveTabLeft=1,
		CmdMoveTabRight=1, CmdNextFileStack=1, CmdPrevFileStack=1, CmdPasteAndDown=1)
	for idm_name, methodName in methodsIdm:
		text = mapIdmToText.get(idm_name, None)
		if text is None:
			if methodName in includeEvenWithNoText:
				text = ''
			else:
				continue
				
		if '(' not in methodName:
			methodName = methodName + '()'
		methodName = 'ScApp.' + methodName
		out.write("<tr><td>%s</td><td>%s</td></tr>\n" % (methodName, text))

def writeScConstMethodsToFile(out):
	currentList = getConstantsFromIFaceTableSrc()
	addPythonDefinedConstants(currentList)
	for constant in currentList:
		# many are for SCN_ events which aren't useful to the python extension
		if not (constant.startswith('SC_FOLDFLAG_') or constant.startswith('SC_MARKNUM_') \
			or constant.startswith('SC_MOD_') or constant.startswith('SC_MARK_') or constant.startswith('SC_UPDATE_') \
			or constant.startswith('SC_MODEVENTMASKALL') or constant.startswith('SC_PERFORMED_') \
			or constant.startswith('SC_MULTISTEPUNDOREDO') or constant.startswith('SC_LASTSTEPINUNDOREDO') \
			or constant.startswith('SC_MULTILINEUNDOREDO') or constant.startswith('SC_STARTACTION') \
			or constant.startswith('SC_AC_')):
			constant = 'ScConst.' + constant
			out.write("<tr><td>%s</td></tr>\n" % (constant))

def getScEditorFunctions(name, features, mapSymbolNameToExplanation):
	featureDefineName = "SCI_" + name.upper()
	explanation = ""
	href = ""
	hrefEnd = ""
	href = "<a href='http://www.scintilla.org/ScintillaDoc.html#" + featureDefineName + "'>"
	hrefEnd = "</a>"

	if features['Param1Type'] in IFaceTableGen.nonScriptableTypes or features['Param2Type'] in IFaceTableGen.nonScriptableTypes:
		return

	parameters = ""
	stringresult = ""
	if features['Param2Type'] == "stringresult":
		stringresult = "string "
		if features['Param1Name'] and features['Param1Name'] != "length":
			parameters += features['Param1Type'] + " " + features['Param1Name']
	else:
		if features['Param1Name']:
			parameters += features['Param1Type'] + " " + features['Param1Name']
			if features['Param1Name'] == "length" and features['Param2Type'] == "string":
				# special case removal
				parameters = ""
		if features['Param2Name']:
			if parameters:
				parameters += ", "
			parameters += features['Param2Type'] + " " + features['Param2Name']

	returnType = stringresult
	if not returnType and features["ReturnType"] != "void":
		returnType = IFaceTableGen.convertStringResult(features["ReturnType"]) + " "

	explanation += '%sScEditor.%s%s%s(%s)' % (
		returnType,
		href,
		name,
		hrefEnd,
		parameters
	)
	
	comment = ''
	if features["Comment"]:
		comment = '<span class="comment">%s</span>' % CommentString(features)

	mapSymbolNameToExplanation[featureDefineName] = [name, explanation, comment, 'Function', False]
	
def getScEditorPropertiesGetter(propname, property, mapSymbolNameToExplanation):
	functionName = property['GetterName']
	featureDefineName = "SCI_" + functionName.upper()
	explanation = ""
	href = "<a href='http://www.scintilla.org/ScintillaDoc.html#" + featureDefineName + "'>"
	hrefEnd = "</a>"
	explanation = property["PropertyType"] + " ScEditor." + href + functionName + hrefEnd + '('
	if property["IndexParamType"] != "void":
		explanation += property["IndexParamType"] + ' ' + property["IndexParamName"]
	explanation += ')'
	comment = ''
	if property["GetterComment"]:
		comment += '<span class="comment">%s</span>' % (property["GetterComment"].replace("<", "&lt;"))
	
	comment = comment.replace('-- ', '')
	mapSymbolNameToExplanation[featureDefineName] = [functionName, explanation, comment, 'Getter', False]
	
def getScEditorPropertiesSetter(propname, property, mapSymbolNameToExplanation):
	functionName = property['SetterName']
	featureDefineName = "SCI_" + functionName.upper()
	explanation = ""
	href = "<a href='http://www.scintilla.org/ScintillaDoc.html#" + featureDefineName + "'>"
	hrefEnd = "</a>"
	explanation = "ScEditor." + href + functionName + hrefEnd + '('
	if property["IndexParamType"] != "void":
		explanation += property["IndexParamType"] + ' ' + property["IndexParamName"] + ', '
	explanation += property["PropertyType"] + ' value)'
	comment = ''
	if property["SetterComment"]:
		comment += '<span class="comment">%s</span>' % (property["SetterComment"].replace("<", "&lt;"))
	
	comment = comment.replace('-- ', '')
	mapSymbolNameToExplanation[featureDefineName] = [functionName, explanation, comment, 'Setter', False]
	
def writeScEditorOutput(parts, out):
	methodName, explanation, comment, fnOrProp, seen = parts
	explanation = replaceWholeWord(explanation, 'position', 'int')
	explanation = replaceWholeWord(explanation, 'stringresult', 'string')
	comment = comment.replace('Result is NUL-terminated.', '').replace('NUL terminated text argument.', '')
	out.write("<tr><td>%s</td><td>%s</td></tr>\n" % (explanation, comment))

def writeScEditorMethodsToFile(out):
	f = Face.Face()
	f.ReadFromFile(srcRoot + "/scintilla/include/Scintilla.iface")
	idsInOrder = IFaceTableGen.idsFromDocumentation(srcRoot + "/scintilla/doc/ScintillaDoc.html")
	(constants, functions, properties) = IFaceTableGen.GetScriptableInterface(f)
	mapSymbolNameToExplanation = {}
	addPythonDefinedPaneMethods(idsInOrder, mapSymbolNameToExplanation)
	
	for name, features in functions:
		getScEditorFunctions(name, features, mapSymbolNameToExplanation)
		
	for propname, property in properties:
		if property['GetterName']:
			getScEditorPropertiesGetter(propname, property, mapSymbolNameToExplanation)
		if property['SetterName']:
			getScEditorPropertiesSetter(propname, property, mapSymbolNameToExplanation)
	
	sections = OrderedDict()
	
	# divide the list into sections
	for sectionName, featureId in idsInOrder:
		if featureId in mapSymbolNameToExplanation:
			if sectionName not in sections:
				sections[sectionName] = []
			
			sections[sectionName].append(mapSymbolNameToExplanation[featureId])
		elif featureId not in knownSkipped:
			print 'GetScriptableInterface said to skip featureID %s, add to knownSkipped if this looks right.'%featureId
		
	# within each section, sort by methodName
	for sectionName in sections:
		out.write('<tr><td align="right"><i><br /><br /><br />%s</i></td><td>%s</td></tr>\n' % (sectionName, ''))
		
		# because the first item is methodName, this will sort by methodName.
		sections[sectionName].sort()
		for parts in sections[sectionName]:
			writeScEditorOutput(parts, out)
			parts[4] = True
	
	# were there any methods skipped?
	for key in mapSymbolNameToExplanation:
		parts = mapSymbolNameToExplanation[key]
		if not parts[4]:
			print 'warning: idsInOrder did not contain featureId %s ' % parts[0]

startFile = """
<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!--Generated by scite/scripts/PythonExtensionDocGen.py -->
<style type="text/css">
	body { font-family:verdana, Geneva, sans-serif; font-size: 80% }
	table { border: 1px solid #1F1F1F; border-collapse: collapse; }
	td { border: 1px solid; border-color: #E0E0E0 #000000; padding: 1px 5px 1px 5px; }
	th { border: 1px solid #1F1F1F; padding: 1px 5px 1px 5px; }
	thead { background-color: #000000; color: #FFFFFF; }
</style>
<body>
"""

def writeScAppMethods(out):
	out.write("<h2>ScApp methods</h2>\n")
	out.write("<table><tr><th> </th><th> </th></tr>\n")
	writeScAppMethodsToFile(out)
	out.write("</table>\n")
	
def writeScEditorMethods(out):
	out.write("<h2>ScEditor (and ScOutput) methods</h2>\n")
	out.write('<table><tr><th style="width:35em"> </th><th> </th></tr>\n')
	writeScEditorMethodsToFile(out)
	out.write("</table>\n")
	
def writeScConstMethods(out):
	out.write("<h2>ScConst properties and methods</h2>\n")
	out.write("<table><tr><th> </th></tr>\n")
	writeScConstMethodsToFile(out)
	out.write("</table>\n")

def RegenerateAll():
	with open(os.path.join("..", "SciTEWithPythonAPIReference.html"), "w") as out:
		out.write(startFile)
		writeScAppMethods(out)
		writeScEditorMethods(out)
		writeScConstMethods(out)
		out.write("</body>\n</html>\n")
	
if __name__=="__main__":
	RegenerateAll()
