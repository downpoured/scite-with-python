
from __future__ import with_statement
import IFaceTableGen
import sys
import os
from collections import OrderedDict
from ShowBindingsReadProps import retrieveCodeLines, escapeXml

srcRoot = "../.."
sys.path.append(srcRoot + "/scintilla/scripts")

import Face

sectionsToHide = {
	'Error handling': 0,
	'Mouse capture': 0,
	'Key bindings': 0,
	'Popup edit menu': 0,
	'Macro recording': 0,
	'Direct access': 0,
	'Multiple views': 0,
	'Background loading and saving': 0,
	'Notifications': 0,
	'Deprecated messages and notifications': 0,
}

knownMissingFromGetScriptableInterface = dict(
	SCI_GETTEXTRANGE=0, # use PaneGetText instead
	SCI_GETSTYLEDTEXT=0,
	SCI_ADDSTYLEDTEXT=0,
	SCI_FINDTEXT=0, # use PaneFindText instead
	SCI_FORMATRANGE=0,
	SCI_SETUSEPALETTE=0, # deprecated
	SCI_GETUSEPALETTE=0, # deprecated
	SCI_GETKEYSUNICODE=0, # deprecated
	SCI_SETKEYSUNICODE=0, # deprecated
	StyleByteIndicators=0, # no longer supported
	message=0)

knownMissingFromIdsInOrder = dict(
	SCI_FORMFEED=0,
	SCI_SCROLLTOSTART=1,
	SCI_CHARRIGHTRECTEXTEND=1,
	SCI_LINEDOWNRECTEXTEND=1,
	SCI_WORDRIGHT=1,
	SCI_LINEEND=1,
	SCI_STUTTEREDPAGEUPEXTEND=0,
	SCI_STUTTEREDPAGEDOWN=0,
	SCI_LINEUPRECTEXTEND=1,
	SCI_DELWORDRIGHTEND=1,
	SCI_WORDPARTLEFTEXTEND=1,
	SCI_PAGEUPEXTEND=1,
	SCI_WORDPARTRIGHTEXTEND=1,
	SCI_LINECOPY=1,
	SCI_VCHOMEDISPLAY=1,
	SCI_LINEENDWRAP=1,
	SCI_HOMEDISPLAY=0,
	SCI_DOCUMENTENDEXTEND=1,
	SCI_HOMERECTEXTEND=1,
	SCI_PARAUPEXTEND=1,
	SCI_PAGEUPRECTEXTEND=1,
	SCI_WORDLEFTEND=1,
	SCI_VCHOME=1,
	SCI_CANCEL=1,
	SCI_LINEDOWNEXTEND=1,
	SCI_LINEDELETE=1,
	SCI_WORDPARTLEFT=1,
	SCI_LINEUPEXTEND=1,
	SCI_DELLINERIGHT=0,
	SCI_DELWORDLEFT=1,
	SCI_CHARRIGHT=1,
	SCI_HOMEDISPLAYEXTEND=0,
	SCI_PRIVATELEXERCALL=1,
	SCI_WORDLEFTENDEXTEND=1,
	SCI_SETSTYLEBITS=0, # deprecated
	SCI_PAGEDOWN=1,
	SCI_PARAUP=1,
	SCI_DOCUMENTEND=1,
	SCI_CHARLEFTRECTEXTEND=1,
	SCI_VCHOMEDISPLAYEXTEND=1,
	SCI_LINETRANSPOSE=1,
	SCI_LOWERCASE=1,
	SCI_DELWORDRIGHT=1,
	SCI_SCROLLTOEND=1,
	SCI_LINECUT=1,
	SCI_HOME=1,
	SCI_LINEDOWN=1,
	SCI_SELECTIONDUPLICATE=1,
	SCI_LINEUP=1,
	SCI_DOCUMENTSTARTEXTEND=1,
	SCI_LINEENDWRAPEXTEND=1,
	SCI_VCHOMEEXTEND=1,
	SCI_VERTICALCENTRECARET=0,
	SCI_PARADOWN=1,
	SCI_HOMEWRAPEXTEND=1,
	SCI_HOMEWRAP=1,
	SCI_LINEENDRECTEXTEND=1,
	SCI_LINESCROLLDOWN=1,
	SCI_LINEDUPLICATE=1,
	SCI_DOCUMENTSTART=1,
	SCI_WORDLEFT=1,
	SCI_CHARLEFT=1,
	SCI_UPPERCASE=1,
	SCI_WORDRIGHTENDEXTEND=1,
	SCI_EDITTOGGLEOVERTYPE=0,
	SCI_LINEENDEXTEND=1,
	SCI_WORDRIGHTEND=1,
	SCI_WORDPARTRIGHT=1,
	SCI_DELETEBACK=1,
	SCI_PAGEUP=1,
	SCI_WORDLEFTEXTEND=1,
	SCI_LINEENDDISPLAYEXTEND=1,
	SCI_STUTTEREDPAGEUP=0,
	SCI_PAGEDOWNRECTEXTEND=1,
	SCI_HOMEEXTEND=1,
	SCI_PARADOWNEXTEND=1,
	SCI_LINESCROLLUP=1,
	SCI_WORDRIGHTEXTEND=1,
	SCI_VCHOMERECTEXTEND=1,
	SCI_DELLINELEFT=0,
	SCI_PAGEDOWNEXTEND=1,
	SCI_BACKTAB=1,
	SCI_VCHOMEWRAPEXTEND=1,
	SCI_NEWLINE=1,
	SCI_CHARRIGHTEXTEND=1,
	SCI_CHARLEFTEXTEND=1,
	SCI_STUTTEREDPAGEDOWNEXTEND=0,
	SCI_VCHOMEWRAP=1,
	SCI_DELETEBACKNOTLINE=0,
	SCI_TAB=1,
	SCI_LINEENDDISPLAY=1)

def CommentString(prop):
	if prop and prop["Comment"]:
		return " ".join(prop["Comment"])
	return ''

def replaceWholeWord(starget, sin, srep):
	import re
	sin = '\\b' + re.escape(sin) + '\\b'
	return re.sub(sin, srep, starget)

def getConstantsFromIFaceTableSrc():
	# returns list of strings
	results = []
	filename = os.path.join("..", "src", "IFaceTable.cxx")
	lines = retrieveCodeLines(filename, 'static IFaceConstant ifaceConstants[] = {', '};')
	for line in lines[1:-1]:
		parts = line.split(',')
		constantname = parts[0]
		constantname = constantname.lstrip(' {"\t')
		constantname = constantname.rstrip(' "')
		if not (constantname.startswith('IDM_') or constantname.startswith('SCE_') or
			constantname.startswith('SCI_') or constantname.startswith('SCK_') or
			constantname.startswith('SCLEX')):
			results.append(constantname)
	return results

def getLinesFromPythonExtensionSrc():
	# returns list of tuples (idm_name, methodName)
	results = []
	filename = os.path.join("..", "src", "PythonExtension.cxx")
	start = '\t//++Autogenerated -- run src/scite/scite/scripts/PythonExtensionGenTable.py and paste the results here'
	end = '\t//--Autogenerated -- end of automatically generated section'
	lines = retrieveCodeLines(filename, start, end)
	for line in lines[1:-1]:
		method, idm, _ = line.split(',')
		method = method.lstrip(' {"\t')
		method = method.rstrip(' "')
		method = 'Cmd' + method
		idm = idm.lstrip(' ')
		idm = idm.rstrip(' }')
		results.append((idm, method))
	return results

def getMapFromIdmToMenuText():
	map = dict()
	with open(os.path.join("..", "win32", "SciTERes.rc"), "rt") as f:
		for l in f:
			l = l.strip()
			if l.startswith("MENUITEM") and "SEPARATOR" not in l:
				l = l.replace("MENUITEM", "").strip()
				text, symbol = l.split('",', 1)
				symbol = symbol.strip()
				text = text[1:].replace("&", "").replace("...", "")
				if "\\t" in text:
					text = text.split("\\t", 1)[0]
				map[symbol] = text
	return map

def addPythonDefinedAppMethods(mapIdmToText, methodsIdm):
	manuallyAddMethods = '''MsgBox(s)|Show message box with text s
GetProperty(propname)|Returns value of property
SetProperty(propname, val)|Set value of property
UnsetProperty(propname)|Unset property
OpenFile(filename)|Open File
LocationNext|Go to next location
LocationPrev|Go to previous location
GetFilePath|Returns full file path
GetFileName|Returns file name
GetFileDirectory|Returns directory of file
GetSciteDirectory|Returns SciTE location
GetSciteUserDirectory|Returns SciTE user dir location'''.replace('\r\n', '\n').split('\n')
	manuallyAddMethods.reverse()
	for line in manuallyAddMethods:
		methodName, desc = line.split('|')
		fakeidm = 'fake_idm_' + methodName
		mapIdmToText[fakeidm] = desc
		methodsIdm.insert(0, (fakeidm, methodName))
		
def addPythonDefinedConstants(currentList):
	manuallyAddConstants = '''MakeKeymod(keycode, shift=False, ctrl=False, alt=False)
MakeColor(red, green, blue)
GetColor(val)
StopEventPropagation'''.replace('\r\n', '\n').split('\n')
	manuallyAddConstants.reverse()
	for added in manuallyAddConstants:
		currentList.insert(0, added)

def addPythonDefinedPaneMethods(idsInOrder, mapSymbolNameToExplanation):
	manuallyAdd = '''SCI_GETEOLMODE|Line endings|string|Utils.GetEolCharacter()|Return current EOL character, e.g. \\r\\n
|Selection and information||Utils.ExpandSelectionToIncludeEntireLines()|Ensure entire lines are selected
SCI_APPENDTEXT|Text retrieval and modification||PaneAppend(string txt)|Append text
SCI_INSERTTEXT|Text retrieval and modification||PaneInsertText(string txt, int pos)|Insert text (without changing selection)
SCI_INSERTTEXT|Text retrieval and modification||PaneWrite(string txt, int pos=None)|Write text, and update selection
SCI_REPLACETARGET|Text retrieval and modification||PaneRemoveText(int pos1, int pos2)|Remove text between these positions
SCI_GETTEXTRANGE|Text retrieval and modification|string|PaneGetText(int pos1, int pos2)|Get text between these positions
SCI_FINDTEXT|Searching|int,int|PaneFindText(string s, int pos1=0, int pos2=-1, wholeWord=False, matchCase=False, regExp=False, flags=0)|Find text
SCI_GETLINE|Text retrieval and modification|string|GetLineText(int line)|Returns text of specified line
SCI_GETSELTEXT|Text retrieval and modification|string|GetSelectedText()|Returns selected text
SCI_GETCURLINE|Text retrieval and modification|string|GetCurrentLineText()|Returns text of current line'''.replace('\r\n', '\n').split('\n')
	for line in manuallyAdd:
		featureId, sectionName, returnType, methodName, comment = line.split('|')
		fakeFeatureId = 'SCI_FAKE_' + methodName
		explanation = returnType + ' ' if returnType else ''
		explanation += 'ScEditor.$link1$#' + featureId + '$link2$' + escapeXml(methodName) + '$linkend$'
		mapSymbolNameToExplanation[fakeFeatureId] = [methodName, explanation, comment, 'Function', False]
		idsInOrder.append((sectionName, fakeFeatureId))

def writeScAppMethodsToFile(out):
	mapIdmToText = getMapFromIdmToMenuText()
	methodsIdm = getLinesFromPythonExtensionSrc()
	addPythonDefinedAppMethods(mapIdmToText, methodsIdm)
	includeEvenWithNoText = dict(CmdFindNextBackSel=1, CmdFindNextSel=1, CmdMoveTabLeft=1,
		CmdMoveTabRight=1, CmdNextFileStack=1, CmdPrevFileStack=1, CmdPasteAndDown=1)
	for idm_name, methodName in methodsIdm:
		text = mapIdmToText.get(idm_name, None)
		if text is None:
			if methodName in includeEvenWithNoText:
				text = ''
			else:
				continue
				
		if '(' not in methodName:
			methodName = methodName + '()'
		methodName = 'ScApp.' + methodName
		out.write("<tr><td>%s</td><td>%s</td></tr>\n" % (escapeXmlLink(methodName), escapeXml(text)))

def writeScConstMethodsToFile(out):
	currentList = getConstantsFromIFaceTableSrc()
	addPythonDefinedConstants(currentList)
	for constant in currentList:
		# many are for SCN_ events which aren't useful to the python extension
		if not (constant.startswith('SC_FOLDFLAG_') or constant.startswith('SC_MARKNUM_') or
			constant.startswith('SC_MOD_') or constant.startswith('SC_MARK_') or constant.startswith('SC_UPDATE_') or
			constant.startswith('SC_MODEVENTMASKALL') or constant.startswith('SC_PERFORMED_') or
			constant.startswith('SC_MULTISTEPUNDOREDO') or constant.startswith('SC_LASTSTEPINUNDOREDO') or
			constant.startswith('SC_MULTILINEUNDOREDO') or constant.startswith('SC_STARTACTION') or
			constant.startswith('SC_AC_')):
			constant = 'ScConst.' + constant
			out.write("<tr><td>%s</td></tr>\n" % escapeXml(constant))

def getScEditorFunctions(name, features, mapSymbolNameToExplanation):
	featureDefineName = "SCI_" + name.upper()
	explanation = ""
	href = '$link1$#' + featureDefineName + '$link2$'
	hrefEnd = "$linkend$"

	if features['Param1Type'] in IFaceTableGen.nonScriptableTypes or features['Param2Type'] in IFaceTableGen.nonScriptableTypes:
		return

	parameters = ""
	stringresult = ""
	if features['Param2Type'] == "stringresult":
		stringresult = "string "
		if features['Param1Name'] and features['Param1Name'] != "length":
			parameters += features['Param1Type'] + " " + features['Param1Name']
	else:
		if features['Param1Name']:
			parameters += features['Param1Type'] + " " + features['Param1Name']
			if features['Param1Name'] == "length" and features['Param2Type'] == "string":
				# special case removal
				parameters = ""
		if features['Param2Name']:
			if parameters:
				parameters += ", "
			parameters += features['Param2Type'] + " " + features['Param2Name']

	# change from IFaceTableGen.py: these return a tuple, not just a string.
	if not stringresult and features["ReturnType"] == "void":
		returnType = ''
	elif not stringresult and features["ReturnType"] != "void":
		returnType = IFaceTableGen.convertStringResult(features["ReturnType"]) + " "
	elif stringresult and features["ReturnType"] in ("void", "string", "stringresult"):
		returnType = 'string '
	else:
		returnType = 'string,' + features["ReturnType"] + ' '
	
	explanation += '%sScEditor.%s%s%s(%s)' % (
		returnType,
		href,
		name,
		hrefEnd,
		parameters
	)
	comment = CommentString(features) if features["Comment"] else ''
	mapSymbolNameToExplanation[featureDefineName] = [name, explanation, comment, 'Function', False]
	
def getScEditorPropertiesGetter(propname, property, mapSymbolNameToExplanation):
	functionName = ('Get' + propname) if not propname.startswith('Get') else propname
	featureDefineName = "SCI_" + property['GetterName'].upper()
	explanation = ""
	href = '$link1$#' + featureDefineName + '$link2$'
	explanation = property["PropertyType"] + " ScEditor." + href + functionName + '$linkend$('
	if property["IndexParamType"] != "void":
		explanation += property["IndexParamType"] + ' ' + property["IndexParamName"]
	explanation += ')'
	
	comment = property["GetterComment"] or ''
	comment = comment.replace('-- ', '').replace('&lt;', '<').replace('&gt;', '>')
	mapSymbolNameToExplanation[featureDefineName] = [functionName, explanation, comment, 'Getter', False]
	
def getScEditorPropertiesSetter(propname, property, mapSymbolNameToExplanation):
	functionName = ('Set' + propname) if not propname.startswith('Set') else propname
	featureDefineName = "SCI_" + property['SetterName'].upper()
	explanation = ""
	href = '$link1$#' + featureDefineName + '$link2$'
	explanation = "ScEditor." + href + functionName + '$linkend$('
	if property["IndexParamType"] != "void":
		explanation += property["IndexParamType"] + ' ' + property["IndexParamName"] + ', '
	explanation += property["PropertyType"] + ' value)'
	
	comment = property["SetterComment"] or ''
	comment = comment.replace('-- ', '').replace('&lt;', '<').replace('&gt;', '>')
	mapSymbolNameToExplanation[featureDefineName] = [functionName, explanation, comment, 'Setter', False]
	
def writeScEditorOutput(parts, out):
	methodName, explanation, comment, fnOrProp, seen = parts
	explanation = replaceWholeWord(explanation, 'position', 'int')
	explanation = replaceWholeWord(explanation, 'stringresult', 'string')
	comment = comment.replace('Result is NUL-terminated.', '').replace('NUL terminated text argument.', '')
	out.write('<tr><td>%s</td><td><span class="comment">%s</span></td></tr>\n' % (escapeXmlLink(explanation), escapeXml(comment)))

def writeScEditorMethodsToFile(out):
	import re
	f = Face.Face()
	f.ReadFromFile(srcRoot + "/scintilla/include/Scintilla.iface")
	idsInOrder = IFaceTableGen.idsFromDocumentation(srcRoot + "/scintilla/doc/ScintillaDoc.html")
	(constants, functions, properties) = IFaceTableGen.GetScriptableInterface(f)
	mapSymbolNameToExplanation = {}
	addPythonDefinedPaneMethods(idsInOrder, mapSymbolNameToExplanation)
	
	for name, features in functions:
		getScEditorFunctions(name, features, mapSymbolNameToExplanation)
		
	for propname, property in properties:
		if property['GetterName']:
			getScEditorPropertiesGetter(propname, property, mapSymbolNameToExplanation)
		if property['SetterName']:
			getScEditorPropertiesSetter(propname, property, mapSymbolNameToExplanation)
	
	sections = OrderedDict()
	
	# divide the list into sections
	for sectionName, featureId in idsInOrder:
		if featureId in mapSymbolNameToExplanation:
			if sectionName not in sections:
				sections[sectionName] = []
			
			sections[sectionName].append(mapSymbolNameToExplanation[featureId])
		elif featureId not in knownMissingFromGetScriptableInterface:
			print('GetScriptableInterface said to skip featureID %s, ' +
				'add to knownMissingFromGetScriptableInterface if this looks right.' % featureId)
		
	# within each section, sort by methodName
	for sectionName in sections:
		if sectionsToHide.get(sectionName, None) == 0:
			continue
		
		out.write('<tr><td align="right"><i><br /><br /><br />%s</i></td><td></td></tr>\n' %
			escapeXml(sectionName))
		
		# because the first item is methodName, this will sort by methodName.
		sections[sectionName].sort()
		for parts in sections[sectionName]:
			writeScEditorOutput(parts, out)
			parts[4] = True
	
	# get remaining methods that weren't in IdsInOrder
	remaining = []
	for key in mapSymbolNameToExplanation:
		parts = mapSymbolNameToExplanation[key]
		if not parts[4]:
			shouldInclude = knownMissingFromIdsInOrder.get(key, None)
			if key is None:
				print('IdsInOrder did not contain featureId %s, please add to knownMissingFromIdsInOrder.' % key)
			elif shouldInclude:
				remaining.append(parts)
	
	# write keyboard commands
	out.write('<tr><td align="right"><i><br /><br /><br />%s</i></td><td></td></tr>\n' %
		'Commands typically bound to key presses')
	remaining.sort()
	reFindShortcuts = re.compile(re.escape('$link1$#') + r'[^$]+\$')
	replaceWith = '$link1$#KeyboardCommands$'
	for parts in remaining:
		# these don't have specific anchor tags, so rewrite the link to point at #KeyboardCommands
		replaced = reFindShortcuts.sub(replaceWith, parts[1])
		assert parts[1] != replaced, parts
		parts[1] = replaced
		writeScEditorOutput(parts, out)


startFile = """
<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!--Generated by scite/scripts/%script% -->
<style type="text/css">
body { font-family:verdana, Geneva, sans-serif; font-size: 80% }
table { border: 1px solid #1F1F1F; border-collapse: collapse; }
td { border: 1px solid; border-color: #E0E0E0 #000000; padding: 1px 5px 1px 5px; }
th { border: 1px solid #1F1F1F; padding: 1px 5px 1px 5px; }
thead { background-color: #000000; color: #FFFFFF; }
</style>
<body>
"""

def escapeXmlLink(s):
	s = escapeXml(s)
	s = s.replace('$link1$', '<a href="http://www.scintilla.org/ScintillaDoc.html')
	return s.replace('$link2$', '">').replace('$linkend$', '</a>')

def writeScAppMethods(out):
	out.write("<h2>ScApp methods</h2>\n")
	out.write("<table><tr><th> </th><th> </th></tr>\n")
	writeScAppMethodsToFile(out)
	out.write("</table>\n")
	
def writeScEditorMethods(out):
	out.write("<h2>ScEditor and ScOutput methods</h2>\n")
	out.write('<table><tr><th style="width:35em"> </th><th> </th></tr>\n')
	writeScEditorMethodsToFile(out)
	out.write("</table>\n")
	
def writeScConstMethods(out):
	out.write("<h2>ScConst properties and methods</h2>\n")
	out.write("<table><tr><th> </th></tr>\n")
	writeScConstMethodsToFile(out)
	out.write("</table>\n")

def RegenerateAll():
	with open("../bin/doc/SciTEWithPythonAPIReference.html", "w") as out:
		out.write(startFile.replace('%script%', __file__))
		writeScAppMethods(out)
		writeScEditorMethods(out)
		writeScConstMethods(out)
		out.write("</body>\n</html>\n")
	
if __name__ == "__main__":
	RegenerateAll()
