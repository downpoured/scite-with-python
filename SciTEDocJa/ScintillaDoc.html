<?xml version="1.0" encoding="Shift_JIS"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
  <head>
    <meta name="generator"
    content="HTML Tidy for Windows (vers 1st August 2002), see www.w3.org" />
    <meta name="generator" content="SciTE" />
    <meta http-equiv="Content-Type" content="text/html; charset=Shift_Jis" />

    <title>Scintilla と SciTE</title>
	<link href="translation.css" rel="stylesheet" type="text/css" />
    <style type="text/css">
<!--
/*<![CDATA[*/
    CODE { font-family: "Courier New", monospace; }
    A:visited { color: blue; }
    A:hover { text-decoration: underline ! important; }
    A.message { text-decoration: none; font-family: "Courier New", monospace; }
    A.toc { text-decoration: none; }
    A.jump { text-decoration: none; }
/*]]>*/
-->
    </style>
  </head>

  <body bgcolor="#FFFFFF" text="#000000">
    <table bgcolor="#000000" width="100%" cellspacing="0" cellpadding="0" border="0"
    summary="Banner">
      <tr>
        <td><img src="SciTEIco.png" border="3" height="64" width="64" alt="Scintilla icon" /></td>

        <td><a href="index.html"
        style="color:white;text-decoration:none;font-size:200%">Scintilla</a></td>
      </tr>
    </table>

    <h1><span>Scintilla 解説書</span><span class="eng">Scintilla Documentation</span></h1>

    <p>2004年5月29日更新</p>
    <p class="eng">Last edited 29/May/2004 NH</p>

    <p><a class="jump" href="Design.html">内部設計の概観</a>
	<br />
     <a class="jump" href="ScintillaUsage.html">Scintilla を使う上でのメモ</a><br />
     <a class="jump" href="Steps.html">Windows での Scintilla エディットコントロールの使い方</a><br />
     <a class="jump" href="http://www.scintilla.org/dmapp.zip">Windows 上の C++ で Scintilla を使う簡単なサンプル</a><br />
     <a class="jump" href="http://www.scintilla.org/SciTry.vb">Visual Basic で Scintilla を使う簡単なサンプル</a><br />
     <a class="jump" href="http://www.scintilla.org/bait.zip">Bait</a> は GTK+ 上で Scintilla を使う小さなサンプルです。<br />
     <a class="jump" href="Lexer.html">解析器の書き方についての詳述</a>。折りたたみについても含みます。<br />
     <a class="jump" href="http://sphere.sourceforge.net/flik/docs/scintilla-container_lexer.html">コンテナの中への解析器の実装方法</a><br />
     <a class="jump" href="http://sphere.sourceforge.net/flik/docs/scintilla-folding.html">折りたたみの実装方法</a><br />
	 Scintilla や SciTE にコードを寄付するときは、それらにおける<a class="jump" href="SciCoding.html">コーディングスタイル</a>に従うことが推奨されます。ただし強制ではありません。</p>
    <p class="eng">There is <a class="jump" href="Design.html">an overview of the internal design of
    Scintilla</a>.<br />
     <a class="jump" href="ScintillaUsage.html">Some notes on using Scintilla</a>.<br />
     <a class="jump" href="Steps.html">How to use the Scintilla Edit Control on Windows</a>.<br />
     <a class="jump" href="http://www.scintilla.org/dmapp.zip">A simple sample using Scintilla from
    C++ on Windows</a>.<br />
     <a class="jump" href="http://www.scintilla.org/SciTry.vb">A simple sample using Scintilla from
    Visual Basic</a>.<br />
     <a class="jump" href="http://www.scintilla.org/bait.zip">Bait is a tiny sample using Scintilla
     on GTK+</a>.<br />
     <a class="jump" href="Lexer.txt">A detailed description of how to write a lexer, including a
    discussion of folding</a>.<br />
     <a class="jump" href="http://sphere.sourceforge.net/flik/docs/scintilla-container_lexer.html">
     How to implement a lexer in the container</a>.<br />
     <a class="jump" href="http://sphere.sourceforge.net/flik/docs/scintilla-folding.html">
     How to implement folding</a>.<br />
     The <a class="jump" href="SciCoding.html">coding style</a> used in Scintilla and SciTE is
    worth following if you want to contribute code to Scintilla but is not compulsory.</p>

    <h2><span>はじめに</span><span class="eng">Introduction</span></h2>

    <p>Windows 版の Scintilla は Windows コントロールです。Windows コントロールと同様に基本的なプログラミングインタフェイスは Windows メッセージを介するものとなっています。初期の Scintilla はたくさんの API を数え上げていました。Windows の標準エディット/リッチエディットコントロールに定義されていたものです。しかしながらこれらの API は現在非推奨となっていて、Scintilla 自身のより一貫性のあるものが支持されています。通常のエディットコントロールのメッセージに加え、Scintilla は文法による装飾、折りたたみ、マーカー、自動補完、コールチップを使うことができます。</p>
    <p class="eng">The Windows version of Scintilla is a Windows Control. As such, its primary programming
    interface is through Windows messages. Early versions of Scintilla emulated much of the API
    defined by the standard Windows Edit and RichEdit controls but those APIs are now deprecated in
    favour of Scintilla's own, more consistent API. In addition to messages performing the actions
    of a normal Edit control, Scintilla allows control of syntax styling, folding, markers, autocompletion
    and call tips.</p>

    <p>GTK+ 版の Scintilla も Windows 版のそれと同様にメッセージを使います。これは通常の GTK+ の手順と異なりますが実装は簡単で速くなります。</p>
    <p class="eng">The GTK+ version also uses messages in a similar way to the Windows version. This is
    different to normal GTK+ practice but made it easier to implement rapidly.</p>

    <p>この解説書は Scintilla で使われるメッセージと通知のそれぞれについて書かれています。どのように組み合わせれば便利なエディタを構成することができるかについては書いていません。現時点では、Scintilla を使う開発の手法は SciTE がどのようにしているかを見るのが一番です。SciTE は Scintilla の機能の大半を実行します。</p>
    <p class="eng">This documentation describes the individual messages and notifications used by Scintilla. It
    does not describe how to link them together to form a useful editor. For now, the best way to
    work out how to develop using Scintilla is to see how SciTE uses it. SciTE exercises most of
    Scintilla's facilities.</p>

    <p>以下では、メッセージは関数の呼び出しとして記述されています。関数呼び出しの媒介変数は 0 〜 2 個となっています。通常は二つで、Windows プログラマによくなじみのある <code>wParam</code> と <code>lParam</code> です。命令は記述されている引数だけを使います。すべてのメッセージは Scintilla が使おうと使うまいと二つの引数をとりますので、命令の引数は内容を記述されたもののみを使う形になります。ここで使われなかった引数はゼロにしておくことが強く推奨されます。このことによって、すでにあるコードを破壊するリスクなしに将来のメッセージの拡張ができるようになるからです。共通する引数の型は次の通りです。</p>
    <p class="eng">In the descriptions that follow, the messages are described as function calls with zero, one
    or two arguments. These two arguments are the standard <code>wParam</code> and
    <code>lParam</code> familiar to Windows programmers. Although the commands only use the
    arguments described, because all messages have two arguments whether Scintilla uses them or
    not, it is strongly recommended that any unused arguments are set to 0. This allows future
    enhancement of messages without the risk of breaking existing code. Common argument types
    are:</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="Common argument types">
      <tbody valign="top">
        <tr>
          <th align="left">bool</th>

          <td>0 として <code>false</code>, 1 として <code>true</code> を期待している引数</td>
        </tr>

        <tr>
          <th align="left">int</th>

          <td>符号付 32 ビット整数引数</td>
        </tr>

        <tr>
          <th align="left">const char *</th>

          <td>Scintilla に渡されるテキストへのポインタを表す引数。テキストは変更されない。テキストは 0 を終端に置かれるか他の引数が文字数を渡しているかされている。説明でこの点ははっきりさせています。</td>
        </tr>

        <tr>
          <th align="left">char *</th>

          <td>Scintilla がテキストで満たすであろうバッファへのポインタを表す引数。場合により他の引数が Scintilla にバッファの大きさを伝えます。そうでない場合は呼び出し側が応答を受け取るに充分な大きさをバッファに確保しておかなくてはなりません。もし SCI_* 呼び出しで NULL ポインタ (0) が渡されると必要なバッファの大きさが返されます。</td>
        </tr>

        <tr>
          <th align="left" id="colour">colour</th>

          <td>RGB 形式で色を設定します(R=赤, G=緑, B=青)。各色成分は 0 〜 255 の値で強さを表します。この三つの色の値は次の方法で結合します : 赤 | (緑 &lt;&lt; 8) | (青 &lt;&lt; 16) 。色の強さがすべて 255 であれば白になり、すべて 0 であれば黒となります。colour を設定するとそれを要求していることになります。要求に対して何が得られるかは実行環境の性能・画面モードによります。</td>
        </tr>

        <tr>
          <th align="left">&lt;unused&gt;</th>

          <td>これは未使用の引数です。将来の拡張に対する互換性を保証するために 0 にしておいてください。</td>
        </tr>
      </tbody>
    </table>

    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Common argument types">
      <tbody valign="top">
        <tr>
          <th align="left">bool</th>

          <td>Arguments expect the values 0 for <code>false</code> and 1 for
          <code>true</code>.</td>
        </tr>

        <tr>
          <th align="left">int</th>

          <td>Arguments are 32-bit signed integers.</td>
        </tr>

        <tr>
          <th align="left">const char *</th>

          <td>Arguments point at text that is being passed to Scintilla but not modified. The text
          may be zero terminated or another argument may specify the character count, the
          description will make this clear.</td>
        </tr>

        <tr>
          <th align="left">char *</th>

          <td>Arguments point at text buffers that Scintilla will fill with text. In some cases,
          another argument will tell Scintilla the buffer size. In others, you must make sure that
          the buffer is big enough to hold the requested text. If a NULL pointer (0) is passed
	then, for SCI_* calls, the length that should be allocated is returned.</td>
        </tr>

        <tr>
          <th align="left" id="colour">colour</th>

          <td>Colours are set using the RGB format (Red, Green, Blue). The intensity of each colour
          is set in the range 0 to 255. If you have three such intensities, they are combined as:
          red | (green &lt;&lt; 8) | (blue &lt;&lt; 16). If you set all intensities to 255, the
          colour is white. If you set all intensities to 0, the colour is black. When you set a
          colour, you are making a request. What you will get depends on the capabilities of the
          system and the current screen mode.</td>
        </tr>

        <tr>
          <th align="left">&lt;unused&gt;</th>

          <td>This is an unused argument. Setting it to 0 will ensure compatibility with future
          enhancements.</td>
        </tr>
      </tbody>
    </table>


    <h2 id="MessageCategories"><span>目次</span><span class="eng">Contents</span></h2>
    <table cellpadding="4" cellspacing="2" border="0" summary="Message categories">
      <tbody>
        <tr>
          <td>o <a class="toc" href="#TextRetrievalAndModification">テキストの獲得と変更</a></td>

          <td>o <a class="toc" href="#Searching">検索と置換</a></td>

          <td>o <a class="toc" href="#Overtype">上書きモード</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#CutCopyAndPaste">切り取り、コピー、貼り付け</a></td>

          <td>o <a class="toc" href="#ErrorHandling">エラーの取り扱い</a></td>

          <td>o <a class="toc" href="#UndoAndRedo">取り消しと再実行</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#SelectionAndInformation">選択と情報</a></td>

          <td>o <a class="toc" href="#ScrollingAndAutomaticScrolling">スクロールと自動スクロール</a></td>

          <td>o <a class="toc" href="#WhiteSpace">ホワイトスペース</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Cursor">カーソル</a></td>

          <td>o <a class="toc" href="#MouseCapture">マウスキャプチャ</a></td>

          <td>o <a class="toc" href="#LineEndings">行末</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Styling">装飾</a></td>

          <td>o <a class="toc" href="#StyleDefinition">装飾の定義</a></td>

          <td>o <a class="toc" href="#CaretAndSelectionStyles">キャレット・選択範囲・ホットスポットの装飾</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Margins">余白</a></td>

          <td>o <a class="toc" href="#OtherSettings">その他の設定</a></td>

          <td>o <a class="toc" href="#BraceHighlighting">括弧の強調</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#TabsAndIndentationGuides">タブと字下げの誘導</a></td>

          <td>o <a class="toc" href="#Markers">マーカ</a></td>

          <td>o <a class="toc" href="#Indicators">標示</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Autocompletion">自動補完</a></td>

          <td>o <a class="toc" href="#UserLists">ユーザ提供の自動補完語</a></td>

          <td>o <a class="toc" href="#CallTips">コールチップ</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#KeyboardCommands">キーボードコマンド</a></td>

          <td>o <a class="toc" href="#KeyBindings">キーの割り当て</a></td>

          <td>o <a class="toc" href="#PopupEditMenu">ポップアップ編集メニュー</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#MacroRecording">マクロの記録</a></td>

          <td>o <a class="toc" href="#Printing">印刷</a></td>

          <td>o <a class="toc" href="#DirectAccess">直接アクセス</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#MultipleViews">複数の視野</a></td>

          <td>o <a class="toc" href="#Folding">折りたたみ</a></td>

          <td>o <a class="toc" href="#LineWrapping">行クリップ</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Zooming">拡大</a></td>

          <td>o <a class="toc" href="#LongLines">長い線</a></td>

          <td>o <a class="toc" href="#Lexer">解析器</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Notifications">通知</a></td>

          <td>o <a class="toc" href="#DeprecatedMessages">非推奨のメッセージ</a></td>

          <td>o <a class="toc" href="#EditMessagesNeverSupportedByScintilla">Scintilla で決して対応しないメッセージ</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#BuildingScintilla">Scintilla の構築</a></td>
        </tr>
      </tbody>
    </table>

    <table class="eng" cellpadding="4" cellspacing="2" border="0" summary="Message categories">
      <tbody>
        <tr>
          <td>o <a class="toc" href="#TextRetrievalAndModification">Text retrieval and
          modification</a></td>

          <td>o <a class="toc" href="#Searching">Searching and replacing</a></td>

          <td>o <a class="toc" href="#Overtype">Overtype</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#CutCopyAndPaste">Cut, copy and paste</a></td>

          <td>o <a class="toc" href="#ErrorHandling">Error handling</a></td>

          <td>o <a class="toc" href="#UndoAndRedo">Undo and Redo</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#SelectionAndInformation">Selection and information</a></td>

          <td>o <a class="toc" href="#ScrollingAndAutomaticScrolling">Scrolling and automatic
          scrolling</a></td>

          <td>o <a class="toc" href="#WhiteSpace">White space</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Cursor">Cursor</a></td>

          <td>o <a class="toc" href="#MouseCapture">Mouse capture</a></td>

          <td>o <a class="toc" href="#LineEndings">Line endings</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Styling">Styling</a></td>

          <td>o <a class="toc" href="#StyleDefinition">Style definition</a></td>

          <td>o <a class="toc" href="#CaretAndSelectionStyles">Caret, selection, and hotspot styles</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Margins">Margins</a></td>

          <td>o <a class="toc" href="#OtherSettings">Other settings</a></td>

          <td>o <a class="toc" href="#BraceHighlighting">Brace highlighting</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#TabsAndIndentationGuides">Tabs and Indentation
          Guides</a></td>

          <td>o <a class="toc" href="#Markers">Markers</a></td>

          <td>o <a class="toc" href="#Indicators">Indicators</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Autocompletion">Autocompletion</a></td>

          <td>o <a class="toc" href="#UserLists">User lists</a></td>

          <td>o <a class="toc" href="#CallTips">Call tips</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#KeyboardCommands">Keyboard commands</a></td>

          <td>o <a class="toc" href="#KeyBindings">Key bindings</a></td>

          <td>o <a class="toc" href="#PopupEditMenu">Popup edit menu</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#MacroRecording">Macro recording</a></td>

          <td>o <a class="toc" href="#Printing">Printing</a></td>

          <td>o <a class="toc" href="#DirectAccess">Direct access</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#MultipleViews">Multiple views</a></td>

          <td>o <a class="toc" href="#Folding">Folding</a></td>

          <td>o <a class="toc" href="#LineWrapping">Line wrapping</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Zooming">Zooming</a></td>

          <td>o <a class="toc" href="#LongLines">Long lines</a></td>

          <td>o <a class="toc" href="#Lexer">Lexer</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#Notifications">Notifications</a></td>

          <td>o <a class="toc" href="#DeprecatedMessages">Deprecated messages</a></td>

          <td>o <a class="toc" href="#EditMessagesNeverSupportedByScintilla">Edit messages never
          supported by Scintilla</a></td>
        </tr>

        <tr>
          <td>o <a class="toc" href="#BuildingScintilla">Building Scintilla</a></td>
        </tr>
      </tbody>
    </table>

    <p><code>SCI_SETxxxxx</code> という名前のメッセージはしばしば <code>SCI_GETxxxxx</code> というメッセージと対になっています。かったるい繰り返しを少なくするために、<code>SCI_GETxxxxx</code> が <code>SCI_SETxxxxx</code> で設定された値を返す場合(だけ)、<code>SET</code> 処理のコードを書き、<code>GET</code> 処理は後の自分の想像のために残しておきます。</p>
    <p class="eng">Messages with names of the form <code>SCI_SETxxxxx</code> often have a companion
    <code>SCI_GETxxxxx</code>. To save tedious repetition, if the <code>SCI_GETxxxxx</code> message
    returns the value set by the <code>SCI_SETxxxxx</code> message, the <code>SET</code> routine is
    described and the <code>GET</code> routine is left to your imagination.</p>

    <h2 id="TextRetrievalAndModification"><span>テキストの獲得と変更</span><span class="eng">Text retrieval and modification</span></h2>

    <p>Scintilla が保持する文書の各文字は関連づけられた装飾情報を伴っています。文字オクテットと装飾オクテットの組はセルと呼ばれます。装飾オクテットは装飾番号を下位 5 ビットに、これとは独立して残りの 3 ビットを<a class="jump"
    href="#Indicators">識別子(indicators)</a> に使います。これにより大部分の言語に対応できる 32 種の基本修飾が可能となり、三つの独立識別子によって文法エラー、非推奨メッセージ、字下げの不整合などの情報も一度に表示可能となります。装飾に使うビット数は <a class="message"
    href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a> で変更でき、最大 7 ビットを割り当てることができます。残りのビットは識別子として利用可能です。</p><p>(訳注: 日本語のように一文字で複数バイトを要する文字は各オクテットに分散して保持し、実装でそれらがバラバラになるのを避ける設計のようです。ですから次の段落の「文字」はオクテット単位の話になると思われます。)
    <p class="eng">Each character in a Scintilla document is followed by an associated byte of styling
    information. The combination of a character byte and a style byte is called a cell. Style bytes
    are interpreted as a style index in the low 5 bits and as 3 individual bits of <a class="jump"
    href="#Indicators">indicators</a>. This allows 32 fundamental styles, which is enough for most
    languages, and three independent indicators so that, for example, syntax errors, deprecated
    names and bad indentation could all be displayed at once. The number of bits used for styles
    can be altered with <a class="message"
    href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a> up to a maximum of 7 bits.
    The remaining bits can be used for indicators.</p>

    <p>Scintilla が保持する文書における「位置」は文字もしくは文字の前の空間を参照します。文書の先頭の文字位置は 0 で、2 文字目が 1 、3 文字目が 2 となります。文書の保持する文字数が <code>nLen</code> であれば最後の文字位置は <code>nLen</code>-1 となります。キャレットは文字間に位置し、最初の文字の前 (0) から最後の文字の後ろ (<code>nLen</code>) までを移動することができます。</p>
    <p class="eng">Positions within the Scintilla document refer to a character or the gap before that
    character. The first character in a document is 0, the second 1 and so on. If a document
    contains <code>nLen</code> characters, the last character is numbered <code>nLen</code>-1.
    The caret exists between character positions and can be located from before the first character (0)
    to after the last character (<code>nLen</code>).</p>

    <p>二つのオクテットが一つの文字を構成している場合、その真ん中にキャレットを移動させることはできません。これは日本語のような DBCS 文字と CP/M 標準に由来する改行文字とそれに直接続く復帰文字の組み合わせにおいて発生します。<code>INVALID_POSITION</code> 定数 (-1) は文書内の不正な位置を表します。</p>
    <p class="eng">There are places where the caret can not go where two character bytes make up one character.
    This occurs when a DBCS character from a language like Japanese is included in the document or
    when line ends are marked with the CP/M standard of a carriage return followed by a line feed.
    The <code>INVALID_POSITION</code> constant (-1) represents an invalid position within the
    document.</p>

    <p>Scintilla のすべての行は同じ高さを持ち、現在有効なスタイルすべてのなかで一番大きなフォントから計算されます。この制限は実行性能を求めたものです。もし、各行の高さが異なるとしたら、文字位置から計算するために最初に装飾を完了しなくてはならないことになります。</p>
    <p class="eng">All lines of text in Scintilla are the same height, and this height is calculated from the
    largest font in any current style. This restriction is for performance; if lines differed in
    height then calculations involving positioning of text would require the text to be styled
    first.</p>
    <code><a class="message" href="#SCI_GETTEXT">SCI_GETTEXT(int length, char *text)</a><br />
     <a class="message" href="#SCI_SETTEXT">SCI_SETTEXT(&lt;unused&gt;, const char *text)</a><br />
     <a class="message" href="#SCI_SETSAVEPOINT">SCI_SETSAVEPOINT</a><br />
     <a class="message" href="#SCI_GETLINE">SCI_GETLINE(int line, char *text)</a><br />
     <a class="message" href="#SCI_REPLACESEL">SCI_REPLACESEL(&lt;unused&gt;, const char
    *text)</a><br />
     <a class="message" href="#SCI_SETREADONLY">SCI_SETREADONLY(bool readOnly)</a><br />
     <a class="message" href="#SCI_GETREADONLY">SCI_GETREADONLY</a><br />
     <a class="message" href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE(&lt;unused&gt;, TextRange
    *tr)</a><br />
     <a class="message" href="#SCI_ALLOCATE">SCI_ALLOCATE(int bytes, &lt;unused&gt;)</a><br />
     <a class="message" href="#SCI_ADDTEXT">SCI_ADDTEXT(int length, const char *s)</a><br />
     <a class="message" href="#SCI_ADDSTYLEDTEXT">SCI_ADDSTYLEDTEXT(int length, cell *s)</a><br />
     <a class="message" href="#SCI_APPENDTEXT">SCI_APPENDTEXT(int length, const char *s)</a><br />
     <a class="message" href="#SCI_INSERTTEXT">SCI_INSERTTEXT(int pos, const char *text)</a><br />
     <a class="message" href="#SCI_CLEARALL">SCI_CLEARALL</a><br />
     <a class="message" href="#SCI_CLEARDOCUMENTSTYLE">SCI_CLEARDOCUMENTSTYLE</a><br />
     <a class="message" href="#SCI_GETCHARAT">SCI_GETCHARAT(int position)</a><br />
     <a class="message" href="#SCI_GETSTYLEAT">SCI_GETSTYLEAT(int position)</a><br />
     <a class="message" href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT(&lt;unused&gt;, TextRange
    *tr)</a><br />
     <a class="message" href="#SCI_SETSTYLEBITS">SCI_SETSTYLEBITS(int bits)</a><br />
     <a class="message" href="#SCI_GETSTYLEBITS">SCI_GETSTYLEBITS</a><br />
    </code>
	<h3 id="SCI_GETTEXT">SCI_GETTEXT(int length, char *text)</h3>
    <p>文書の先頭から <code>length</code>-1 文字のテキストを取り出し、終端文字 0 を加えて返します。文書の全テキストを獲得するには <code>SCI_GETLENGTH</code> を用いて文書が保持する文字数 (<code>nLen</code>) を獲得してください。長さ <code>nLen+1</code> バイトのバッファを割り当ててから <code>SCI_GETTEXT(nLen+1, char
    *text)</code> を呼び出します。text 引数が 0 の場合、文書のすべてを収めるに必要な大きさが返されます。テキストを保存したときは、 <code>SCI_SETSAVEPOINT</code> を用いてテキストを未編集扱いにするべきです。</p>
    <p>参照: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a class="message"
    href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a></code></p>
    <p class="eng"><b>SCI_GETTEXT(int length, char *text)</b><br />
     This returns <code>length</code>-1 characters of text from the start of the document plus one
    terminating 0 character. To collect all the text in a document, use <code>SCI_GETLENGTH</code>
    to get the number of characters in the document (<code>nLen</code>), allocate a character
    buffer of length <code>nLen+1</code> bytes, then call <code>SCI_GETTEXT(nLen+1, char
    *text)</code>. If the text argument is 0 then the length that should be allocated to store the
    entire document is returned.
    If you then save the text, you should use <code>SCI_SETSAVEPOINT</code> to mark
    the text as unmodified.</p>

    <p class="eng">See also: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a class="message"
    href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a></code></p>

    <h3 id="SCI_SETTEXT">SCI_SETTEXT(&lt;unused&gt;, const char *text)</h3>
	<p>文書内のテキストすべてを指定した文字列で置き換えます。text は 0 終端を持つ文字列を指定します。</p>
    <p class="eng"><b>SCI_SETTEXT(&lt;unused&gt;, const char *text)</b><br />
     This replaces all the text in the document with the zero terminated text string you pass
    in.</p>
	<h3 id="SCI_SETSAVEPOINT">SCI_SETSAVEPOINT</h3>
    <p>Scintilla に文書を未編集扱いにすることを伝えます。通常はファイルの保存あるいは読み出しを行ったときに実行することからこの名前(保存ポイント)があります。Scintilla がやり直しと再実行を扱うのと同様に、<code><a class="message"
    href="#SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</a></code> と <code><a class="message"
    href="#SCN_SAVEPOINTLEFT">SCN_SAVEPOINTLEFT</a></code> の各<a class="jump"
    href="#Notifications">通知メッセージ</a>により、コンテナにファイルが変更されていることを考慮すべきかどうかを知らせることができます。(未訳: あとで意味の検証必要)</p>
	<p>参照: <code><a class="message" href="#SCI_EMPTYUNDOBUFFER">SCI_EMPTYUNDOBUFFER</a>, <a
    class="message" href="#SCI_GETMODIFY">SCI_GETMODIFY</a></code></p>
    <p class="eng"><b>SCI_SETSAVEPOINT</b><br />
     This message tells Scintilla that the current state of the document is unmodified. This is
    usually done when the file is saved or loaded, hence the name "save point". As Scintilla
    performs undo and redo operations, it notifies the container that it has entered or left the
    save point with <code><a class="message"
    href="#SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</a></code> and <code><a class="message"
    href="#SCN_SAVEPOINTLEFT">SCN_SAVEPOINTLEFT</a></code> <a class="jump"
    href="#Notifications">notification messages</a>, allowing the container to know if the file
    should be considered dirty or not.</p>

    <p class="eng">See also: <code><a class="message" href="#SCI_EMPTYUNDOBUFFER">SCI_EMPTYUNDOBUFFER</a>, <a
    class="message" href="#SCI_GETMODIFY">SCI_GETMODIFY</a></code></p>

	<h3 id="SCI_GETLINE">SCI_GETLINE(int line, char *text)</h3>
    <p>text 引数で指定されたバッファを、指定された行の内容で満たします。行番号は 0 から始まります。バッファは 0 を終端文字に持ちません。バッファがテキストを格納するに充分な長さを持っていることは呼び出し側が保証しなくてはなりません。<a class="message"
    href="#SCI_LINELENGTH"><code>SCI_LINELENGTH(int line)</code></a> を使ってください。戻り値はバッファに複写された文字数です。返された文字列は行末文字を含んでいます。文書がもつ行数を超える行番号が指定された場合は一文字も複写されません。text 引数が 0 の場合は行全体を保存するに必要な長さが返されます。</p>
	<p>参照: <code><a class="message" href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a
    class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a></code></p>
    <p class="eng"><b>SCI_GETLINE(int line, char *text)</b><br />
     This fills the buffer defined by text with the contents of the nominated line (lines start at
    0). The buffer is not terminated by a 0 character. It is up to you to make sure that the buffer
    is long enough for the text, use <a class="message"
    href="#SCI_LINELENGTH"><code>SCI_LINELENGTH(int line)</code></a>. The returned value is the
    number of characters copied to the buffer. The returned text includes any end of line
    characters. If you ask for a line number outside the range of lines in the document, 0
    characters are copied. If the text argument is 0 then the length that should be allocated
    to store the entire line is returned.</p>

    <p class="eng">See also: <code><a class="message" href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a
    class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a></code></p>

	<h3 id="SCI_REPLACESEL">SCI_REPLACESEL(&lt;unused&gt;, const char *text)</h3>
    <p><a class="jump" href="#SelectionAndInformation">アンカーから現在位置</a>までの選択範囲のテキストを指定した 0 終端文字列で置換します。アンカーと現在位置が同じの時はキャレットの位置に指定文字列が挿入されます。キャレットは挿入された文字列の後ろに移動し、必要であれば画面がスクロールしてキャレットが見えるようになります。</p>
    <p class="eng"><b>SCI_REPLACESEL(&lt;unused&gt;, const char *text)</b><br />
     The currently selected text between the <a class="jump" href="#SelectionAndInformation">anchor
    and the current position</a> is replaced by the 0 terminated text string. If the anchor and
    current position are the same, the text is inserted at the caret position. The caret is
    positioned after the inserted text and the caret is scrolled into view.</p>
	<h3 id="SCI_SETREADONLY">SCI_SETREADONLY(bool readOnly)<br /><span id="SCI_GETREADONLY">SCI_GETREADONLY</span></h3>
    <p>これらのメッセージは文書の「読み出し専用」フラグを設定したり読み出したりします。文書を読み出し専用にすると、テキストを変更しようとしたときに <a class="message"
    href="#SCN_MODIFYATTEMPTRO"><code>SCN_MODIFYATTEMPTRO</code></a> 通知が発生します。</p>
    <p class="eng"><b>SCI_SETREADONLY(bool readOnly)</b><br />
     <b>SCI_GETREADONLY</b><br />
     These messages set and get the read-only flag for the document. If you mark a document as read
    only, attempts to modify the text cause the <a class="message"
    href="#SCN_MODIFYATTEMPTRO"><code>SCN_MODIFYATTEMPTRO</code></a> notification.</p>

	<h3 id="SCI_GETTEXTRANGE">SCI_GETTEXTRANGE(&lt;unused&gt;, <a class="jump"
    href="#TextRange">TextRange</a> *tr)</h3>
    <p><code>cpMin</code> から <code>cpMax</code> までの範囲の文字列を <code>lpstrText</code> に複写します(<code>Scintilla.h</code> にある <code>TextRange</code> 構造体を参照ください)。<code>cpMax</code> が -1 の場合は文書の最後までが範囲となります。返される文字列は 0 終端を持ちます。従って、バッファの大きさは読み出し予定の大きさよりも少なくとも 1 文字長くなくてはなりません。戻り値は終端の 0 を含まない文字列の長さです。</p>
	<p>参照: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a></code></p>
    <p class="eng"><b>SCI_GETTEXTRANGE(&lt;unused&gt;, <a class="jump"
    href="#TextRange">TextRange</a> *tr)</b><br />
     This collects the text between the positions <code>cpMin</code> and <code>cpMax</code> and
    copies it to <code>lpstrText</code> (see <code>struct TextRange</code> in
    <code>Scintilla.h</code>). If <code>cpMax</code> is -1, text is returned to the end of the
    document. The text is 0 terminated, so you must supply a buffer that is at least 1 character
    longer than the number of characters you wish to read. The return value is the length of the
    returned text not including the terminating 0.</p>

    <p></p>
    <p class="eng">See also: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a></code></p>
	<h3 id="SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT(&lt;unused&gt;, <a class="jump"
    href="#TextRange">TextRange</a> *tr)</h3>
    <p>装飾情報を含めて文字列をバッファに複写します。各セルは 2 オクテットを使用し、各セル内の下位アドレス側に文字、上位アドレス側に装飾情報が格納されます。<code>cpMin</code> から <code>cpMax</code> までの文字が <code>lpstrText</code>  に複写されます(<code>Scintilla.h</code> にある <code>TextRange</code> 構造体を参照ください)。終端には 2 オクテットの 0 が追加されます。従って <code>lpstrText</code> で指定するバッファは少なくとも <code>2*(cpMax-cpMin)+2</code> バイトの大きさが必要です。<code>cpMin</code> や <code>cpMax</code> が有効な値かどうかの検査は行われません。文書の外を示す位置は文字・装飾情報ともに 0 を返します。</p>
    <p class="eng"><b>SCI_GETSTYLEDTEXT(&lt;unused&gt;, <a class="jump"
    href="#TextRange">TextRange</a> *tr)</b><br />
     This collects styled text into a buffer using two bytes for each cell, with the character at
    the lower address of each pair and the style byte at the upper address. Characters between the
    positions <code>cpMin</code> and <code>cpMax</code> are copied to <code>lpstrText</code> (see
    <code>struct TextRange</code> in <code>Scintilla.h</code>). Two 0 bytes are added to the end of
    the text, so the buffer that <code>lpstrText</code> points at must be at least
    <code>2*(cpMax-cpMin)+2</code> bytes long. No check is made for sensible values of
    <code>cpMin</code> or <code>cpMax</code>. Positions outside the document return character codes
    and style bytes of 0.</p>
	<p>参照: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a></code></p>
    <p class="eng">See also: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a></code></p>
	<h3 id="SCI_ALLOCATE">SCI_ALLOCATE(int bytes, &lt;unused&gt;)</h3>
    <p>与えられたバイト数を格納するに充分な文書バッファを割り当てます。その文書は現在の内容よりも小さくなることはありません。</p>
    <p class="eng"><b>SCI_ALLOCATE(int bytes, &lt;unused&gt;)</b><br />
     Allocate a document buffer large enough to store a given number of bytes.
     The document will not be made smaller than its current contents.</p>
	<h3 id="SCI_ADDTEXT">SCI_ADDTEXT(int length, const char *s)</h3>
    <p>文字列 <code>s</code> の最初の <code>length</code> 文字を現在位置に挿入します。挿入処理を停止させるための 0 を文字列の中に含めることができます。現在位置は挿入された文字列の後ろに移動しますが、自動スクロールは行われません。</p>
    <p class="eng"><b>SCI_ADDTEXT(int length, const char *s)</b><br />
     This inserts the first <code>length</code> characters from the string <code>s</code>
    at the current position. This will include any 0's in the string that you might have expected
    to stop the insert operation. The current position is set at the end of the inserted text,
    but it is not scrolled into view.</p>
	<h3 id="SCI_ADDSTYLEDTEXT">SCI_ADDSTYLEDTEXT(int length, cell *s)</h3>
    <p><code>SCI_ADDTEXT</code> と同様ですが、挿入されるのは装飾付文字列です。</p>
    <p class="eng"><b>SCI_ADDSTYLEDTEXT(int length, cell *s)</b><br />
     This behaves just like <code>SCI_ADDTEXT</code>, but inserts styled text.</p>
	<h3 id="SCI_APPENDTEXT">SCI_APPENDTEXT(int length, const char *s)</h3>
    <p>文字列 <code>s</code> の最初の <code>length</code> 文字を文書の最後に挿入します。挿入処理を停止させるための 0 を文字列の中に含めることができます。現在の選択範囲は変更されず、挿入された文字列を見せるような自動スクロールも発生しません。</p>
    <p class="eng"><b>SCI_APPENDTEXT(int length, const char *s)</b><br />
     This adds the first <code>length</code> characters from the string <code>s</code> to the end
    of the document. This will include any 0's in the string that you might have expected to stop
    the operation. The current selection is not changed and the new text is not scrolled into
    view.</p>
	<h3 id="SCI_INSERTTEXT">SCI_INSERTTEXT(int pos, const char *text)</h3>
    <p>0 終端文字列 <code>text</code> を位置 <code>pos</code> か、もしこれが -1 であれば現在位置に挿入します。現在位置は挿入された文字列の後ろに移動しますが、自動スクロールは発生しません。 </p>
    <p class="eng"><b>SCI_INSERTTEXT(int pos, const char *text)</b><br />
     This inserts the zero terminated <code>text</code> string at position <code>pos</code> or at
    the current position if <code>pos</code> is -1. The current position is set at the end of the
    inserted text, but it is not scrolled into view.</p>
	<h3 id="SCI_CLEARALL">SCI_CLEARALL</h3>
    <p>文書が読み出し専用でない限り、テキストすべてを削除します。</p>
    <p class="eng"><b>SCI_CLEARALL</b><br />
     Unless the document is read-only, this deletes all the text.</p>
	<h3 id="SCI_CLEARDOCUMENTSTYLE">SCI_CLEARDOCUMENTSTYLE</h3>
    <p>解析器を選択した後など、文書全体を再装飾したい場合は <code>SCI_CLEARDOCUMENTSTYLE</code> ですべての装飾情報と折りたたみ状態をクリアすることができます。</p>
    <p class="eng"><b>SCI_CLEARDOCUMENTSTYLE</b><br />
     When wanting to completely restyle the document, for example after choosing a lexer, the
    <code>SCI_CLEARDOCUMENTSTYLE</code> can be used to clear all styling information and reset the
    folding state.</p>
	<h3 id="SCI_GETCHARAT">SCI_GETCHARAT(int pos)</h3>
    <p>文書内の位置 <code>pos</code> にある文字を返します。<code>pos</code> が範囲外の値であれば 0 が返されます。</p>
    <p class="eng"><b>SCI_GETCHARAT(int pos)</b><br />
     This returns the character at <code>pos</code> in the document or 0 if <code>pos</code> is
    negative or past the end of the document.</p>
	<h3 id="SCI_GETSTYLEAT">SCI_GETSTYLEAT(int pos)</h3>
    <p>文書内の位置 <code>pos</code> についての装飾情報を返します。<code>pos</code> が範囲外の値であれば 0 が返されます。</p>
    <p class="eng"><b id="SCI_GETSTYLEAT">SCI_GETSTYLEAT(int pos)</b><br />
     This returns the style at <code>pos</code> in the document, or 0 if <code>pos</code> is
    negative or past the end of the document.</p>
	<h3 id="SCI_SETSTYLEBITS">SCI_SETSTYLEBITS(int bits)<br />
     <span id="SCI_GETSTYLEBITS">SCI_GETSTYLEBITS</span></h3>
    <p>各セルで装飾情報に使われるビット数の設定と読み出しを行います。装飾情報は最大 7 ビットにすることができます。残りのビットは識別子として用いることができます。標準設定は <code>SCI_SETSTYLEBITS(5)</code> です。</p>
    <p class="eng"><b>SCI_SETSTYLEBITS(int bits)</b><br />
     <b>SCI_GETSTYLEBITS</b><br />
     This pair of routines sets and reads back the number of bits in each cell to use for styling,
    to a maximum of 7 style bits. The remaining bits can be used as indicators. The standard
    setting is <code>SCI_SETSTYLEBITS(5)</code>.</p>
	<h3><span id="TextRange">TextRange</span> と <span id="CharacterRange">CharacterRange</span></h3>
    <p>これらの構造体は Win32 の <code>TEXTRANGE</code> および <code>CHARRANGE</code> と全く同じ形で定義されています。これにより、Scintilla をリッチエディットのように扱う古いコードも動作します。</p>
    <p class="eng"><b>TextRange</b> and <b>CharacterRange</b><br />
     These structures are defined to be exactly the same shape as the Win32 <code>TEXTRANGE</code>
    and <code>CHARRANGE</code>, so that older code that treats Scintilla as a RichEdit will
    work.</p>
<pre>
struct CharacterRange {
    long cpMin;
    long cpMax;
};

struct TextRange {
    struct CharacterRange chrg;
    char *lpstrText;
};
</pre>

    <h2 id="Searching"><span>検索と置換</span><span class="eng">Searching</span></h2>
    <code><a class="message" href="#SCI_FINDTEXT">SCI_FINDTEXT(int flags, TextToFind
    *ttf)</a><br />
     <a class="message" href="#SCI_SEARCHANCHOR">SCI_SEARCHANCHOR</a><br />
     <a class="message" href="#SCI_SEARCHNEXT">SCI_SEARCHNEXT(int searchFlags, const char
    *text)</a><br />
     <a class="message" href="#SCI_SEARCHPREV">SCI_SEARCHPREV(int searchFlags, const char
    *text)</a><br />
	<a class="jump" href="#SearchAndReplaceUsingTheTarget">target を使った検索と置換</a><br />
     <span class="eng"><a class="jump" href="#SearchAndReplaceUsingTheTarget">Search and replace using the
    target</a></span><br />
    </code>

	<h3 id="searchFlags"><code>searchFlags</code></h3>
    <p>検索ルーチンのいくつかは flag オプションを使います。これにより簡単な正規表現検索が可能です。次のフラグを加算合成してください。</p>
    <p class="eng"><b id="searchFlags"><code>searchFlags</code></b><br />
     Several of the search routines use flag options, which include a simple regular expression
    search. Combine the flag options by adding them:</p>

    <table border="0" summary="検索フラグ">
      <tbody>
        <tr>
          <td><code>SCFIND_MATCHCASE</code></td>

          <td>検索文字列の大文字小文字まで一致した場合のみ合致とみなします。</td>
        </tr>

        <tr>
          <td><code>SCFIND_WHOLEWORD</code></td>

          <td>前後の文字が単語を構成するものではない場合のみ合致とみなします。<br />(訳注: 日本語でどれだけ役に立つかという点は怪しい。次も同様。)</td>
        </tr>

        <tr>
          <td><code>SCFIND_WORDSTART</code></td>

          <td>前の文字が単語を構成するものではない場合のみ合致とみなします。</td>
        </tr>

        <tr>
          <td><code>SCFIND_REGEXP</code></td>

          <td>指定する検索文字列が正規表現とみなされます。</td>
        </tr>
        <tr>
          <td><code>SCFIND_POSIX</code></td>

          <td>正規表現の書式がより POSIX 互換となります。( ) はエスケープなしでタグを生成します。</td>
        </tr>
      </tbody>
    </table>
    <table class="eng" border="0" summary="Search flags">
      <tbody>
        <tr>
          <td><code>SCFIND_MATCHCASE</code></td>

          <td>A match only occurs with text that matches the case of the search string.</td>
        </tr>

        <tr>
          <td><code>SCFIND_WHOLEWORD</code></td>

          <td>A match only occurs if the characters before and after are not word characters.</td>
        </tr>

        <tr>
          <td><code>SCFIND_WORDSTART</code></td>

          <td>A match only occurs if the character before is not a word character.</td>
        </tr>

        <tr>
          <td><code>SCFIND_REGEXP</code></td>

          <td>The search string should be interpreted as a regular expression.</td>
        </tr>
        <tr>
          <td><code>SCFIND_POSIX</code></td>

          <td>Treat regular expression in a more POSIX compatible manner
	  by interpreting bare ( and ) for tagged sections rather than \( and \).</td>
        </tr>
      </tbody>
    </table>

    <p><code>searchFlags</code> に <code>SCFIND_REGEXP</code> が含まれていなければ、検索範囲の終端を開始端より前に持ってくるという手法で逆方向検索を行うことができます。<code>SCFIND_REGEXP</code> が含まれている場合は、位置指定が逆転していても常に文書の順方向に検索します。</p>
    <p class="eng">If <code>SCFIND_REGEXP</code> is not included in the <code>searchFlags</code>, you can
    search backwards to find the previous occurrence of a search string by setting the end of the
    search range before the start. If <code>SCFIND_REGEXP</code> is included, searches are always
    from a lower position to a higher position, even if the search range is backwards.</p>

    <p>正規表現の中で特殊文字として扱われる文字は以下の通りです。</p>
    <p class="eng">In a regular expression, special characters interpreted are:</p>

    <table border="0" summary="正規表現の概要">
      <tbody>
        <tr>
          <td><code>.</code></td>

          <td>任意の一文字と一致します。</td>
        </tr>

        <tr>
          <td><code>\(</code></td>

          <td>一致部のタグづけ範囲の開始を定めます。</td>
        </tr>

        <tr>
          <td><code>\)</code></td>

          <td>タグ付け範囲の範囲の終わりを定めます。</td>
        </tr>

        <tr>
          <td><code>\n</code></td>

          <td><code>n</code> は 1 〜 9 までで、n 番目のタグ範囲に合致した文字列を参照します。例えば、検索文字列が <code>Fred\([1-9]\)XXX</code> で 置換文字列が <code>Sam\1YYY</code> であるとき、<code>Fred2XXX</code> が与えられると <code>Sam2YYY</code> に置換されます。</td>
        </tr>

        <tr>
          <td><code>\&lt;</code></td>

          <td>Scintilla の定義する単語の開始位置に一致します。</td>
        </tr>

        <tr>
          <td>\&gt;</td>

          <td>Scintilla の定義する単語の終了位置に一致します。</td>
        </tr>

        <tr>
          <td><code>\x</code></td>

          <td>通常は正規表現内で特殊な意味を持つ文字 x をその文字そのものとして使います。例えば \[ は文字集合の開始ではなく単なる [ の文字として扱われます。</td>
        </tr>

        <tr>
          <td><code>[...]</code></td>

          <td>文字集合を意味します。[abc] は a, b, c, のいずれか一文字に合致します。範囲指定も可能で、[a-z] は全ての小文字一文字に合致します。</td>
        </tr>

        <tr>
          <td><code>[^...]</code></td>

          <td>文字集合の補集合を意味します。[^A-Za-z] はアルファベット以外の全ての文字一字に合致します。</td>
        </tr>

        <tr>
          <td><code>^</code></td>

          <td>(上記の「文字の補集合」の中で使われているのでなければ)行頭に合致します。</td>
        </tr>

        <tr>
          <td><code>$</code></td>

          <td>行末に合致します。</td>
        </tr>

        <tr>
          <td><code>*</code></td>

          <td>0 回以上の繰り返しに合致します。<code>Sa*m</code> は <code>Sm</code>,
          <code>Sam</code>, <code>Saam</code>, <code>Saaam</code> などのすべてに合致します。</td>
        </tr>

        <tr>
          <td><code>+</code></td>

          <td>1 回以上の繰り返しに合致します。<code>Sa+m</code> は
          <code>Sam</code>, <code>Saam</code>, <code>Saaam</code> などに合致します。</td>
        </tr>
      </tbody>
    </table>
    <table class="eng" border="0" summary="Regular expression synopsis">
      <tbody>
        <tr>
          <td><code>.</code></td>

          <td>Matches any character</td>
        </tr>

        <tr>
          <td><code>\(</code></td>

          <td>This marks the start of a region for tagging a match.</td>
        </tr>

        <tr>
          <td><code>\)</code></td>

          <td>This marks the end of a tagged region.</td>
        </tr>

        <tr>
          <td><code>\n</code></td>

          <td>Where <code>n</code> is 1 through 9 refers to the first through ninth tagged region
          when replacing. For example, if the search string was <code>Fred\([1-9]\)XXX</code> and
          the replace string was <code>Sam\1YYY</code>, when applied to <code>Fred2XXX</code> this
          would generate <code>Sam2YYY</code>.</td>
        </tr>

        <tr>
          <td><code>\&lt;</code></td>

          <td>This matches the start of a word using Scintilla's definitions of words.</td>
        </tr>

        <tr>
          <td>\&gt;</td>

          <td>This matches the end of a word using Scintilla's definition of words.</td>
        </tr>

        <tr>
          <td><code>\x</code></td>

          <td>This allows you to use a character x that would otherwise have a special meaning. For
          example, \[ would be interpreted as [ and not as the start of a character set.</td>
        </tr>

        <tr>
          <td><code>[...]</code></td>

          <td>This indicates a set of characters, for example, [abc] means any of the characters a,
          b or c. You can also use ranges, for example [a-z] for any lower case character.</td>
        </tr>

        <tr>
          <td><code>[^...]</code></td>

          <td>The complement of the characters in the set. For example, [^A-Za-z] means any
          character except an alphabetic character.</td>
        </tr>

        <tr>
          <td><code>^</code></td>

          <td>This matches the start of a line (unless used inside a set, see above).</td>
        </tr>

        <tr>
          <td><code>$</code></td>

          <td>This matches the end of a line.</td>
        </tr>

        <tr>
          <td><code>*</code></td>

          <td>This matches 0 or more times. For example, <code>Sa*m</code> matches <code>Sm</code>,
          <code>Sam</code>, <code>Saam</code>, <code>Saaam</code> and so on.</td>
        </tr>

        <tr>
          <td><code>+</code></td>

          <td>This matches 1 or more times. For example, <code>Sa+m</code> matches
          <code>Sam</code>, <code>Saam</code>, <code>Saaam</code> and so on.</td>
        </tr>
      </tbody>
    </table>
	<h3 id="SCI_FINDTEXT">SCI_FINDTEXT(int searchFlags, <a class="jump"
    href="#TextToFind">TextToFind</a> *ttf)</h3>
    <p>文書内の文字列を検索します。選択範囲を参照したり移動させたりはしません。<a class="jump" href="#searchFlags"><code>searchFlags</code></a> 引数は検索方法の種類を指定します。正規表現も使用できます。</p>
    <p class="eng"><b>SCI_FINDTEXT(int searchFlags, <a class="jump"
    href="#TextToFind">TextToFind</a> *ttf)</b><br />
     This message searches for text in the document. It does not use or move the current selection.
    The <a class="jump" href="#searchFlags"><code>searchFlags</code></a> argument controls the
    search type, which includes regular expression searches.</p>

    <p><code>TextToFind</code> 構造体は <code>Scintilla.h</code> に定義されています。文書内の検索範囲を<code>chrg.cpMin</code> と <code>chrg.cpMax</code> に設定してください。<code>SCFIND_REGEXP</code> がフラグに含まれていなければ、<code>chrg.cpMax</code> を <code>chrg.cpMin</code> より小さくすることで逆方向検索が行えます。<code>SCFIND_REGEXP</code> が含まれている場合は常に順方向検索となります(<code>chrg.cpMax</code> が <code>chrg.cpMin</code> より小さい場合でも)。</p>
	<p><code>TextToFind</code> 構造体のメンバ <code>lpstrText</code> に、検索対象を表す 0 終端文字列へのポインタを設定してください。<code>TextToFind</code> の適用が難しい言語の場合は <code>SCI_SEARCHINTARGET</code> で代用することを考慮しましょう。</p>
    <p class="eng">The <code>TextToFind</code> structure is defined in <code>Scintilla.h</code>; set
    <code>chrg.cpMin</code> and <code>chrg.cpMax</code> with the range of positions in the document
    to search. If <code>SCFIND_REGEXP</code> is not included in the flags, you can search backwards by
    setting <code>chrg.cpMax</code> less than <code>chrg.cpMin</code>. If <code>SCFIND_REGEXP</code>
    is included, the search is always forwards (even if <code>chrg.cpMax</code> is less than <code>chrg.cpMin</code>).
    Set the <code>lpstrText</code> member of <code>TextToFind</code> to point at a zero terminated
    text string holding the search pattern. If your language makes the use of <code>TextToFind</code>
    difficult, you should consider using <code>SCI_SEARCHINTARGET</code> instead.</p>

    <p>検索が失敗したときは -1 が、成功したときは見つかった文字列の先頭位置が戻り値となります。<code>TextToFind</code> のメンバである <code>chrgText.cpMin</code> と <code>chrgText.cpMax</code> には見つかったテキストの開始端と終端の位置が収められます。</p>
    <p class="eng">The return value is -1 if the search fails or the position of the start of the found text if
    it succeeds. The <code>chrgText.cpMin</code> and <code>chrgText.cpMax</code> members of
    <code>TextToFind</code> are filled in with the start and end positions of the found text.</p>

    <p>参照: <code><a class="message"
    href="#SCI_SEARCHINTARGET">SCI_SEARCHINTARGET</a></code></p>
    <p class="eng">See also: <code><a class="message"
    href="#SCI_SEARCHINTARGET">SCI_SEARCHINTARGET</a></code></p>
	<h3 id="TextToFind">TextToFind</h3>
    <p>この構造体は正確に Win32 の <code>FINDTEXTEX</code> 構造体と等価になるように定義されています。リッチエディットコントロールとして Scintilla を扱う古いコードのためです。</p>
    <p class="eng"><b>TextToFind</b><br />
     This structure is defined to have exactly the same shape as the Win32 structure
    <code>FINDTEXTEX</code> for old code that treated Scintilla as a RichEdit control.</p>
<pre>
struct TextToFind {
    struct <a class="jump" href="#CharacterRange">CharacterRange</a> chrg;     // 検索範囲。
    char *lpstrText;                // 検索対象文字列 ( 終端を 0 にすること )。
    struct CharacterRange chrgText; // 合致文字列の位置が返される。
};
</pre>
<pre class="eng">
struct TextToFind {
    struct <a class="jump" href="#CharacterRange">CharacterRange</a> chrg;     // range to search
    char *lpstrText;                // the search pattern (zero terminated)
    struct CharacterRange chrgText; // returned as position of matching text
};
</pre>
	<h3 id="SCI_SEARCHANCHOR">SCI_SEARCHANCHOR<br />
	<span id="SCI_SEARCHNEXT">SCI_SEARCHNEXT(int searchFlags, const char *text)</span><br />
	<span id="SCI_SEARCHPREV">SCI_SEARCHPREV(int searchFlags, const char *text)</span><br />
	</h3>
    <p>これらによって再配置可能な検索を実行できます。マクロで記録できるような対話的多重インクリメンタルサーチが可能となります。(未訳)この三種のメッセージは <a class="message"
    href="#SCN_MACRORECORD"><code>SCN_MACRORECORD</code></a> の<a class="jump"
    href="#Notifications">通知</a>を送ります。</p>
    <p class="eng"><b>SCI_SEARCHANCHOR</b><br />
     <b>SCI_SEARCHNEXT(int searchFlags, const char *text)</b><br />
     <b>SCI_SEARCHPREV(int searchFlags, const char *text)</b><br />
     These messages provide relocatable search support. This allows multiple incremental
    interactive searches to be macro recorded while still setting the selection to found text so
    the find/select operation is self-contained. These three messages send <a class="message"
    href="#SCN_MACRORECORD"><code>SCN_MACRORECORD</code></a> <a class="jump"
    href="#Notifications">notifications</a> if macro recording is enabled.</p>

    <p><code>SCI_SEARCHANCHOR</code> は検索の開始位置を設定し、<code>SCI_SEARCHNEXT</code> と <code>SCI_SEARCHPREV</code> で現在の選択範囲の先頭あるいは最後（文書の先頭に近い方）を示します。<code>SCI_SEARCHNEXT</code> もしくは <code>SCI_SEARCHPREV</code> を呼び出すときは常に事前に <code>SCI_SEARCHANCHOR</code> を呼び出すべきです。</p>
    <p class="eng"><code>SCI_SEARCHANCHOR</code> sets the search start point used by
    <code>SCI_SEARCHNEXT</code> and <code>SCI_SEARCHPREV</code> to the start of the current
    selection, that is, the end of the selection that is nearer to the start of the document. You
    should always call this before calling either of <code>SCI_SEARCHNEXT</code> or
    <code>SCI_SEARCHPREV</code>.</p>

    <p><code>SCI_SEARCHNEXT</code> と <code>SCI_SEARCHPREV</code> は次あるいは前の合致部分を検索します。検索文字列は text で指定し、これは 0 終端文字列へのポインタです。検索方法は <a class="jump" href="#searchFlags"><code>searchFlags</code></a> で調整できます。正規表現で指定したときは <code>SCI_SEARCHPREV</code> は最初の合致部分文字列を探し当てるだけで、アンカーポイントの一つ前の合致部分を検索するわけではありません。</p>
    <p class="eng"><code>SCI_SEARCHNEXT</code> and <code>SCI_SEARCHPREV</code> search for the next and previous
    occurrence of the zero terminated search string pointed at by text. The search is modified by
    the <a class="jump" href="#searchFlags"><code>searchFlags</code></a>. If you request a regular
    expression, <code>SCI_SEARCHPREV</code> finds the first occurrence of the search string in the
    document, not the previous one before the anchor point.</p>

    <p>合致部分がなければ  -1 が、あれば開始位置が戻り値として返されます。合致文字列を示すために選択部が更新されますが、それが見えるようにするためにスクロールをするようなことはありません。</p>
    <p class="eng">The return value is -1 if nothing is found, otherwise the return value is the start position
    of the matching text. The selection is updated to show the matched text, but is not scrolled
    into view.</p>

    <p>参照: <a class="message" href="#SCI_SEARCHINTARGET"><code>SCI_SEARCHINTARGET</code></a>,
    <a class="message" href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a></p>
    <p class="eng">See also: <a class="message" href="#SCI_SEARCHINTARGET"><code>SCI_SEARCHINTARGET</code></a>,
    <a class="message" href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a></p>

    <h3 id="SearchAndReplaceUsingTheTarget"><span>target を使う検索と置換</span><span class="eng">Search and replace using the target</span></h3>

    <p><a class="message" href="#SCI_REPLACESEL"><code>SCI_REPLACESEL</code></a> を使うと視覚的に確認できるその他の変更やスクロールが発生します。これは時に思わぬ動作の場合があります。「すべてを置換」のような多数の変更を行う場合、target を代わりに使うことができます。まず変更される範囲を target に設定し、<code>SCI_REPLACETARGET</code> や <code>SCI_REPLACETARGETRE</code> を呼び出します。</p>
    <p class="eng">Using <a class="message" href="#SCI_REPLACESEL"><code>SCI_REPLACESEL</code></a>,
    modifications cause scrolling and other visible changes, which may take some time and cause
    unwanted display updates. If performing many changes, such as a replace all command, the target
    can be used instead. First, set the target, ie. the range to be replaced. Then call
    <code>SCI_REPLACETARGET</code> or <code>SCI_REPLACETARGETRE</code>.</p>

    <p>target で指定した範囲内での検索は <code>SCI_SEARCHINTARGET</code> で実行されます。文字数を別に与えられた文字列を使うため、ヌル文字を検索することもできます。検索に成功すると範囲の長さ、失敗すると -1 が返されます。失敗した場合、target は削除されません。<code>SCFIND_MATCHCASE</code>,
    <code>SCFIND_WHOLEWORD</code>, <code>SCFIND_WORDSTART</code>, <code>SCFIND_REGEXP</code> といったフラグが <code>SCI_SEARCHINTARGET</code> で使われる際、<code>SCI_SETSEARCHFLAGS</code> とも組み合わせることができます。構造体へのポインタが不要なことから、<code>SCI_SEARCHINTARGET</code> はいくつかの場合において <a class="message"
    href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a> よりも簡単に使うことができます。</p>
    <p class="eng">Searching can be performed within the target range with <code>SCI_SEARCHINTARGET</code>,
    which uses a counted string to allow searching for null characters. It returns the length of
    range or -1 for failure, in which case the target is not moved. The flags used by
    <code>SCI_SEARCHINTARGET</code> such as <code>SCFIND_MATCHCASE</code>,
    <code>SCFIND_WHOLEWORD</code>, <code>SCFIND_WORDSTART</code>, and <code>SCFIND_REGEXP</code>
    can be set with <code>SCI_SETSEARCHFLAGS</code>. <code>SCI_SEARCHINTARGET</code> may be simpler
    for some clients to use than <a class="message"
    href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a>, as that requires using a pointer to a
    structure.</p>
    <code><a class="message" href="#SCI_SETTARGETSTART">SCI_SETTARGETSTART(int pos)</a><br />
     <a class="message" href="#SCI_GETTARGETSTART">SCI_GETTARGETSTART</a><br />
     <a class="message" href="#SCI_SETTARGETEND">SCI_SETTARGETEND(int pos)</a><br />
     <a class="message" href="#SCI_GETTARGETEND">SCI_GETTARGETEND</a><br />
     <a class="message" href="#SCI_TARGETFROMSELECTION">SCI_TARGETFROMSELECTION</a><br />
     <a class="message" href="#SCI_SETSEARCHFLAGS">SCI_SETSEARCHFLAGS(int searchFlags)</a><br />
     <a class="message" href="#SCI_GETSEARCHFLAGS">SCI_GETSEARCHFLAGS</a><br />
     <a class="message" href="#SCI_SEARCHINTARGET">SCI_SEARCHINTARGET(int length, const char
    *text)</a><br />
     <a class="message" href="#SCI_REPLACETARGET">SCI_REPLACETARGET(int length, const char
    *text)</a><br />
     <a class="message" href="#SCI_REPLACETARGETRE">SCI_REPLACETARGETRE(int length, const char
    *text)</a><br />
    </code>
	<h3 id="SCI_SETTARGETSTART">SCI_SETTARGETSTART(int pos)<br />
     <span id="SCI_GETTARGETSTART">SCI_GETTARGETSTART</span><br />
     <span id="SCI_SETTARGETEND">SCI_SETTARGETEND(int pos)</span><br />
     <span id="SCI_GETTARGETEND">SCI_GETTARGETEND</span></h3>
    <p>target の開始及び終了点を設定あるいは取得します。正規表現を使わない検索を行っている場合は、開始点を終了点より後ろに置くことができます。このような指定を行うと文書の末尾側から合致部分を検索していきます。target は <code>SCI_SEARCHINTARGET</code> の成功によっても設定されます。</p>
    <p class="eng"><b>SCI_SETTARGETSTART(int pos)</b><br />
     <b>SCI_GETTARGETSTART</b><br />
     <b>SCI_SETTARGETEND(int pos)</b><br />
     <b>SCI_GETTARGETEND</b><br />
     These functions set and return the start and end of the target. When searching in non-regular
    expression mode, you can set start greater than end to find the last matching text in the
    target rather than the first matching text. The target is also set by a successful
    <code>SCI_SEARCHINTARGET</code>.</p>
	<h3 id="SCI_TARGETFROMSELECTION">SCI_TARGETFROMSELECTION</h3>
     <p>target の範囲が選択範囲に一致するよう再設定します。</p>
    <p class="eng"><b>SCI_TARGETFROMSELECTION</b><br />
     Set the target start and end to the start and end positions of the selection.</p>
	<h3  id="SCI_SETSEARCHFLAGS">SCI_SETSEARCHFLAGS(int searchFlags)<br />
	<span id="SCI_GETSEARCHFLAGS">SCI_GETSEARCHFLAGS</span></h3>
    <p><code>SCI_SEARCHINTARGET</code> で用いる <a class="jump" href="#searchFlags"><code>searchFlags</code></a> を設定または取得します。簡単な正規表現検索を含む数種のオプションフラグがあります。</p>
    <p class="eng"><b>SCI_SETSEARCHFLAGS(int searchFlags)</b><br />
     <b id="SCI_GETSEARCHFLAGS">SCI_GETSEARCHFLAGS</b><br />
     These get and set the <a class="jump" href="#searchFlags"><code>searchFlags</code></a> used by
    <code>SCI_SEARCHINTARGET</code>. There are several option flags including a simple regular
    expression search.</p>
	<h3 id="SCI_SEARCHINTARGET">SCI_SEARCHINTARGET(int length, const char *text)</h3>
    <p><code>SCI_SETTARGETSTART</code> と <code>SCI_SETTARGETEND</code> で定義された target 内の最初の合致文字列 text を検索します。text は 0 終端文字列というわけではなく、<code>length</code> で長さを指定します。検索が成功すれば target は合致した文字列を設定され、戻り値はその開始位置となります。検索に失敗すれば -1 が返されます。</p>
    <p class="eng"><b>SCI_SEARCHINTARGET(int length, const char *text)</b><br />
     This searches for the first occurrence of a text string in the target defined by
    <code>SCI_SETTARGETSTART</code> and <code>SCI_SETTARGETEND</code>. The text string is not zero
    terminated; the size is set by <code>length</code>. The search is modified by the search flags
    set by <code>SCI_SETSEARCHFLAGS</code>. If the search succeeds, the target is set to the found
    text and the return value is the position of the start of the matching text. If the search
    fails, the result is -1.</p>
	<h3 id="SCI_REPLACETARGET">SCI_REPLACETARGET(int length, const char *text)</h3>
    <p><code>length</code> が -1 の場合は <code>text</code> は 0 終端文字列でなくてはなりません。それ以外の場合は <code>length</code> で置換する文字列の文字数を指定します。戻り値は置換する文字列の長さです。文書内の文字列を削除する推奨された方法は target に削除される文字列を入れ、空文字列で置換するというものです。</p>
    <p class="eng"><b>SCI_REPLACETARGET(int length, const char *text)</b><br />
     If <code>length</code> is -1, <code>text</code> is a zero terminated string, otherwise
    <code>length</code> sets the number of character to replace the target with. The return value
    is the length of the replacement string.<br />
    Note that the recommanded way to delete text in the document is to set the target to the text to be removed,
    and to perform a replace target with an empty string.</p>
	<h3 id="SCI_REPLACETARGETRE">SCI_REPLACETARGETRE(int length, const char *text)</h3>
    <p>正規表現を使った合致部分の置換を行います。<code>length</code> が -1 のO場合は <code>text</code> は 0 終端文字列でなくてはなりません。それ以外の場合は <code>length</code> で text の先頭から使用する文字数を指定します。置換文字列は <code>\1</code> 〜 <code>\9</code> を含んだ文字列 text から、タグ付けされた合致部分を当てはめた上で生成されます。タグ付け部分の差し替えは直前の合致結果から採用されます。戻り値は置換文字列の長さです。</p>
    <p class="eng"><b>SCI_REPLACETARGETRE(int length, const char *text)</b><br />
     This replaces the target using regular expressions. If <code>length</code> is -1,
    <code>text</code> is a zero terminated string, otherwise <code>length</code> is the number of
    characters to use. The replacement string is formed from the text string with any sequences of
    <code>\1</code> through <code>\9</code> replaced by tagged matches from the most recent regular
    expression search. The return value is the length of the replacement string.</p>

    <p>参照: <a class="message" href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a></p>
    <p class="eng">See also: <a class="message" href="#SCI_FINDTEXT"><code>SCI_FINDTEXT</code></a></p>

    <h2 id="Overtype"><span>上書きモード</span><span class="eng">Overtype</span></h2>
	<h3 id="SCI_SETOVERTYPE">SCI_SETOVERTYPE(bool overType)<br />
	<span id="SCI_GETOVERTYPE">SCI_GETOVERTYPE</span></h3>
    <p>上書きモードが有効になっていると、キー入力した文字でキャレットの右側の文字を置換していきます。無効になっているときはキャレットの位置に挿入されます。<code>SCI_GETOVERTYPE</code> は上書きモードの時に <code>TRUE</code> (1) を、そうでないときに <code>FALSE</code> (0) を返します。<code>SCI_SETOVERTYPE</code> を使って上書きモードを切り替えることができます。</p>
    <p class="eng"><b>SCI_SETOVERTYPE(bool overType)</b><br />
     <b>SCI_GETOVERTYPE</b><br />
     When overtype is enabled, each typed character replaces the character to the right of the text
    caret. When overtype is disabled, characters are inserted at the caret.
    <code>SCI_GETOVERTYPE</code> returns <code>TRUE</code> (1) if overtyping is active, otherwise
    <code>FALSE</code> (0) will be returned. Use <code>SCI_SETOVERTYPE</code> to set the overtype
    mode.</p>

    <h2 id="CutCopyAndPaste"><span>切り取り、コピー、貼り付け</span><span class="eng">Cut, copy and paste</span></h2>

    <code><a class="message" href="#SCI_CUT">SCI_CUT</a><br />
     <a class="message" href="#SCI_COPY">SCI_COPY</a><br />
     <a class="message" href="#SCI_PASTE">SCI_PASTE</a><br />
     <a class="message" href="#SCI_CLEAR">SCI_CLEAR</a><br />
     <a class="message" href="#SCI_CANPASTE">SCI_CANPASTE</a><br />
     <a class="message" href="#SCI_COPYRANGE">SCI_COPYRANGE(int start, int end)</a><br />
     <a class="message" href="#SCI_COPYTEXT">SCI_COPYTEXT(int length,
     const char *text)</a><br />
    </code>
	<h3 id="SCI_CUT">SCI_CUT<br />
     <span id="SCI_COPY">SCI_COPY</span><br />
     <span id="SCI_PASTE">SCI_PASTE</span><br />
     <span id="SCI_CLEAR">SCI_CLEAR</span><br />
     <span id="SCI_CANPASTE">SCI_CANPASTE</span></h3>
    <p>クリップボードに対する標準的な切り取り、コピー、あるいはクリップボードから文書への貼り付け、および文書の全消去を行います。<br /><code>SCI_CANPASTE</code> は文書が読み出し専用でなく、選択範囲にも被保護部分が含まれていないときに 0 でない値を返します。「コピー可能か？」「切り取り可能か？」を知りたいときは <code>SCI_GETSELECTIONSTART()-SCI_GETSELECTIONEND()</code> を使ってください。コピー・切り取りが可能であれば 0 でない値が計算結果となります。</p>
    <p class="eng"><b>SCI_CUT</b><br />
     <b>SCI_COPY</b><br />
     <b>SCI_PASTE</b><br />
     <b>SCI_CLEAR</b><br />
     <b>SCI_CANPASTE</b><br />
     These commands perform the standard tasks of cutting and copying data to the clipboard,
    pasting from the clipboard into the document, and clearing the document.
    <code>SCI_CANPASTE</code> returns non-zero if the document isn't read-only and if the selection
    doesn't contain protected text. If you need a "can copy" or "can cut", use
    <code>SCI_GETSELECTIONSTART()-SCI_GETSELECTIONEND()</code>, which will be non-zero if you can
    copy or cut to the clipboard.</p>

    <p>GTK+ では、<code>SCI_CANPASTE</code>は完全には動作しません。読み出し専用文書でない限り常に <code>TRUE</code> を返します。</p>
    <p class="eng">GTK+ does not really support <code>SCI_CANPASTE</code> and always returns <code>TRUE</code>
    unless the document is read-only.</p>

	<h3 id="SCI_COPYRANGE">SCI_COPYRANGE(int start, int end)<br />
     <span id="SCI_COPYTEXT">SCI_COPYTEXT(int length, const char *text)</span></h3>
    <p><code>SCI_COPYRANGE</code> は文書内の指定された範囲を、<code>SCI_COPYTEXT</code> は指定した文字列をシステムのクリップボードにコピーします。</p>
     <p class="eng"><b>SCI_COPYRANGE(int start, int end)</b><br />
     <b>SCI_COPYTEXT(int length, const char *text)</b><br /></p>
    <p class="eng"><code>SCI_COPYRANGE</code> copies a range of text from the document to
    the system clipboard and <code>SCI_COPYTEXT</code> copies a supplied piece of
    text to the system clipboard.</p>

    <h2 id="ErrorHandling"><span>エラーの取り扱い</span><span class="eng">Error handling</span></h2>
	<h3 id="SCI_SETSTATUS">SCI_SETSTATUS(int status)<br />
	<span id="SCI_GETSTATUS">SCI_GETSTATUS</span></h3>
    <p>エラーが発生したとき、Scintilla は内部エラー番号を設定します。この値は <code>SCI_GETSTATUS</code> で取得できます。現在はまだ使われていませんが、将来利用できるようになる予定です。<code>SCI_SETSTATUS(0)</code> のコードでエラー状態をクリアします。</p>
    <p class="eng"><b>SCI_SETSTATUS(int status)</b><br />
     <b>SCI_GETSTATUS</b><br />
     If an error occurs, Scintilla may set an internal error number that can be retrieved with
    <code>SCI_GETSTATUS</code>. Not currently used but will be in the future. To clear the error
    status call <code>SCI_SETSTATUS(0)</code>.</p>

    <h2 id="UndoAndRedo"><span>取り消しと再実行</span><span class="eng">Undo and Redo</span></h2>

    <p>Scintilla は多段階の取り消し・再実行機能を持っています。取り消し可能な行動の記録はメモリがある限り行われます。Scintilla は文書の変更行動を保存します。一方、キャレットと選択範囲の移動は記録しません。可視範囲の移動も同様です。一続きのキー入力や削除は一回の行動に圧縮されます。これにより、取り消しと再実行は何が起きたか理解しやすくなります。連続した行動は一単位の取り消しとして使用できる行動に合成することができます。これらの連続体は<code>SCI_BEGINUNDOACTION</code> メッセージと
    <code>SCI_ENDUNDOACTION</code> メッセージの間で発生します。これらの連続体は入れ子にすることが可能です。また最上位の連続体のみが一単位で取り消しを実行できます。</p>
    <p class="eng">Scintilla has multiple level undo and redo. It will continue to collect undoable actions
    until memory runs out. Scintilla saves actions that change the document. Scintilla does not
    save caret and selection movements, view scrolling and the like. Sequences of typing or
    deleting are compressed into single actions to make it easier to undo and redo at a sensible
    level of detail. Sequences of actions can be combined into actions that are undone as a unit.
    These sequences occur between <code>SCI_BEGINUNDOACTION</code> and
    <code>SCI_ENDUNDOACTION</code> messages. These sequences can be nested and only the top-level
    sequences are undone as units.</p>
    <code><a class="message" href="#SCI_UNDO">SCI_UNDO</a><br />
     <a class="message" href="#SCI_CANUNDO">SCI_CANUNDO</a><br />
     <a class="message" href="#SCI_EMPTYUNDOBUFFER">SCI_EMPTYUNDOBUFFER</a><br />
     <a class="message" href="#SCI_REDO">SCI_REDO</a><br />
     <a class="message" href="#SCI_CANREDO">SCI_CANREDO</a><br />
     <a class="message" href="#SCI_SETUNDOCOLLECTION">SCI_SETUNDOCOLLECTION(bool
    collectUndo)</a><br />
     <a class="message" href="#SCI_GETUNDOCOLLECTION">SCI_GETUNDOCOLLECTION</a><br />
     <a class="message" href="#SCI_BEGINUNDOACTION">SCI_BEGINUNDOACTION</a><br />
     <a class="message" href="#SCI_ENDUNDOACTION">SCI_ENDUNDOACTION</a><br />
    </code>
	<h3 id="SCI_UNDO">SCI_UNDO<br />
     <span id="SCI_CANUNDO">SCI_CANUNDO</span></h3>
    <p><code>SCI_UNDO</code> で行動一つ分を取り消します。取り消しバッファが <code>SCI_ENDUNDOACTION</code> を行った点に達した場合は、対応する <code>SCI_BEGINUNDOACTION</code> まで一度に取り消し動作を行います。</p>
    <p class="eng"><b>SCI_UNDO</b><br />
     <b>SCI_CANUNDO</b><br />
     <code>SCI_UNDO</code> undoes one action, or if the undo buffer has reached a
    <code>SCI_ENDUNDOACTION</code> point, all the actions back to the corresponding
    <code>SCI_BEGINUNDOACTION</code>.</p>

    <p><code>SCI_CANUNDO</code> は取り消す動作がない場合に 0 を返し、ある場合は 1 を返します。このメッセージの結果は一般的に取り消しコマンドを使用可能にしておくか否かの切り替えに利用します。</p>
    <p class="eng"><code>SCI_CANUNDO</code> returns 0 if there is nothing to undo, and 1 if there is. You would
    typically use the result of this message to enable/disable the Edit menu Undo command.</p>
	<h3 id="SCI_REDO">SCI_REDO<br />
     <span id="SCI_CANREDO">SCI_CANREDO</span></h3>
    <p><code>SCI_REDO</code> は最後の取り消しをさらに取り消し、結果として再実行を行います。</p>
    <p class="eng"><b>SCI_REDO</b><br />
     <b>SCI_CANREDO</b><br />
     <code>SCI_REDO</code> undoes the effect of the last <code>SCI_UNDO</code> operation.</p>

    <p><code>SCI_CANREDO</code> は再実行する行動がないときに 0 を返し、あるときに 1 を返します。このメッセージの結果は一般的に再実行コマンドを使用可能にしておくか否かの切り替えに利用します。</p>
    <p class="eng"><code>SCI_CANREDO</code> returns 0 if there is no action to redo and 1 if there are undo
    actions to redo. You could typically use the result of this message to enable/disable the Edit
    menu Redo command.</p>
	<h3 id="SCI_EMPTYUNDOBUFFER">SCI_EMPTYUNDOBUFFER</h3>
    <p>Scintilla に取り消し・再実行のための履歴記録を破棄させます。同時に取り消しバッファの開始点を保存しますので、文書は未編集状態として扱われます。この処理ではコンテナに <code><a class="message"
    href="#SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</a></code> 通知を送りません。</p>
    <p class="eng"><b>SCI_EMPTYUNDOBUFFER</b><br />
     This command tells Scintilla to forget any saved undo or redo history. It also sets the save
    point to the start of the undo buffer, so the document will appear to be unmodified. This does
    not cause the <code><a class="message"
    href="#SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</a></code> notification to be sent to the
    container.</p>

    <p>参照: <a class="message" href="#SCI_SETSAVEPOINT"><code>SCI_SETSAVEPOINT</code></a></p>
    <p class="eng">See also: <a class="message" href="#SCI_SETSAVEPOINT"><code>SCI_SETSAVEPOINT</code></a></p>
	<h3 id="SCI_SETUNDOCOLLECTION">SCI_SETUNDOCOLLECTION(bool collectUndo)<br />
     <span id="SCI_GETUNDOCOLLECTION">SCI_GETUNDOCOLLECTION</span></h3>
    <p>Scintilla が取り消し情報を集めるか否かを設定できます。<code>SCI_SETUNDOCOLLECTION</code> の呼び出しで <code>true</code> (1) を与えると情報収集を行い、<code>false</code> (0) を与えると収集を停止します。<code>SCI_EMPTYUNDOBUFFER</code> も同時に使用すべきです。これは編集バッファが取り消しバッファと同期をとれなくなることを防ぎます。</p>
    <p class="eng"><b>SCI_SETUNDOCOLLECTION(bool collectUndo)</b><br />
     <b>SCI_GETUNDOCOLLECTION</b><br />
     You can control whether Scintilla collects undo information with
    <code>SCI_SETUNDOCOLLECTION</code>. Pass in <code>true</code> (1) to collect information and
    <code>false</code> (0) to stop collecting. If you stop collection, you should also use
    <code>SCI_EMPTYUNDOBUFFER</code> to avoid the undo buffer being unsynchronized with the data in
    the buffer.</p>

    <p>Scintilla がログの表示などプログラムが生成した文字列を表示するとか、テキストがしばしば削除と再生成を繰り返すといった場合に、取り消し情報の保存を禁止することになるでしょう。</p>
    <p class="eng">You might wish to turn off saving undo information if you use the Scintilla to store text
    generated by a program (a Log view) or in a display window where text is often deleted and
    regenerated.</p>
	<h3 id="SCI_BEGINUNDOACTION">SCI_BEGINUNDOACTION<br />
     <span id="SCI_ENDUNDOACTION">SCI_ENDUNDOACTION</span></h3>
    <p>これらのメッセージを Scintilla に送ると処理集合の開始点と終点を印付けることができます。印付けられた集合は一回の取り消し指示で全部が取り消されます。印付けを行わなければ一つ一つ取り消ししなくてはなりません。他方、取り消しの際に前後の処理と一緒にしたくないという目的でもこの印付けを利用することができます。</p>
    <p class="eng"><b>SCI_BEGINUNDOACTION</b><br />
     <b>SCI_ENDUNDOACTION</b><br />
     Send these two messages to Scintilla to mark the beginning and end of a set of operations that
    you want to undo all as one operation but that you have to generate as several operations.
    Alternatively, you can use these to mark a set of operations that you do not want to have
    combined with the preceding or following operations if they are undone.</p>

    <h2 id="SelectionAndInformation"><span>選択と情報</span><span class="eng">Selection and information</span></h2>

    <p>Scintilla は二点間に伸びる選択範囲を扱えます。この二点はアンカーと現在位置です。これらが同じ位置にある場合は選択範囲内にテキストがないということになります。文書内の位置は 0 (最初の文字の前)から文書の大きさ(最後の文字の後ろを表す)までです。メッセージを使うと CRLF の組や 2 オクテット文字列の真ん中を指定することも可能ですが、キーボードによる移動ではそのような位置を指定することはできません。</p>
    <p class="eng">Scintilla maintains a selection that stretches between two points, the anchor and the
    current position. If the anchor and the current position are the same, there is no selected
    text. Positions in the document range from 0 (before the first character), to the document size
    (after the last character). If you use messages, there is nothing to stop you setting a
    position that is in the middle of a CRLF pair, or in the middle of a 2 byte character. However,
    keyboard commands will not move the caret into such positions.</p>
    <code><a class="message" href="#SCI_GETTEXTLENGTH">SCI_GETTEXTLENGTH</a><br />
     <a class="message" href="#SCI_GETLENGTH">SCI_GETLENGTH</a><br />
     <a class="message" href="#SCI_GETLINECOUNT">SCI_GETLINECOUNT</a><br />
     <a class="message" href="#SCI_GETFIRSTVISIBLELINE">SCI_GETFIRSTVISIBLELINE</a><br />
     <a class="message" href="#SCI_LINESONSCREEN">SCI_LINESONSCREEN</a><br />
     <a class="message" href="#SCI_GETMODIFY">SCI_GETMODIFY</a><br />
     <a class="message" href="#SCI_SETSEL">SCI_SETSEL(int anchorPos, int currentPos)</a><br />
     <a class="message" href="#SCI_GOTOPOS">SCI_GOTOPOS(int position)</a><br />
     <a class="message" href="#SCI_GOTOLINE">SCI_GOTOLINE(int line)</a><br />
     <a class="message" href="#SCI_SETCURRENTPOS">SCI_SETCURRENTPOS(int position)</a><br />
     <a class="message" href="#SCI_GETCURRENTPOS">SCI_GETCURRENTPOS</a><br />
     <a class="message" href="#SCI_SETANCHOR">SCI_SETANCHOR(int position)</a><br />
     <a class="message" href="#SCI_GETANCHOR">SCI_GETANCHOR</a><br />
     <a class="message" href="#SCI_SETSELECTIONSTART">SCI_SETSELECTIONSTART(int position)</a><br />
     <a class="message" href="#SCI_GETSELECTIONSTART">SCI_GETSELECTIONSTART</a><br />
     <a class="message" href="#SCI_SETSELECTIONEND">SCI_SETSELECTIONEND(int position)</a><br />
     <a class="message" href="#SCI_GETSELECTIONEND">SCI_GETSELECTIONEND</a><br />
     <a class="message" href="#SCI_SELECTALL">SCI_SELECTALL</a><br />
     <a class="message" href="#SCI_LINEFROMPOSITION">SCI_LINEFROMPOSITION(int position)</a><br />
     <a class="message" href="#SCI_POSITIONFROMLINE">SCI_POSITIONFROMLINE(int line)</a><br />
     <a class="message" href="#SCI_GETLINEENDPOSITION">SCI_GETLINEENDPOSITION(int line)</a><br />
     <a class="message" href="#SCI_LINELENGTH">SCI_LINELENGTH(int line)</a><br />
     <a class="message" href="#SCI_GETCOLUMN">SCI_GETCOLUMN(int position)</a><br />
     <a class="message" href="#SCI_FINDCOLUMN">SCI_FINDCOLUMN(int line, int column)</a><br />
     <a class="message" href="#SCI_POSITIONFROMPOINT">SCI_POSITIONFROMPOINT(int x, int y)</a><br />
     <a class="message" href="#SCI_POSITIONFROMPOINTCLOSE">SCI_POSITIONFROMPOINTCLOSE(int x, int
    y)</a><br />
     <a class="message" href="#SCI_POINTXFROMPOSITION">SCI_POINTXFROMPOSITION(&lt;unused&gt;, int
    position)</a><br />
     <a class="message" href="#SCI_POINTYFROMPOSITION">SCI_POINTYFROMPOSITION(&lt;unused&gt;, int
    position)</a><br />
     <a class="message" href="#SCI_HIDESELECTION">SCI_HIDESELECTION(bool hide)</a><br />
     <a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT(&lt;unused&gt;, char *text)</a><br />
     <a class="message" href="#SCI_GETCURLINE">SCI_GETCURLINE(int textLen, char *text)</a><br />
     <a class="message" href="#SCI_SELECTIONISRECTANGLE">SCI_SELECTIONISRECTANGLE</a><br />
     <a class="message" href="#SCI_SETSELECTIONMODE">SCI_SETSELECTIONMODE</a><br />
     <a class="message" href="#SCI_GETSELECTIONMODE">SCI_GETSELECTIONMODE</a><br />
     <a class="message" href="#SCI_GETLINESELSTARTPOSITION">SCI_GETLINESELSTARTPOSITION(int line)</a><br />
     <a class="message" href="#SCI_GETLINESELENDPOSITION">SCI_GETLINESELENDPOSITION(int line)</a><br />
     <a class="message" href="#SCI_MOVECARETINSIDEVIEW">SCI_MOVECARETINSIDEVIEW</a><br />
     <a class="message" href="#SCI_WORDENDPOSITION">SCI_WORDENDPOSITION(int position, bool
    onlyWordCharacters)</a><br />
     <a class="message" href="#SCI_WORDSTARTPOSITION">SCI_WORDSTARTPOSITION(int position, bool
    onlyWordCharacters)</a><br />
     <a class="message" href="#SCI_POSITIONBEFORE">SCI_POSITIONBEFORE(int position)</a><br />
     <a class="message" href="#SCI_POSITIONAFTER">SCI_POSITIONAFTER(int position)</a><br />
     <a class="message" href="#SCI_TEXTWIDTH">SCI_TEXTWIDTH(int styleNumber, const char *text)</a><br />
     <a class="message" href="#SCI_TEXTHEIGHT">SCI_TEXTHEIGHT(int line)</a><br />
     <a class="message" href="#SCI_CHOOSECARETX">SCI_CHOOSECARETX</a><br />
    </code>
	<h3 id="SCI_GETTEXTLENGTH">SCI_GETTEXTLENGTH<br /><span id="SCI_GETLENGTH">SCI_GETLENGTH</span></h3>
    <p>これらのメッセージはともに文書の長さを文字数で返します。</p>
	<p>(訳注: 文字数ではなくオクテット数なのだろうが未確認)</p>
    <p class="eng"><b>SCI_GETTEXTLENGTH</b><br />
     <b>SCI_GETLENGTH</b><br />
     Both these messages return the length of the document in characters.</p>
	<h3 id="SCI_GETLINECOUNT">SCI_GETLINECOUNT</h3>
    <p>文書内の行数を返します。空の文書は 1 行あるとみなします。改行だけを持っている文書は 2 行とみなされます。</p>
    <p class="eng"><b>SCI_GETLINECOUNT</b><br />
     This returns the number of lines in the document. An empty document contains 1 line. A
    document holding only an end of line sequence has 2 lines.</p>
	<h3 id="SCI_GETFIRSTVISIBLELINE">SCI_GETFIRSTVISIBLELINE</h3>
    <p>Scintilla が最初に見せている行の行番号を返します。文書の先頭行番号は 0 です。</p>
    <p class="eng"><b>SCI_GETFIRSTVISIBLELINE</b><br />
     This returns the line number of the first visible line in the Scintilla view. The first line
    in the document is numbered 0.</p>
	<h3 id="SCI_LINESONSCREEN">SCI_LINESONSCREEN</h3>
    <p>画面に完全に表示できる行の数を返します。行の高さが一定ならば、この値は垂直方向の利用可能空間を行数で割ったものです。表示可能行がぴったり収まるようにウィンドウをリサイズするまでは画面の下端に部分的に見える行があるかも知れません。</p>
    <p class="eng"><b>SCI_LINESONSCREEN</b><br />
     This returns the number of complete lines visible on the screen. With a constant line height,
    this is the vertical space available divided by the line separation. Unless you arrange to size
    your window to an integral number of lines, there may be a partial line visible at the bottom
    of the view.</p>
	<h3 id="SCI_GETMODIFY">SCI_GETMODIFY</h3>
    <p>文書が変更されていれば 0 以外が、未変更ならば 0 が返されます。文書の変更状態は、取り消し情報列において保存位置と取り消し位置が異なるかどうかで決まります。この保存位置は通常ファイルにデータを保存した位置です。保存位置は <a class="message" href="#SCI_SETSAVEPOINT"><code>SCI_SETSAVEPOINT</code></a> で設定できます。</p>
    <p class="eng"><b id="SCI_GETMODIFY">SCI_GETMODIFY</b><br />
     This returns non-zero if the document is modified and 0 if it is unmodified. The modified
    status of a document is determined by the undo position relative to the save point. The save
    point is set by <a class="message" href="#SCI_SETSAVEPOINT"><code>SCI_SETSAVEPOINT</code></a>,
    usually when you have saved data to a file.</p>

    <p>文書が変更されようとしていることを知るには、保存位置に達したり保存位置から移動したりした際に Scintilla がコンテナに対して送る <a class="message"
    href="#SCN_SAVEPOINTREACHED"><code>SCN_SAVEPOINTREACHED</code></a> や <a class="message"
    href="#SCN_SAVEPOINTLEFT"><code>SCN_SAVEPOINTLEFT</code></a> <a class="jump"
    href="#Notifications">通知メッセージ</a>を利用します。</p>
    <p class="eng">If you need to be notified when the document becomes modified, Scintilla notifies the
    container that it has entered or left the save point with the <a class="message"
    href="#SCN_SAVEPOINTREACHED"><code>SCN_SAVEPOINTREACHED</code></a> and <a class="message"
    href="#SCN_SAVEPOINTLEFT"><code>SCN_SAVEPOINTLEFT</code></a> <a class="jump"
    href="#Notifications">notification messages</a>.</p>
	<h3 id="SCI_SETSEL">SCI_SETSEL(int anchorPos, int currentPos)</h3>
    <p>アンカーと現在位置の両方を設定します。<code>currentPos</code> が負数の場合、文書の末尾を意味します。<code>anchorPos</code> が負数の場合は選択範囲が無くなります。すなわち、アンカーが <code>currentPos</code> と同じ場所に移動します。このメッセージの実行後、スクロールによってキャレットが画面内に見えるようになります。</p>
    <p class="eng"><b>SCI_SETSEL(int anchorPos, int currentPos)</b><br />
     This message sets both the anchor and the current position. If <code>currentPos</code> is
    negative, it means the end of the document. If <code>anchorPos</code> is negative, it means
    remove any selection (i.e. set the anchor to the same position as <code>currentPos</code>). The
    caret is scrolled into view after this operation.</p>
	<h3 id="SCI_GOTOPOS">SCI_GOTOPOS(int pos)</h3>
    <p>選択範囲が無くなり、キャレットを <code>pos</code> に移動させ、また必要であればキャレットが見えるようにスクロールが行われます。<code>SCI_SETSEL(pos, pos)</code> と同じ効果をもたらします。アンカーはキャレットと同じ位置に設定されます。</p>
    <p class="eng"><b>SCI_GOTOPOS(int pos)</b><br />
     This removes any selection, sets the caret at <code>pos</code> and scrolls the view to make
    the caret visible, if necessary. It is equivalent to
    <code>SCI_SETSEL(pos, pos)</code>. The anchor position is set the same as the current
    position.</p>
	<h3 id="SCI_GOTOLINE">SCI_GOTOLINE(int line)</h3>
    <p>選択範囲が無くなり、キャレットを行番号 <code>line</code> の行の先頭に置きます。また必要であればキャレットが見えるようにスクロールが行われます。アンカーはキャレットと同じ位置に設定されます。<code>line</code> が文書の外を指定している場合は、先頭行か最終行とみなします。</p>
    <p class="eng"><b id="SCI_GOTOLINE">SCI_GOTOLINE(int line)</b><br />
     This removes any selection and sets the caret at the start of line number <code>line</code>
    and scrolls the view (if needed) to make it visible. The anchor position is set the same as the
    current position. If <code>line</code> is outside the lines in the document (first line is 0),
    the line set is the first or last.</p>
	<h3 id="SCI_SETCURRENTPOS">SCI_SETCURRENTPOS(int pos)</h3>
    <p>現在位置を変更し、アンカーとの間に選択範囲を設定します。キャレットを表示させるためのスクロールは行われません。</p>
    <p class="eng"><b id="SCI_SETCURRENTPOS">SCI_SETCURRENTPOS(int pos)</b><br />
     This sets the current position and creates a selection between the anchor and the current
    position. The caret is not scrolled into view.</p>

    <p>参照: <a class="message" href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a></p>
    <p class="eng">See also: <a class="message" href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a></p>
	<h3 id="SCI_GETCURRENTPOS">SCI_GETCURRENTPOS</h3>
    <p>現在位置を示す値を返します。</p>
    <p class="eng"><b>SCI_GETCURRENTPOS</b><br />
     This returns the current position.</p>
	<h3 id="SCI_SETANCHOR">SCI_SETANCHOR(int pos)</h3>
    <p>アンカーを移動し現在位置との間に選択範囲を設定します。キャレットを表示させるためのスクロールは行われません。</p>
    <p class="eng"><b>SCI_SETANCHOR(int pos)</b><br />
     This sets the anchor position and creates a selection between the anchor position and the
    current position. The caret is not scrolled into view.</p>

    <p>参照: <a class="message" href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a></p>
    <p class="eng">See also: <a class="message" href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a></p>
	<h3 id="SCI_GETANCHOR">SCI_GETANCHOR</h3>
    <p>アンカー位置を示す値を返します。</p>
    <p class="eng"><b>SCI_GETANCHOR</b><br />
     This returns the current anchor position.</p>
	<h3 id="SCI_SETSELECTIONSTART">SCI_SETSELECTIONSTART(int pos)<br />
     <span id="SCI_SETSELECTIONEND">SCI_SETSELECTIONEND(int pos)</span></h3>
    <p>これらのメッセージはアンカーがキャレットよりも前（先行する側）にあることを前提として選択範囲を設定します。キャレットを表示させるためのスクロールは行われません。実行後のキャレットとアンカーの位置については次の表をご覧ください。</p>
    <p class="eng"><b id="SCI_SETSELECTIONSTART">SCI_SETSELECTIONSTART(int pos)</b><br />
     <b id="SCI_SETSELECTIONEND">SCI_SETSELECTIONEND(int pos)</b><br />
     These set the selection based on the assumption that the anchor position is less than the
    current position. They do not make the caret visible. The table shows the positions of the
    anchor and the current position after using these messages.</p>

    <table cellpadding="3" cellspacing="0" border="1" summary="SETSELECTIONSTART/END 後のキャレットなどの位置">
      <thead align="center">
        <tr>
          <th>
          </th>

          <th>アンカー</th>

          <th>キャレット</th>
        </tr>
      </thead>

      <tbody align="center">
        <tr>
          <th><code>SCI_SETSELECTIONSTART</code></th>

          <td><code>pos</code></td>

          <td><code>Max(pos, キャレット位置)</code></td>
        </tr>

        <tr>
          <th><code>SCI_SETSELECTIONEND</code></th>

          <td><code>Min(アンカー位置, pos)</code></td>

          <td><code>pos</code></td>
        </tr>
      </tbody>
    </table>
    <p>参照: <a class="message" href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a></p>


    <table class="eng" cellpadding="3" cellspacing="0" border="1" summary="SetSelection caret positioning">
      <thead align="center">
        <tr>
          <th>
          </th>

          <th>anchor</th>

          <th>current</th>
        </tr>
      </thead>

      <tbody align="center">
        <tr>
          <th><code>SCI_SETSELECTIONSTART</code></th>

          <td><code>pos</code></td>

          <td><code>Max(pos, current)</code></td>
        </tr>

        <tr>
          <th><code>SCI_SETSELECTIONEND</code></th>

          <td><code>Min(anchor, pos)</code></td>

          <td><code>pos</code></td>
        </tr>
      </tbody>
    </table>

    <p class="eng">See also: <a class="message" href="#SCI_SCROLLCARET"><code>SCI_SCROLLCARET</code></a></p>
	<h3 id="SCI_GETSELECTIONSTART">SCI_GETSELECTIONSTART<br />
     <span id="SCI_GETSELECTIONEND">SCI_GETSELECTIONEND</span></h3>
    <p>選択範囲の開始端と終端を返します。キャレットとアンカーの前後関係には影響されません。<code>SCI_GETSELECTIONSTART</code> はそれらの位置の小さい方、<code>SCI_GETSELECTIONEND</code> は大きい方を返します。</p>
    <p class="eng"><b>SCI_GETSELECTIONSTART</b><br />
     <b>SCI_GETSELECTIONEND</b><br />
     These return the start and end of the selection without regard to which end is the current
    position and which is the anchor. <code>SCI_GETSELECTIONSTART</code> returns the smaller of the
    current position or the anchor position. <code>SCI_GETSELECTIONEND</code> returns the larger of
    the two values.</p>
	<h3 id="SCI_SELECTALL">SCI_SELECTALL</h3>
    <p>文書内のすべてのテキストを選択します。キャレットを表示させるためのスクロールは行われません。</p>
    <p class="eng"><b>SCI_SELECTALL</b><br />
     This selects all the text in the document. The current position is not scrolled into view.</p>
	<h3 id="SCI_LINEFROMPOSITION">SCI_LINEFROMPOSITION(int pos)</h3>
    <p>文書内の位置 <code>pos</code> を含む行の番号を取得します。<code>pos</code> が 0 以下の時は 0 、<code>pos</code> が文書末を越えているときは最終行を戻り値とします。</p>
    <p class="eng"><b>SCI_LINEFROMPOSITION(int pos)</b><br />
     This message returns the line that contains the position <code>pos</code> in the document. The
    return value is 0 if <code>pos</code> &lt;= 0. The return value is the last line if
    <code>pos</code> is beyond the end of the document.</p>
	<h3 id="SCI_POSITIONFROMLINE">SCI_POSITIONFROMLINE(int line)</h3>
    <p>文書内における指定された行の開始位置を返します。<code>line</code> が負数の時は、選択範囲の先頭が含まれる行の開始位置が返されます。<code>line</code> が文書内の行数よりも大きい値の時は戻り値は -1 になります。<code>line</code> と文書内の行数が同じである場合（すなわち最終行の番号より１多い場合）は文書末を意味する値を返します。</p>
    <p class="eng"><b>SCI_POSITIONFROMLINE(int line)</b><br />
     This returns the document position that corresponds with the start of the line. If
    <code>line</code> is negative, the position of the line holding the start of the selection is
    returned. If <code>line</code> is greater than the lines in the document, the return value is
    -1. If <code>line</code> is equal to the number of lines in the document (i.e. 1 line past the
    last line), the return value is the end of the document.</p>
	<h3 id="SCI_GETLINEENDPOSITION">SCI_GETLINEENDPOSITION(int line)</h3>
    <p>行末の位置、具体的には行末文字の直前の位置を返します。<code>line</code> が負数であれば 0 を返します(*)。<code>line</code> が文書の終わりの（ため行末文字がない）場合、文書の大きさが返されます。<code>line</code> が負数であれば -1 を返します(*)。<code>line</code> &gt;=
    <code>SCI_GETLINECOUNT()</code> の状態の時は現在は <code>SCI_GETLENGTH()-1</code> を返します。未定義かも知れません。</p>
	<p>(訳注: (*)で、結局 line が負数だったら結果は -1 なのか 0 なのか。つーか誰がこの原文書いたんだよ。)</p>
    <p class="eng"><b id="SCI_GETLINEENDPOSITION">SCI_GETLINEENDPOSITION(int line)</b><br />
     This returns the position at the end of the line, before any line end characters. If
    <code>line</code> is negative, the result is 0. If <code>line</code> is the last line in the
    document, (which does not have any end of line characters), the result is the size of the
    document. If <code>line</code> is negative, the result is -1. If <code>line</code> is &gt;=
    <code>SCI_GETLINECOUNT()</code>, the result is currently <code>SCI_GETLENGTH()-1</code>...
    (undefined?).</p>
	<h3 id="SCI_LINELENGTH">SCI_LINELENGTH(int line)</h3>
    <p>行末文字まで含めた行の長さを返します。<code>line</code> が負数であったり文書の最終行を越えていたりする場合は 0　を返します。行末文字を含まない行の長さを知る場合は <a class="message"
    href="#SCI_GETLINEENDPOSITION"><code>SCI_GETLINEENDPOSITION(line)</code></a> - <a class="message"
    href="#SCI_POSITIONFROMLINE"><code>SCI_POSITIONFROMLINE(line)</code></a> を求めてください。</p>
    <p class="eng"><b>SCI_LINELENGTH(int line)</b><br />
     This returns the length of the line, including any line end characters. If <code>line</code>
    is negative or beyond the last line in the document, the result is 0. If you want the length of
    the line not including any end of line characters, use <a class="message"
    href="#SCI_GETLINEENDPOSITION"><code>SCI_GETLINEENDPOSITION(line)</code></a> - <a class="message"
    href="#SCI_POSITIONFROMLINE"><code>SCI_POSITIONFROMLINE(line)</code></a>.</p>
	<h3 id="SCI_GETSELTEXT">SCI_GETSELTEXT(&lt;unused&gt;, char *text)</h3>
	<p>現在の選択範囲にある文字列をコピーし、終端に 0 を加えて <code>text</code> バッファに格納します。このバッファは少なくとも <code>SCI_GETSELECTIONEND()-SCI_GETSELECTIONSTART()+1</code> バイトの大きさが無くてはなりません。引数 text が 0 の場合は、格納に最低必要なバッファの大きさを返します。</p>
    <p class="eng"><b>SCI_GETSELTEXT(&lt;unused&gt;, char *text)</b><br />
     This copies the currently selected text and a terminating 0 byte to the <code>text</code>
    buffer. The buffer must be at least
    <code>SCI_GETSELECTIONEND()-SCI_GETSELECTIONSTART()+1</code> bytes long. <br />
    If the text argument is 0 then the length that should be allocated
    to store the entire selection is returned.</p>

    <p class="eng">参照: <code><a class="message" href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a></code></p>
    <p class="eng">See also: <code><a class="message" href="#SCI_GETCURLINE">SCI_GETCURLINE</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a></code></p>
	<h3 id="SCI_GETCURLINE">SCI_GETCURLINE(int textLen, char *text)</h3>
    <p>キャレットがある行のテキストを取得し、その行におけるキャレットの位置を返します。<code>char* text</code> は該当行の内容から取得したい長さと終端の 0 を収めるに充分な大きさが無くてはなりません。<code>textLen</code> はバッファの大きさです。引数 text が 0 の時は該当行全体を収めるために必要な大きさが返されます。</p>
    <p class="eng"><b id="SCI_GETCURLINE">SCI_GETCURLINE(int textLen, char *text)</b><br />
     This retrieves the text of the line containing the caret and returns the position within the
    line of the caret. Pass in <code>char* text</code> pointing at a buffer large enough to hold
    the text you wish to retrieve and a terminating 0 character. Set <code>textLen</code> to the
    length of the buffer. If the text argument is 0 then the length that should be allocated
    to store the entire current line is returned.</p>

    <p class="eng">参照: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a></code></p>
    <p class="eng">See also: <code><a class="message" href="#SCI_GETSELTEXT">SCI_GETSELTEXT</a>, <a
    class="message" href="#SCI_GETLINE">SCI_GETLINE</a>, <a class="message"
    href="#SCI_GETTEXT">SCI_GETTEXT</a>, <a class="message"
    href="#SCI_GETSTYLEDTEXT">SCI_GETSTYLEDTEXT</a>, <a class="message"
    href="#SCI_GETTEXTRANGE">SCI_GETTEXTRANGE</a></code></p>
	<h3 id="SCI_SELECTIONISRECTANGLE">SCI_SELECTIONISRECTANGLE</h3>
    <p>矩形選択モードの時は 1 、そうでなければ 0 を返します。</p>
    <p class="eng"><b>SCI_SELECTIONISRECTANGLE</b><br />
     This returns 1 if the current selection is in rectangle mode, 0 if not.</p>
	<h3 id="SCI_SETSELECTIONMODE">SCI_SETSELECTIONMODE<br />
    <span id="SCI_GETSELECTIONMODE">SCI_GETSELECTIONMODE</span></h3>
    <p>選択モードの設定と取得を行います。ストリーム(<code>SC_SEL_STREAM</code>=1), 矩形(<code>SC_SEL_RECTANGLE</code>=2), 行単位(<code>SC_SEL_LINES</code>=3) が取りうる値です。これら各モードが設定されると、キャレットの移動とともに選択範囲の拡縮が行われます。同じ値か <code>SCI_CANCEL</code> を引数にしてで呼び出されるまでこの効果は続きます。取得関数はすでに選択範囲が生成されている場合でも現在のモードを返します。</p>
    <p class="eng"><b id="SCI_SETSELECTIONMODE">SCI_SETSELECTIONMODE</b><br />
    <b id="SCI_GETSELECTIONMODE">SCI_GETSELECTIONMODE</b><br />
    The two functions set and get the selection mode, which can be
     stream (<code>SC_SEL_STREAM</code>=1) or
     rectangular (<code>SC_SEL_RECTANGLE</code>=2)
     or by lines (<code>SC_SEL_LINES</code>=3).
     When set in these modes, regular caret moves will extend or reduce the selection,
     until the mode is cancelled by a call with same value or with <code>SCI_CANCEL</code>.
     The get function returns the current mode even if the selection was made by mouse
     or with regular extended moves.</p>
	<h3 id="SCI_GETLINESELSTARTPOSITION">SCI_GETLINESELSTARTPOSITION(int line)<br />
    <span id="SCI_GETLINESELENDPOSITION">SCI_GETLINESELENDPOSITION(int line)</span></h3>
    <p>指定された行における選択範囲の開始点や終了点を返します。当該行に選択範囲がない場合は INVALID_POSITION が返されます。</p>
    <p class="eng"><b id="SCI_GETLINESELSTARTPOSITION">SCI_GETLINESELSTARTPOSITION(int line)</b><br />
    <b id="SCI_GETLINESELENDPOSITION">SCI_GETLINESELENDPOSITION(int line)</b><br />
    Retrieve the position of the start and end of the selection at the given line with
    INVALID_POSITION returned if no selection on this line.</p>
	<h3 id="SCI_MOVECARETINSIDEVIEW">SCI_MOVECARETINSIDEVIEW</h3>
    <p>可視範囲の上下からキャレットがはみ出して見えないとき、可視範囲の一番近い行へキャレットを移動します。選択範囲はキャンセルされます。</p>
    <p class="eng"><b>SCI_MOVECARETINSIDEVIEW</b><br />
     If the caret is off the top or bottom of the view, it is moved to the nearest line that is
    visible to its current position. Any selection is lost.</p>
	<h3 id="SCI_WORDENDPOSITION">SCI_WORDENDPOSITION(int position, bool
    onlyWordCharacters)<br />
     <span id="SCI_WORDSTARTPOSITION">SCI_WORDSTARTPOSITION(int position, bool
    onlyWordCharacters)</span></h3>
    <p>Scintilla が内部で使う単語定義と同様のものを用いて単語の開始点や終了点を求めます。どの文字を単語の一部として扱うかについて独自の情報を <a class="message" href="#SCI_SETWORDCHARS"><code>SCI_SETWORDCHARS</code></a> で与えることができます。position 引数には検索の開始点を指定します。その位置から、単語の開始点を探すときは後方に、終了点を探すときには前方に検索します。</p>
    <p class="eng"><b>SCI_WORDENDPOSITION(int position, bool
    onlyWordCharacters)</b><br />
     <b>SCI_WORDSTARTPOSITION(int position, bool
    onlyWordCharacters)</b><br />
     These messages return the start and end of words using the same definition of words as used
    internally within Scintilla. You can set your own list of characters that count as words with
    <a class="message" href="#SCI_SETWORDCHARS"><code>SCI_SETWORDCHARS</code></a>. The position
    sets the start or the search, which is forwards when searching for the end and backwards when
    searching for the start.</p>

    <p><code>onlyWordCharacters</code> に <code>true</code> (1) を与えると、検索方向に向かって単語を構成しない文字で止まります。<code>onlyWordCharacters</code> が <code>false</code> (0) の時は、まず検索方向の最初の文字の種類（単語を校正する文字か否か）を判別し、同じ方向へ同じ種類の文字が続く位置を検索します。検索は文書の先頭か末尾に達した場合も終了します。</p>
    <p class="eng">Set <code>onlyWordCharacters</code> to <code>true</code> (1) to stop searching at the first
    non-word character in the search direction. If <code>onlyWordCharacters</code> is
    <code>false</code> (0), the first character in the search direction sets the type of the search
    as word or non-word and the search stops at the first non-matching character. Searches are also
    terminated by the start or end of the document.</p>

    <p>"w" が単語構成文字で "," がそうでない場合、"|" で位置を表して、<code>true</code> や <code>false</code> は <code>onlyWordCharacters</code> への指定値だとすると次の表のような結果になります。</p>    <table cellpadding="3" cellspacing="0" border="1" summary="単語の開始点・終了点">
      <thead align="center">
        <tr>
          <th>初期状態</th>

          <th>〜END〜, true</th>

          <th>〜END〜, false</th>

          <th>〜START〜, true</th>

          <th>〜START〜, false</th>
        </tr>
      </thead>

      <tbody align="center">
        <tr>
          <td>..ww..|..ww..</td>

          <td>..ww..|..ww..</td>

          <td>..ww....|ww..</td>

          <td>..ww..|..ww..</td>

          <td>..ww|....ww..</td>
        </tr>

        <tr>
          <td>....ww|ww....</td>

          <td>....wwww|....</td>

          <td>....wwww|....</td>

          <td>....|wwww....</td>

          <td>....|wwww....</td>
        </tr>

        <tr>
          <td>..ww|....ww..</td>

          <td>..ww|....ww..</td>

          <td>..ww....|ww..</td>

          <td>..|ww....ww..</td>

          <td>..|ww....ww..</td>
        </tr>

        <tr>
          <td>..ww....|ww..</td>

          <td>..ww....ww|..</td>

          <td>..ww....ww|..</td>

          <td>..ww....|ww..</td>

          <td>..ww|....ww..</td>
        </tr>
      </tbody>
    </table>


    <p class="eng">If "w" represents word characters and "." represents non-word characters and "|" represents
    the position and <code>true</code> or <code>false</code> is the state of
    <code>onlyWordCharacters</code>:</p>


    <table class="eng" cellpadding="3" cellspacing="0" border="1" summary="Word start and end positions">
      <thead align="center">
        <tr>
          <th>Initial state</th>

          <th>end, true</th>

          <th>end, false</th>

          <th>start, true</th>

          <th>start, false</th>
        </tr>
      </thead>

      <tbody align="center">
        <tr>
          <td>..ww..|..ww..</td>

          <td>..ww..|..ww..</td>

          <td>..ww....|ww..</td>

          <td>..ww..|..ww..</td>

          <td>..ww|....ww..</td>
        </tr>

        <tr>
          <td>....ww|ww....</td>

          <td>....wwww|....</td>

          <td>....wwww|....</td>

          <td>....|wwww....</td>

          <td>....|wwww....</td>
        </tr>

        <tr>
          <td>..ww|....ww..</td>

          <td>..ww|....ww..</td>

          <td>..ww....|ww..</td>

          <td>..|ww....ww..</td>

          <td>..|ww....ww..</td>
        </tr>

        <tr>
          <td>..ww....|ww..</td>

          <td>..ww....ww|..</td>

          <td>..ww....ww|..</td>

          <td>..ww....|ww..</td>

          <td>..ww|....ww..</td>
        </tr>
      </tbody>
    </table>

	<h3 id="SCI_POSITIONBEFORE">SCI_POSITIONBEFORE(int position)<br />
     <span id="SCI_POSITIONAFTER">SCI_POSITIONAFTER(int position)</span></h3>
	<p>文書内の指定位置の直前や直後の位置を返します。現在のコードページを意識します。最小の位置は 0 で最大の位置は文書の末尾です。マルチバイト文字の中の位置を指定した場合、その文字の開始位置・終了位置を返します。</p>
    <p class="eng"><b>SCI_POSITIONBEFORE(int position)</b><br />
     <b>SCI_POSITIONAFTER(int position)</b><br />
     These messages return the position before and after another position
     in the document taking into account the current code page. The minimum
     position returned is 0 and the maximum is the last position in the document.
     If called with a position within a multi byte character will return the position
     of the start/end of that character.</p>
	<h3 id="SCI_TEXTWIDTH">SCI_TEXTWIDTH(int styleNumber, const char *text)</h3>
    <p><code>styleNumber</code> のスタイルで指定した文字列を描画するのに必要なピクセル幅を返します。例えば行番号をを表示する余白幅を決めるためなどに利用することができます。</p>
    <p class="eng"><b>SCI_TEXTWIDTH(int styleNumber, const char *text)</b><br />
     This returns the pixel width of a string drawn in the given <code>styleNumber</code> which can
    be used, for example, to decide how wide to make the line number margin in order to display a
    given number of numerals.</p>
	<h3 id="SCI_TEXTHEIGHT">SCI_TEXTHEIGHT(int line)</h3>
    <p>指定行のピクセル単位の高さを返します。現時点では全ての行が同じ高さを持っています。</p>
    <p class="eng"><b>SCI_TEXTHEIGHT(int line)</b><br />
     This returns the height in pixels of a particular line. Currently all lines are the same
    height.</p>
	<h3 id="SCI_GETCOLUMN">SCI_GETCOLUMN(int pos)</h3>
    <p>文書内の位置 <code>pos</code> の桁番号を返します。タブ幅も計算上考慮されます。<code>pos</code> より前でその行の最後のタブの桁番号に、そこから <code>pos</code> の直前までの文字数を加えた値を返します。その行にタブ文字がないときは、戻り値は最大でその行の文字数です。ダブルバイト文字は一つの文字として数えられます。おそらくは固定幅フォントでのみ有効に利用できるものです。</p>
    <p class="eng"><b>SCI_GETCOLUMN(int pos)</b><br />
     This message returns the column number of a position <code>pos</code> within the document
    taking the width of tabs into account. This returns the column number of the last tab on the
    line before <code>pos</code>, plus the number of characters between the last tab and
    <code>pos</code>. If there are no tab characters on the line, the return value is the number of
    characters up to the position on the line. In both cases, double byte characters count as a
    single character. This is probably only useful with monospaced fonts.</p>
	<h3 id="SCI_FINDCOLUMN">SCI_FINDCOLUMN(int line, int column)</h3>
    <p><code>line</code> 行の <code>column</code> 文字目の位置を、タブ幅を考慮した上で返します。マルチバイト文字は一つの桁として数えられます。桁番号は行番号同様に 0 から始まります。</p>
    <p class="eng"><b>SCI_FINDCOLUMN(int line, int column)</b><br />
     This message returns the position of a <code>column</code> on a <code>line</code>
    taking the width of tabs into account. It treats a multi-byte character as a single column.
    Column numbers, like lines start at 0.</p>
	<h3 id="SCI_POSITIONFROMPOINT">SCI_POSITIONFROMPOINT(int x, int y)<br />
     <span id="SCI_POSITIONFROMPOINTCLOSE">SCI_POSITIONFROMPOINTCLOSE(int x, int y)</span></h3>
    <p><code>SCI_POSITIONFROMPOINT</code> は指定座標から一番近い文字の位置を返します。<code>SCI_POSITIONFROMPOINTCLOSE</code> も同様の動作をしますが、ウィンドウの外を指定されたり近くに文字がない場合には -1 を返す点が異なります。</p>
    <p class="eng"><b>SCI_POSITIONFROMPOINT(int x, int y)</b><br />
     <b>SCI_POSITIONFROMPOINTCLOSE(int x, int y)</b><br />
     <code>SCI_POSITIONFROMPOINT</code> finds the closest character position to a point and
    <code>SCI_POSITIONFROMPOINTCLOSE</code> is similar but returns -1 if the point is outside the
    window or not close to any characters.</p>
	<h3 id="SCI_POINTXFROMPOSITION">SCI_POINTXFROMPOSITION(&lt;unused&gt;, int pos)<br />
     <span id="SCI_POINTYFROMPOSITION">SCI_POINTYFROMPOSITION(&lt;unused&gt;, int pos)</span></h3>
    <p>文書内における位置 <code>pos</code> の文字のピクセル座標を返します。</p>
    <p class="eng"><b id="SCI_POINTXFROMPOSITION">SCI_POINTXFROMPOSITION(&lt;unused&gt;, int pos)</b><br />
     <b id="SCI_POINTYFROMPOSITION">SCI_POINTYFROMPOSITION(&lt;unused&gt;, int pos)</b><br />
     These messages return the x and y display pixel location of text at position <code>pos</code>
    in the document.</p>
	<h3 id="SCI_HIDESELECTION">SCI_HIDESELECTION(bool hide)</h3>
    <p>選択範囲がわかるように描画する通常の状態は <a class="message"
    href="#SCI_SETSELFORE"><code>SCI_SETSELFORE</code></a> と <a class="message"
    href="#SCI_SETSELBACK"><code>SCI_SETSELBACK</code></a> によって設定しますが、このメッセージによって選択範囲を「隠す」ようにすると、選択範囲も通常のテキストとして描画されます。</p>
    <p class="eng"><b>SCI_HIDESELECTION(bool hide)</b><br />
     The normal state is to make the selection visible by drawing it as set by <a class="message"
    href="#SCI_SETSELFORE"><code>SCI_SETSELFORE</code></a> and <a class="message"
    href="#SCI_SETSELBACK"><code>SCI_SETSELBACK</code></a>. However, if you hide the selection, it
    is drawn as normal text.</p>
	<h3 id="SCI_CHOOSECARETX">SCI_CHOOSECARETX</h3>
    <p>垂直移動の際、Scintilla はユーザが明示的に移動した最後の横座標( x ) を記憶しており、この値は矢印キーの上下などで移動するときに用いられます。このメッセージはキャレットの位置でその記憶する横座標を設定するものです。</p>
    <p class="eng"><b id="SCI_CHOOSECARETX">SCI_CHOOSECARETX</b><br />
     Scintilla remembers the x value of the last position horizontally moved to explicitly by the
    user and this value is then used when moving vertically such as by using the up and down keys.
    This message sets the current x position of the caret as the remembered value.</p>

    <h2 id="ScrollingAndAutomaticScrolling"><span>スクロールと自動スクロール</span><span class="eng">Scrolling and automatic scrolling</span></h2>
    <code><a class="message" href="#SCI_LINESCROLL">SCI_LINESCROLL(int column, int line)</a><br />
     <a class="message" href="#SCI_SCROLLCARET">SCI_SCROLLCARET</a><br />
     <a class="message" href="#SCI_SETXCARETPOLICY">SCI_SETXCARETPOLICY(int caretPolicy, int
    caretSlop)</a><br />
     <a class="message" href="#SCI_SETYCARETPOLICY">SCI_SETYCARETPOLICY(int caretPolicy, int
    caretSlop)</a><br />
     <a class="message" href="#SCI_SETVISIBLEPOLICY">SCI_SETVISIBLEPOLICY(int caretPolicy, int
    caretSlop)</a><br />
     <a class="message" href="#SCI_SETHSCROLLBAR">SCI_SETHSCROLLBAR(bool visible)</a><br />
     <a class="message" href="#SCI_GETHSCROLLBAR">SCI_GETHSCROLLBAR</a><br />
     <a class="message" href="#SCI_SETVSCROLLBAR">SCI_SETVSCROLLBAR(bool visible)</a><br />
     <a class="message" href="#SCI_GETVSCROLLBAR">SCI_GETVSCROLLBAR</a><br />
     <a class="message" href="#SCI_GETXOFFSET">SCI_GETXOFFSET</a><br />
     <a class="message" href="#SCI_SETXOFFSET">SCI_SETXOFFSET(int xOffset)</a><br />
     <a class="message" href="#SCI_SETSCROLLWIDTH">SCI_SETSCROLLWIDTH(int pixelWidth)</a><br />
     <a class="message" href="#SCI_GETSCROLLWIDTH">SCI_GETSCROLLWIDTH</a><br />
     <a class="message" href="#SCI_SETENDATLASTLINE">SCI_SETENDATLASTLINE(bool
    endAtLastLine)</a><br />
     <a class="message" href="#SCI_GETENDATLASTLINE">SCI_GETENDATLASTLINE</a><br />
    </code>
	<h3 id="SCI_LINESCROLL">SCI_LINESCROLL(int column, int line)</h3>
    <p>指定した桁数分と行数分の画面スクロールを試みます。正の行数は最上部の行番号を増やすようにスクロールします。つまりユーザから見てテキストが上に動くように見えます。負の行数は逆方向にこれを行います。</p>
    <p class="eng"><b id="SCI_LINESCROLL">SCI_LINESCROLL(int column, int line)</b><br />
     This will attempt to scroll the display by the number of columns and lines that you specify.
    Positive line values increase the line number at the top of the screen (i.e. they move the text
    upwards as far as the user is concerned), Negative line values do the reverse.</p>

    <p>桁数の単位は標準スタイルの空白の幅です。正の値は可視部の左端の桁位置を増加します。したがってテキストが左に動くように見えます。負の値は逆方向にこれを行います。</p>
    <p class="eng">The column measure is the width of a space in the default style. Positive values increase
    the column at the left edge of the view (i.e. they move the text leftwards as far as the user
    is concerned). Negative values do the reverse.</p>

    <p>参照: <a class="message" href="#SCI_SETXOFFSET"><code>SCI_SETXOFFSET</code></a></p>
    <p class="eng">See also: <a class="message" href="#SCI_SETXOFFSET"><code>SCI_SETXOFFSET</code></a></p>
	<h3 id="SCI_SCROLLCARET">SCI_SCROLLCARET</h3>
    <p>現在位置(選択範囲がなければキャレット位置)が見えない状態の時はスクロールによって見えるようにします。これは現在のキャレットポリシーに従う動作を行います。</p>
    <p class="eng"><b>SCI_SCROLLCARET</b><br />
     If the current position (this is the caret if there is no selection) is not visible, the view
    is scrolled to make it visible according to the current caret policy.</p>
	<h3 id="SCI_SETXCARETPOLICY">SCI_SETXCARETPOLICY(int caretPolicy, int caretSlop)<br />
     <span id="SCI_SETYCARETPOLICY">SCI_SETYCARETPOLICY(int caretPolicy, int caretSlop)</span></h3>
    <p>キャレットポリシーを設定します。<code>caretPolicy</code> は <code>CARET_SLOP</code>, <code>CARET_STRICT</code>, <code>CARET_JUMPS</code>,
    <code>CARET_EVEN</code> の組み合わせで指定します。</p>
    <p class="eng"><b>SCI_SETXCARETPOLICY(int caretPolicy, int caretSlop)</b><br />
     <b>SCI_SETYCARETPOLICY(int caretPolicy, int caretSlop)</b><br />
     These set the caret policy. The value of <code>caretPolicy</code> is a combination of
    <code>CARET_SLOP</code>, <code>CARET_STRICT</code>, <code>CARET_JUMPS</code> and
    <code>CARET_EVEN</code>.</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="キャレットポリシー">
      <tbody valign="top">
        <tr>
          <th align="left"><code>CARET_SLOP</code></th>

          <td>指定されると溢れ値 <code>caretSlop</code> を定義できます。この値は可視部のうちキャレットを置いて欲しくない区間を定義するもので、垂直余白からはピクセル単位、水平余白からは行数でで指定します。これらの端にキャレットを近づけないことにより、常にキャレットを中に表示することができます。これにより、キャレットが置かれているところにある識別子を尻切れトンボに表示させずに済ませたり、キャレットがある行と関係するであろう直後の数行を現在行とともに見ることができます。</td>
        </tr>

        <tr>
          <th align="left"><code>CARET_STRICT</code></th>

          <td>指定されると <code>CARET_SLOP</code> の効果を厳格に実行します。<code>caretSlop</code> が未設定の時はキャレットが常に中央にあります。<code>caretSlop</code> が設定済みであればキャレットは指定の区間に決してはいることができなくなります。</td>
        </tr>

        <tr>
          <th align="left"><code>CARET_JUMPS</code></th>

          <td>指定されると表示範囲が大胆に移動するようになり、キャレットポリシーを再適用せずに同一方向へ移動できる量が多くなります。'3UZ' は指定値の三倍の距離を意味します。</td>
        </tr>

        <tr>
          <th align="left"><code>CARET_EVEN</code></th>

          <td>指定されていなければ、対称的に指定区間があるものと考える代わりに左側と下側のキャレット拒絶区間が右側と上側の拒絶区間まで引き延ばされます。こうすると大部分のコードがある行頭を表示しやすくなり、またキャレットの下にある関数本体等も見やすくなります。</td>
        </tr>
      </tbody>
    </table>

    <table cellpadding="3" cellspacing="0" border="1" summary="Caret positioning">
      <thead align="center">
        <tr>
          <th>slop</th>

          <th>strict</th>

          <th>jumps</th>

          <th>even</th>

          <th>キャレットが余白に移動できるか</th>

          <th>可視部か拒絶区間の外にキャレットが出た場合</th>
        </tr>
      </thead>

      <tbody align="center">
        <tr>
          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>○</td>

          <td>上端・右端に置かれるようにスクロール</td>
        </tr>

        <tr>
          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>○</td>

          <td>一単位移動</td>
        </tr>

        <tr>
          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>0</td>

          <td>○</td>

          <td>上端・右端に置かれるようにスクロール</td>
        </tr>

        <tr>
          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>1</td>

          <td>○</td>

          <td>キャレットは可視部の中央へ</td>
        </tr>

        <tr>
          <td>0</td>

          <td>1</td>

          <td>-</td>

          <td>0</td>

          <td>キャレットは常に上端・右端</td>

          <td>-</td>
        </tr>

        <tr>
          <td>0</td>

          <td>1</td>

          <td>-</td>

          <td>1</td>

          <td>キャレットは常に中央</td>

          <td>-</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>○</td>

          <td>非対称の指定区間の外へ</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>○</td>

          <td>指定区間の外へ</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>1</td>

          <td>0</td>

          <td>○</td>

          <td>上端・右端から指定値の三倍離してキャレットを置く</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>1</td>

          <td>1</td>

          <td>○</td>

          <td>端から指定値の三倍離してキャレットを置く</td>
        </tr>

        <tr>
          <td>1</td>

          <td>1</td>

          <td>-</td>

          <td>0</td>

          <td>常に上・右の指定区間に接する</td>

          <td>-</td>
        </tr>

        <tr>
          <td>1</td>

          <td>1</td>

          <td>0</td>

          <td>1</td>

          <td>× - 指定区間の外側へ</td>

          <td>一単位移動</td>
        </tr>

        <tr>
          <td>1</td>

          <td>1</td>

          <td>1</td>

          <td>0</td>

          <td>× - 指定区間の外側へ</td>

          <td>端から指定値の三倍離してキャレットを置く</td>
        </tr>
      </tbody>
    </table>

    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Caret policy">
      <tbody valign="top">
        <tr>
          <th align="left"><code>CARET_SLOP</code></th>

          <td>If set, we can define a slop value: <code>caretSlop</code>. This value defines an
          unwanted zone (UZ) where the caret is... unwanted. This zone is defined as a number of
          pixels near the vertical margins, and as a number of lines near the horizontal margins.
          By keeping the caret away from the edges, it is seen within its context. This makes it
          likely that the identifier that the caret is on can be completely seen, and that the
          current line is seen with some of the lines following it, which are often dependent on
          that line.</td>
        </tr>

        <tr>
          <th align="left"><code>CARET_STRICT</code></th>

          <td>If set, the policy set by <code>CARET_SLOP</code> is enforced... strictly. The caret
          is centred on the display if <code>caretSlop</code> is not set, and cannot go in the UZ
          if <code>caretSlop</code> is set.</td>
        </tr>

        <tr>
          <th align="left"><code>CARET_JUMPS</code></th>

          <td>If set, the display is moved more energetically so the caret can move in the same
          direction longer before the policy is applied again. '3UZ' notation is used to indicate
          three time the size of the UZ as a distance to the margin.</td>
        </tr>

        <tr>
          <th align="left"><code>CARET_EVEN</code></th>

          <td>If not set, instead of having symmetrical UZs, the left and bottom UZs are extended
          up to right and top UZs respectively. This way, we favour the displaying of useful
          information: the beginning of lines, where most code reside, and the lines after the
          caret, for example, the body of a function.</td>
        </tr>
      </tbody>
    </table>

    <table class="eng" cellpadding="3" cellspacing="0" border="1" summary="Caret positioning">
      <thead align="center">
        <tr>
          <th>slop</th>

          <th>strict</th>

          <th>jumps</th>

          <th>even</th>

          <th>Caret can go to the margin</th>

          <th>On reaching limit (going out of visibility<br />
           or going into the UZ) display is...</th>
        </tr>
      </thead>

      <tbody align="center">
        <tr>
          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>Yes</td>

          <td>moved to put caret on top/on right</td>
        </tr>

        <tr>
          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>Yes</td>

          <td>moved by one position</td>
        </tr>

        <tr>
          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>0</td>

          <td>Yes</td>

          <td>moved to put caret on top/on right</td>
        </tr>

        <tr>
          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>1</td>

          <td>Yes</td>

          <td>centred on the caret</td>
        </tr>

        <tr>
          <td>0</td>

          <td>1</td>

          <td>-</td>

          <td>0</td>

          <td>Caret is always on top/on right of display</td>

          <td>-</td>
        </tr>

        <tr>
          <td>0</td>

          <td>1</td>

          <td>-</td>

          <td>1</td>

          <td>No, caret is always centred</td>

          <td>-</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>0</td>

          <td>0</td>

          <td>Yes</td>

          <td>moved to put caret out of the asymmetrical UZ</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>0</td>

          <td>1</td>

          <td>Yes</td>

          <td>moved to put caret out of the UZ</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>1</td>

          <td>0</td>

          <td>Yes</td>

          <td>moved to put caret at 3UZ of the top or right margin</td>
        </tr>

        <tr>
          <td>1</td>

          <td>0</td>

          <td>1</td>

          <td>1</td>

          <td>Yes</td>

          <td>moved to put caret at 3UZ of the margin</td>
        </tr>

        <tr>
          <td>1</td>

          <td>1</td>

          <td>-</td>

          <td>0</td>

          <td>Caret is always at UZ of top/right margin</td>

          <td>-</td>
        </tr>

        <tr>
          <td>1</td>

          <td>1</td>

          <td>0</td>

          <td>1</td>

          <td>No, kept out of UZ</td>

          <td>moved by one position</td>
        </tr>

        <tr>
          <td>1</td>

          <td>1</td>

          <td>1</td>

          <td>0</td>

          <td>No, kept out of UZ</td>

          <td>moved to put caret at 3UZ of the margin</td>
        </tr>
      </tbody>
    </table>
	<h3 id="SCI_SETVISIBLEPOLICY">SCI_SETVISIBLEPOLICY(int caretPolicy, int caretSlop)</h3>
    <p><a class="message"
    href="#SCI_ENSUREVISIBLEENFORCEPOLICY"><code>SCI_ENSUREVISIBLEENFORCEPOLICY</code></a> が呼び出されたときに垂直位置をどのように定めるかを指定します。<code>VISIBLE_SLOP</code> および <code>VISIBLE_STRICT</code> フラグがポリシー引数となります。<a class="message"
    href="#SCI_SETYCARETPOLICY"><code>SCI_SETYCARETPOLICY(int caretPolicy, int
    caretSlop)</code></a> と同様の処理を行います。</p>
    <p class="eng"><b>SCI_SETVISIBLEPOLICY(int caretPolicy, int caretSlop)</b><br />
     This determines how the vertical positioning is determined when <a class="message"
    href="#SCI_ENSUREVISIBLEENFORCEPOLICY"><code>SCI_ENSUREVISIBLEENFORCEPOLICY</code></a> is
    called. It takes <code>VISIBLE_SLOP</code> and <code>VISIBLE_STRICT</code> flags for the policy
    parameter. It is similar in operation to <a class="message"
    href="#SCI_SETYCARETPOLICY"><code>SCI_SETYCARETPOLICY(int caretPolicy, int
    caretSlop)</code></a>.</p>
	<h3 id="SCI_SETHSCROLLBAR">SCI_SETHSCROLLBAR(bool visible)<br />
     <span id="SCI_GETHSCROLLBAR">SCI_GETHSCROLLBAR</span></h3>
    <p>水平スクロールバーは計算した幅に必要な場合のみ表示されます。<code>SCI_SETHSCROLLBAR(0)</code> というコードで水平スクロールバーは全く表示されなくなります。<code>SCI_SETHSCROLLBAR(1)</code> で再び表示されるようになります。<br /><code>SCI_GETHSCROLLBAR</code> は現在の状態を返します。標準状態では水平スクロールバーが表示されるようになっています。<br />
	参照: <a class="message" href="#SCI_SETSCROLLWIDTH">SCI_SETSCROLLWIDTH</a></p>
    <p class="eng"><b id="SCI_SETHSCROLLBAR">SCI_SETHSCROLLBAR(bool visible)</b><br />
     <b id="SCI_GETHSCROLLBAR">SCI_GETHSCROLLBAR</b><br />
     The horizontal scroll bar is only displayed if it is needed for the assumed width.
     If you never wish to see it, call
    <code>SCI_SETHSCROLLBAR(0)</code>. Use <code>SCI_SETHSCROLLBAR(1)</code> to enable it again.
    <code>SCI_GETHSCROLLBAR</code> returns the current state. The default state is to display it
    when needed.
    See also: <a class="message" href="#SCI_SETSCROLLWIDTH">SCI_SETSCROLLWIDTH</a>.</p>
	<h3 id="SCI_SETVSCROLLBAR">SCI_SETVSCROLLBAR(bool visible)<br />
     <span id="SCI_GETVSCROLLBAR">SCI_GETVSCROLLBAR</span></h3>
    <p>標準状態手は、垂直スクロールバーは必要に応じて常に表示されます。<code>SCI_SETVSCROLLBAR</code> でこれを隠すかどうかを指定することができ、<code>SCI_GETVSCROLLBAR</code> で現在の状態を取得することができます。</p>
    <p class="eng"><b>SCI_SETVSCROLLBAR(bool visible)</b><br />
     <b>SCI_GETVSCROLLBAR</b><br />
     By default, the vertical scroll bar is always displayed when required. You can choose to hide
    or show it with <code>SCI_SETVSCROLLBAR</code> and get the current state with
    <code>SCI_GETVSCROLLBAR</code>.</p>
	<h3 id="SCI_SETXOFFSET">SCI_SETXOFFSET(int xOffset)<br />
     <span id="SCI_GETXOFFSET">SCI_GETXOFFSET</span></h3>
    <p><code>xOffset</code> はピクセル単位で、テキストビュー開始点からの水平スクロール位置を指定します。。0 が最初の桁が左端に見えるような通常の位置です。</p>
    <p class="eng"><b>SCI_SETXOFFSET(int xOffset)</b><br />
     <b>SCI_GETXOFFSET</b><br />
     The <code>xOffset</code> is the horizontal scroll position in pixels of the start of the text
    view. A value of 0 is the normal position with the first text column visible at the left of the
    view.</p>

    <p>参照: <a class="message" href="#SCI_LINESCROLL"><code>SCI_LINESCROLL</code></a></p>
    <p class="eng">See also: <a class="message" href="#SCI_LINESCROLL"><code>SCI_LINESCROLL</code></a></p>

	<h3 id="SCI_SETSCROLLWIDTH">SCI_SETSCROLLWIDTH(int pixelWidth)<br />
     <span id="SCI_GETSCROLLWIDTH">SCI_GETSCROLLWIDTH</span></h3>
    <p>実行速度の面から、Scintilla は水平スクロールバーの特性を決める目的では文書の表示幅を計算しません。その代わり、想定幅を用います。これらのメッセージは、Scintilla が仮定する文書幅をピクセル単位で設定あるいは取得します。標準値は 2000 です。</p>
    <p class="eng"><b>SCI_SETSCROLLWIDTH(int pixelWidth)</b><br />
     <b>SCI_GETSCROLLWIDTH</b><br />
     For performance, Scintilla does not measure the display width of the document to determine
     the properties of the horizontal scroll bar. Instead, an assumed width is used.
     These messages set and get the document width in pixels assumed by Scintilla.
     The default value is 2000.</p>
	<h3 id="SCI_SETENDATLASTLINE">SCI_SETENDATLASTLINE(bool endAtLastLine)<br />
     <span id="SCI_GETENDATLASTLINE">SCI_GETENDATLASTLINE</span></h3>
    <p><code>SCI_SETENDATLASTLINE</code> でスクロール幅を設定します。標準では、最大のスクロール位置で最終行が可視範囲の一番下に現れます。<code>endAtLastLine</code> に <code>false</code> を指定すると最終行からさらに一頁下にスクロールします。</p>
    <p class="eng"><b>SCI_SETENDATLASTLINE(bool endAtLastLine)</b><br />
     <b>SCI_GETENDATLASTLINE</b><br />
     <code>SCI_SETENDATLASTLINE</code> sets the scroll range so that maximum scroll position has
    the last line at the bottom of the view (default). Setting this to <code>false</code> allows
    scrolling one page below the last line.</p>

    <h2 id="WhiteSpace"><span>ホワイトスペース</span><span class="eng">White space</span></h2>
    <code><a class="message" href="#SCI_SETVIEWWS">SCI_SETVIEWWS(int wsMode)</a><br />
     <a class="message" href="#SCI_GETVIEWWS">SCI_GETVIEWWS</a><br />
     <a class="message" href="#SCI_SETWHITESPACEFORE">SCI_SETWHITESPACEFORE(bool
    useWhitespaceForeColour, int colour)</a><br />
     <a class="message" href="#SCI_SETWHITESPACEBACK">SCI_SETWHITESPACEBACK(bool
    useWhitespaceBackColour, int colour)</a><br />
    </code>
	<h3 id="SCI_SETVIEWWS">SCI_SETVIEWWS(int wsMode)<br />
     <span id="SCI_GETVIEWWS">SCI_GETVIEWWS</span></h3>
    <p>ホワイトスペースは目に見えるようにすることができます。Python のようにホワイトスペースが意味を持つような言語では便利です。空白文字はその中央に小さな点で、タブ文字は右向きの矢印で表示されます。<a
    class="jump" href="#LineEndings">行末文字</a>を表示する方法も提供されています。ここでのメッセージはこのホワイトスペースの表示モードを設定あるいは取得するものです。引数 <code>wsMode</code> は次のいずれか一つを取ります。</p>
    <p class="eng"><b>SCI_SETVIEWWS(int wsMode)</b><br />
     <b>SCI_GETVIEWWS</b><br />
     White space can be made visible which may useful for languages in which white space is
    significant, such as Python. Space characters appear as small centred dots and tab characters
    as light arrows pointing to the right. There are also ways to control the display of <a
    class="jump" href="#LineEndings">end of line characters</a>. The two messages set and get the
    white space display mode. The <code>wsMode</code> argument can be one of:</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="ホワイトスペースポリシー">
      <tbody valign="top">
        <tr>
          <th align="left"><code>SCWS_INVISIBLE</code></th>

          <td>0</td>

          <td>通常の表示を行います。ホワイトスペースは全体を背景色で表示します。
          colour.</td>
        </tr>

        <tr>
          <th align="left"><code>SCWS_VISIBLEALWAYS</code></th>

          <td>1</td>

          <td>ホワイトスペース文字が点と矢印で表示されます。</td>
        </tr>

        <tr>
          <th align="left"><code>SCWS_VISIBLEAFTERINDENT</code></th>

          <td>2</td>

          <td>字下げに使われているホワイトスペースは背景色のままですが、同じ行で可視文字の後にあるホワイトスペースは点と矢印で表示されます。</td>
        </tr>
      </tbody>
    </table>
    <p><code>wsMode</code> に他の値を与えたときの動作は定義されていません。</p>

    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="White space policy">
      <tbody valign="top">
        <tr>
          <th align="left"><code>SCWS_INVISIBLE</code></th>

          <td>0</td>

          <td>The normal display mode with white space displayed as an empty background
          colour.</td>
        </tr>

        <tr>
          <th align="left"><code>SCWS_VISIBLEALWAYS</code></th>

          <td>1</td>

          <td>White space characters are drawn as dots and arrows,</td>
        </tr>

        <tr>
          <th align="left"><code>SCWS_VISIBLEAFTERINDENT</code></th>

          <td>2</td>

          <td>White space used for indentation is displayed normally but after the first visible
          character, it is shown as dots and arrows.</td>
        </tr>
      </tbody>
    </table>

    <p class="eng">The effect of using any other <code>wsMode</code> value is undefined.</p>
	<h3 id="SCI_SETWHITESPACEFORE">SCI_SETWHITESPACEFORE&lt;(bool useWhitespaceForeColour, int <a
    class="jump" href="#colour">colour</a>)<br />
     <span id="SCI_SETWHITESPACEBACK">SCI_SETWHITESPACEBACK(bool useWhitespaceBackColour, int <a
    class="jump" href="#colour">colour</a>)</span></h3>
    <p>標準状態では、見えるようにされたホワイトスペースは使用中の解析器に定義されます。文字色と背景色は一方または両方を共有特性として定義でき、<code>SCI_SETWHITESPACEFORE</code> と
    <code>SCI_SETWHITESPACEBACK</code>による解析器の指定で上書きすることになります。</p>
    <p class="eng"><b>SCI_SETWHITESPACEFORE&lt;(bool useWhitespaceForeColour, int <a
    class="jump" href="#colour">colour</a>)</b><br />
     <b>SCI_SETWHITESPACEBACK(bool useWhitespaceBackColour, int <a
    class="jump" href="#colour">colour</a>)</b><br />
     By default, the colour of visible white space is determined by the lexer in use. The
    foreground and/or background colour of all visible white space can be set globally, overriding
    the lexer's colours with <code>SCI_SETWHITESPACEFORE</code> and
    <code>SCI_SETWHITESPACEBACK</code>.</p>

    <h2 id="Cursor"><span>マウスカーソル</span><span class="eng">Cursor</span></h2>
	<h3 id="SCI_SETCURSOR">SCI_SETCURSOR(int curType)</h3>
    <p>マウスカーソルはその位置の内容に応じて変化します。テキスト上にあるときと余白にあるときは異なることがあります。遅いカーソルを実現したい場合はカーソルの待ち手法を変更することができます。手法は <code>SCI_SETCURSOR</code> で指定します。引数 <code>curType</code> は次のいずれかです。</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="マウスカーソル">
      <tbody valign="top">
        <tr>
          <th align="left"><code>SC_CURSORNORMAL</code></th>

          <td>-1</td>

          <td>通常のカーソル表示を行います。</td>
        </tr>

        <tr>
          <th align="left"><code>SC_CURSORWAIT</code></th>

          <td>&nbsp;4</td>

          <td>Scintilla かそれが所有するウィンドウ上にカーソルが来たときに待ちカーソルを表示します。</td>
        </tr>
      </tbody>
    </table>

    <p class="eng"><b>SCI_SETCURSOR(int curType)</b><br />
     <b id="SCI_GETCURSOR">SCI_GETCURSOR</b><br />
     The cursor is normally chosen in a context sensitive way, so it will be different over the
    margin than when over the text. When performing a slow action, you may wish to change to a wait
    cursor. You set the cursor type with <code>SCI_SETCURSOR</code>. The <code>curType</code>
    argument can be:</p>

    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Mouse cursors">
      <tbody valign="top">
        <tr>
          <th align="left"><code>SC_CURSORNORMAL</code></th>

          <td>-1</td>

          <td>The normal cursor is displayed.</td>
        </tr>

        <tr>
          <th align="left"><code>SC_CURSORWAIT</code></th>

          <td>&nbsp;4</td>

          <td>The wait cursor is displayed when the mouse is over or owned by the Scintilla
          window.</td>
        </tr>
      </tbody>
    </table>

    <p>1 〜 7 のカーソル値はカーソルで定義されていますが、<code>SC_CURSORWAIT</code> だけが制御に便利です。他の <code>curType</code> の値はカーソルポインタを表示します。<br /><code>SCI_GETCURSOR</code> メッセージは最後に指定されたカーソル種別を返します。未指定だった場合は <code>SC_CURSORNORMAL</code> (-1) が返されます。</p>
    <p class="eng">Cursor values 1 through 7 have defined cursors, but only <code>SC_CURSORWAIT</code> is
    usefully controllable. Other values of <code>curType</code> cause a pointer to be displayed.
    The <code>SCI_GETCURSOR</code> message returns the last cursor type you set, or
    <code>SC_CURSORNORMAL</code> (-1) if you have not set a cursor type.</p>

    <h2 id="MouseCapture"><span>マウスキャプチャ</span><span class="eng">Mouse capture</span></h2>
	<h3 id="SCI_SETMOUSEDOWNCAPTURES">SCI_SETMOUSEDOWNCAPTURES(bool captures)<br />
     <span id="SCI_GETMOUSEDOWNCAPTURES">SCI_GETMOUSEDOWNCAPTURES</span></h3>
    <p>Scintilla の内部でマウスのボタンが押されると、それ以後マウスが動いたというイベント情報が Scintilla に送られます。この挙動は <code>SCI_SETMOUSEDOWNCAPTURES(0)</code> で切ることができます。</p>
    <p class="eng"><b id="SCI_SETMOUSEDOWNCAPTURES">SCI_SETMOUSEDOWNCAPTURES(bool captures)</b><br />
     <b id="SCI_GETMOUSEDOWNCAPTURES">SCI_GETMOUSEDOWNCAPTURES</b><br />
     When the mouse is pressed inside Scintilla, it is captured so future mouse movement events are
    sent to Scintilla. This behavior may be turned off with
    <code>SCI_SETMOUSEDOWNCAPTURES(0)</code>.</p>

    <h2 id="LineEndings"><span>行末文字</span><span class="eng">Line endings</span></h2>

    <p>Scintilla は三種の主要な行末表現を解釈することができます。Macintosh (\r), Unix
    (\n), CP/M / DOS / Windows (\r\n) がその三種です。ユーザが Enter キーを押すとこれらの行末文字の一つがバッファに挿入されます。Windows では \r\n, Unix では \n が標準で挿入されますが、<code>SCI_SETEOLMODE</code> メッセージで変更することができます。行末文字は <code>SCI_SETVIEWEOL</code> の設定によって表示することも可能です。</p>
    <p class="eng">Scintilla can interpret any of the three major line end conventions, Macintosh (\r), Unix
    (\n) and CP/M / DOS / Windows (\r\n). When the user presses the Enter key, one of these line
    end strings is inserted into the buffer. The default is \r\n in Windows and \n in Unix, but
    this can be changed with the <code>SCI_SETEOLMODE</code> message. You can also convert the
    entire document to one of these line endings with <code>SCI_CONVERTEOLS</code>. Finally, you
    can choose to display the line endings with <code>SCI_SETVIEWEOL</code>.</p>
    <code><a class="message" href="#">SCI_SETEOLMODE(int eolMode)</a><br />
     <a class="message" href="#">SCI_GETEOLMODE</a><br />
     <a class="message" href="#">SCI_CONVERTEOLS(int eolMode)</a><br />
     <a class="message" href="#">SCI_SETVIEWEOL(bool visible)</a><br />
     <a class="message" href="#">SCI_GETVIEWEOL</a><br />
    </code>
	<h3 id="SCI_SETEOLMODE">SCI_SETEOLMODE(int eolMode)
	<span id="SCI_GETEOLMODE">SCI_GETEOLMODE</span></h3>
    <p>ユーザが Enter キーを押したときに挿入される文字は <code>SCI_SETEOLMODE</code> で設定できます。<code>eolMode</code> は <code>SC_EOL_CRLF</code> (0),
    <code>SC_EOL_CR</code> (1), <code>SC_EOL_LF</code> (2) のいずれかです。<code>SCI_GETEOLMODE</code> で現在の状態を取得できます。</p>
    <p class="eng"><b>SCI_SETEOLMODE(int eolMode)</b><br />
     <b>SCI_GETEOLMODE</b><br />
     <code>SCI_SETEOLMODE</code> sets the characters that are added into the document when the user
    presses the Enter key. You can set <code>eolMode</code> to one of <code>SC_EOL_CRLF</code> (0),
    <code>SC_EOL_CR</code> (1), or <code>SC_EOL_LF</code> (2). The <code>SCI_GETEOLMODE</code>
    message retrieves the current state.</p>
	<h3 id="SCI_CONVERTEOLS">SCI_CONVERTEOLS(int eolMode)</h3>
    <p>文書内のすべての行末文字を <code>eolMode</code> で指定したものに置き換えます。<code>SC_EOL_CRLF</code> (0), <code>SC_EOL_CR</code>
    (1), <code>SC_EOL_LF</code> (2) が有効です。</p>
    <p class="eng"><b>SCI_CONVERTEOLS(int eolMode)</b><br />
     This message changes all the end of line characters in the document to match
    <code>eolMode</code>. Valid values are: <code>SC_EOL_CRLF</code> (0), <code>SC_EOL_CR</code>
    (1), or <code>SC_EOL_LF</code> (2).</p>
	<h3 id="SCI_SETVIEWEOL">SCI_SETVIEWEOL(bool visible)<br />
     <span id="SCI_GETVIEWEOL">SCI_GETVIEWEOL</span></h3>
    <p>通常、行末文字は隠されていますが <code>SCI_SETVIEWEOL</code> で設定することによりこれを見えるようにすることができます。<code>visible</code> に <code>true</code> を指定すると見えるようになり、<code>false</code> を指定すると見えなくなります。見えるようにした場合、<code>(CR)</code>, <code>(LF)</code>, <code>(CR)(LF)</code>といった表現になっています。<code>SCI_GETVIEWEOL</code> で現在の状態を取得できます。</p>
    <p class="eng"><b>SCI_SETVIEWEOL(bool visible)</b><br />
     <b>SCI_GETVIEWEOL</b><br />
     Normally, the end of line characters are hidden, but <code>SCI_SETVIEWEOL</code> allows you to
    display (or hide) them by setting <code>visible</code> <code>true</code> (or
    <code>false</code>). The visible rendering of the end of line characters is similar to
    <code>(CR)</code>, <code>(LF)</code>, or <code>(CR)(LF)</code>. <code>SCI_GETVIEWEOL</code>
    returns the current state.</p>

    <h2 id="Styling"><span>装飾</span><span class="eng">Styling</span></h2>

    <p>ここで解説する装飾系のメッセージはテキストの装飾割り当てを行います。Scintilla の標準設定では、文字毎に 8 ビットの情報が持てる中で 5 ビットを装飾 ( ビット 0 〜 4 = <a class="jump"
    href="#StyleDefinition">装飾番号 0 〜 31</a> )に、残りの 3 ビットを<a class="jump" href="#Indicators">指標</a>に割り当てます。装飾と指標の配分は <a class="message"
    href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a> で変更できます。既存の標準解析器の中に欲しい装飾方法がある場合、あるいは自分で解析器を書く場合のいずれでも、解析器はおそらく文書を装飾表示する最も簡単な方法です。装飾を実行するコンテナを使うことに決めたときは <a class="message" href="#SCI_SETLEXER"><code>SCI_SETLEXER</code></a> で <code>SCLEX_CONTAINER</code> を選択します。この場合、テキストを表示用に装飾する必要が出るたびに <a class="message"
    href="#SCN_STYLENEEDED"><code>SCN_STYLENEEDED</code></a> <a class="jump"
    href="#Notifications">通知</a>がコンテナに送られます。装飾は空き時間で行うように指示することができます。解析器を使っている場合も含め、コンパイラが見つけたエラーに印をつけるために装飾コマンドを使うこともあるでしょう。次のコマンドが提供されています。</p>
    <p class="eng">The styling messages allow you to assign styles to text. The standard Scintilla settings
    divide the 8 style bits available for each character into 5 bits (0 to 4 = <a class="jump"
    href="#StyleDefinition">styles 0 to 31</a>) that set a style and three bits (5 to 7) that
    define <a class="jump" href="#Indicators">indicators</a>. You can change the balance between
    styles and indicators with <a class="message"
    href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a>. If your styling needs can be met by
    one of the standard lexers, or if you can write your own, then a lexer is probably the easiest
    way to style your document. If you choose to use the container to do the styling you can use
    the <a class="message" href="#SCI_SETLEXER"><code>SCI_SETLEXER</code></a> command to select
    <code>SCLEX_CONTAINER</code>, in which case the container is sent a <a class="message"
    href="#SCN_STYLENEEDED"><code>SCN_STYLENEEDED</code></a> <a class="jump"
    href="#Notifications">notification</a> each time text needs styling for display. As another
    alternative, you might use idle time to style the document. Even if you use a lexer, you might
    use the styling commands to mark errors detected by a compiler. The following commands can be
    used.</p>
    <code><a class="message" href="#SCI_GETENDSTYLED">SCI_GETENDSTYLED</a><br />
     <a class="message" href="#SCI_STARTSTYLING">SCI_STARTSTYLING(int position, int mask)</a><br />
     <a class="message" href="#SCI_SETSTYLING">SCI_SETSTYLING(int length, int style)</a><br />
     <a class="message" href="#SCI_SETSTYLINGEX">SCI_SETSTYLINGEX(int length, const char
    *styles)</a><br />
     <a class="message" href="#SCI_SETLINESTATE">SCI_SETLINESTATE(int line, int value)</a><br />
     <a class="message" href="#SCI_GETLINESTATE">SCI_GETLINESTATE(int line)</a><br />
     <a class="message" href="#SCI_GETMAXLINESTATE">SCI_GETMAXLINESTATE</a><br />
    </code>
	<h3 id="SCI_GETENDSTYLED">SCI_GETENDSTYLED</h3>
    <p>Scintilla は正しく装飾されたと思われる最後の文字を記録しています。その次の文字が装飾されれば記録はその方向へ移動し、それ以前の文字が修正されれば記録の位置も戻ります。テキストの描画の前に何らかの装飾が必要かどうかを知るためにこの位置が検査され、もし必要ならば通知 <code><a class="message"
    href="#SCN_STYLENEEDED">SCN_STYLENEEDED</a></code> がコンテナに送られます。コンテナは <code>SCI_GETENDSTYLED</code> で装飾の開始点を見つけることができます。Scintilla は常に行全体に対して装飾目的の問い合わせを行います。</p>
    <p class="eng"><b>SCI_GETENDSTYLED</b><br />
     Scintilla keeps a record of the last character that is likely to be styled correctly. This is
    moved forwards when characters after it are styled and moved backwards if changes are made to
    the text of the document before it. Before drawing text, this position is checked to see if any
    styling is needed and, if so, a <code><a class="message"
    href="#SCN_STYLENEEDED">SCN_STYLENEEDED</a></code> notification message is sent to the
    container. The container can send <code>SCI_GETENDSTYLED</code> to work out where it needs to
    start styling. Scintilla will always ask to style whole lines.</p>
	<h3 id="SCI_STARTSTYLING">SCI_STARTSTYLING(int pos, int mask)</h3>
    <p>装飾処理の準備をします。位置 <code>pos</code> を開始点とし、どの装飾が設定可能かを示すマスクを <code>mask</code> で指定します。マスクによって何度か同じ点を処理させることができます。例えば一回目で基本装飾を行ってコードテキストを素早く正確に表示させ、他方時間のかかる二回目で文法の誤りを検出し、指標を使って誤りがどれなのかを示すといった使い方ができます。標準設定では装飾が 5 ビット、指標が 3 ビットになっていますが、この状態で <code>mask</code> を 31 (0x1f) にすると、テキストの装飾のみを設定し、指標を操作させないでいることができます。<code>SCI_STARTSTYLING</code> の後、装飾に使う解析時の実体ごとに <code>SCI_SETSTYLING</code> メッセージを送信してください。</p>
    <p class="eng"><b id="SCI_STARTSTYLING">SCI_STARTSTYLING(int pos, int mask)</b><br />
     This prepares for styling by setting the styling position <code>pos</code> to start at and a
    <code>mask</code> indicating which bits of the style bytes can be set. The mask allows styling
    to occur over several passes, with, for example, basic styling done on an initial pass to
    ensure that the text of the code is seen quickly and correctly, and then a second slower pass,
    detecting syntax errors and using indicators to show where these are. For example, with the
    standard settings of 5 style bits and 3 indicator bits, you would use a <code>mask</code> value
    of 31 (0x1f) if you were setting text styles and did not want to change the indicators. After
    <code>SCI_STARTSTYLING</code>, send multiple <code>SCI_SETSTYLING</code> messages for each
    lexical entity to style.</p>
	<h3 id="SCI_SETSTYLING">SCI_SETSTYLING(int length, int style)</h3>
    <p>装飾開始位置から文字数 <code>length</code> に渡って指定の装飾を設定します。実行後、装飾開始位置は <code>length</code> の分だけ移動し、次の呼び出しに利用できるようになります。<code>sCell</code> が対象文字の装飾オクテットであるとき、この呼び出しは次の処理を行います。<br />
     <code>if ((sCell &amp; mask) != style) sCell = (sCell &amp; ~mask) | (style &amp;
    mask);</code></p>
    <p class="eng"><b>SCI_SETSTYLING(int length, int style)</b><br />
     This message sets the style of <code>length</code> characters starting at the styling position
    and then increases the styling position by <code>length</code>, ready for the next call. If
    <code>sCell</code> is the style byte, the operation is:<br />
     <code>if ((sCell &amp; mask) != style) sCell = (sCell &amp; ~mask) | (style &amp;
    mask);</code><br />
    </p>
	<h3 id="SCI_SETSTYLINGEX">SCI_SETSTYLINGEX(int length, const char *styles)</h3>
    <p><code>SCI_SETSTYLING</code> が指定範囲に同じ装飾を設定するのに対し、このメッセージでは装飾開始位置と <code>length</code> で定まる範囲の各オクテットごとに <code>styles</code> 配列の装飾を設定します。<code>styles</code> の各オクテットはマスクで指定されたビット以外を設定すべきではありません。実行後、装飾開始位置は <code>length</code> の分だけ移動し、次の呼び出しに利用できるようになります。</p>
    <p class="eng"><b>SCI_SETSTYLINGEX(int length, const char *styles)</b><br />
     As an alternative to <code>SCI_SETSTYLING</code>, which applies the same style to each byte,
    you can use this message which specifies the styles for each of <code>length</code> bytes from
    the styling position and then increases the styling position by <code>length</code>, ready for
    the next call. The <code>length</code> styling bytes pointed at by <code>styles</code> should
    not contain any bits not set in mask.</p>
	<h3 id="SCI_SETLINESTATE">SCI_SETLINESTATE(int line, int value)<br />
     <span id="SCI_GETLINESTATE">SCI_GETLINESTATE(int line)</span></h3>
    <p>各文字に対し 8 ビットの解析状態が格納されているように、各行にも整数が格納されています。ASP ページ内でどのスクリプト言語が使われているか、などといった長い範囲の分析状態の格納に使うことができます。<code>SCI_SETLINESTATE</code> でこの値を設定し、<code>SCI_GETLINESTATE</code> で取得することができます。</p>
    <p class="eng"><b>SCI_SETLINESTATE(int line, int value)</b><br />
     <b>SCI_GETLINESTATE(int line)</b><br />
     As well as the 8 bits of lexical state stored for each character there is also an integer
    stored for each line. This can be used for longer lived parse states such as what the current
    scripting language is in an ASP page. Use <code>SCI_SETLINESTATE</code> to set the integer
    value and <code>SCI_GETLINESTATE</code> to get the value.</p>
	<h3 id="SCI_GETMAXLINESTATE">SCI_GETMAXLINESTATE</h3>
    <p>行の状態を持っているもののうちで最終の行を返します。</p>
    <p class="eng"><b id="SCI_GETMAXLINESTATE">SCI_GETMAXLINESTATE</b><br />
     This returns the last line that has any line state.</p>

    <h2 id="StyleDefinition"><span>装飾の定義</span><span class="eng">Style definition</span></h2>

    <p>前節で解説した装飾設定メッセージはテキストに関係づけられた装飾番号を変更するものでした。ここではそれらの装飾番号に対して視覚的にどう表現するかを定義するメッセージを紹介します。装飾ビットには 0 〜 <code>STYLEMAX</code> (127) まで 128 種の解析による装飾値が設定できます。0 〜 31 はテキストの属性に使われます。さらに 32 以降にも定義済みの番号があり、次の <code>STYLE_</code>* 定数で参照します。</p>
    <p class="eng">While the style setting messages mentioned above change the style numbers associated with
    text, these messages define how those style numbers are interpreted visually. There are 128
    lexer styles that can be set, numbered 0 to <code>STYLEMAX</code> (127). Unless you use <a
    class="message" href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a> to change the number
    of style bits, styles 0 to 31 are used to set the text attributes. There are also some
    predefined numbered styles starting at 32, The following <code>STYLE_</code>* constants are
    defined.</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="Preset styles">
      <tbody valign="top">
        <tr>
          <th align="left"><code>STYLE_DEFAULT</code></th>

          <td>32</td>

          <td><code>SCI_STYLECLEARALL</code> メッセージが使われたときにすべての装飾が参照する属性を定義します。</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_LINENUMBER</code></th>

          <td>33</td>

          <td>行番号表示余白の属性に関する装飾番号です。文字色・背景色が設定できます。背景色は折りたたみのマスクビットが使われていてはいけません。すなわち <code>mask &amp; SC_MASK_FOLDERS</code> は 0 でなくてはなりません。マスクについては <a class="message"
          href="#SCI_SETMARGINMASKN"><code>SCI_SETMARGINMASKN</code></a> を参照してください。</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_BRACELIGHT</code></th>

          <td>34</td>

          <td>括弧の強調に関する装飾番号です。<a
          class="message" href="#BraceHighlighting"><code>SCI_BRACEHIGHLIGHT</code></a> メッセージで使うほか、<a class="message"
          href="#SCI_SETHIGHLIGHTGUIDE"><code>SCI_SETHIGHLIGHTGUIDE</code></a> で関係し合う字下げ部の強調表示にも使用されます。</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_BRACEBAD</code></th>

          <td>35</td>

          <td>対応の付かない括弧に関する装飾番号です。<a class="message" href="#BraceHighlighting"><code>SCI_BRACEBADLIGHT</code></a> メッセージで使用します。</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_CONTROLCHAR</code></th>

          <td>36</td>

          <td>制御文字に関する装飾番号です。フォント、文字の大きさ、太字、イタリック体、文字集合の属性が使用できます。他方、色の属性は利用できません。<br />参照: <a class="message"
          href="#SCI_SETCONTROLCHARSYMBOL"><code>SCI_SETCONTROLCHARSYMBOL</code></a></td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_INDENTGUIDE</code></th>

          <td>37</td>

          <td>字下げ情報を表示する部分の前景色と背景色に関する装飾番号です。</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_LASTPREDEFINED</code></th>

          <td>39</td>

          <td>コードを書く側が定義済みスタイル番号を検出できるように定義されている値です。この値は定義済み装飾番号のうち最後のものに設定されています。現時点の最終番号は 37 であるのに対してこの値が 39 になっています。これは将来の定義済み装飾番号のために予約されているものです。</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_MAX</code></th>

          <td>127</td>

          <td>これは装飾属性ではありませんが、使用可能な装飾番号の最大値を保持しています。<a class="message" href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a> を用いて装飾ビットを 5 ビットより多くした場合は <code>STYLE_LASTPREDEFINED</code> 〜 <code>STYLE_MAX</code> の間の装飾番号が充当されることになります。 </td>
        </tr>
      </tbody>
    </table>


    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Preset styles">
      <tbody valign="top">
        <tr>
          <th align="left"><code>STYLE_DEFAULT</code></th>

          <td>32</td>

          <td>This style defines the attributes that all styles receive when the
          <code>SCI_STYLECLEARALL</code> message is used.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_LINENUMBER</code></th>

          <td>33</td>

          <td>This style sets the attributes of the text used to display line numbers in a line
          number margin. The background colour set for this style also sets the background colour
          for all margins that do not have any folding mask bits set. That is, any margin for which
          <code>mask &amp; SC_MASK_FOLDERS</code> is 0. See <a class="message"
          href="#SCI_SETMARGINMASKN"><code>SCI_SETMARGINMASKN</code></a> for more about masks.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_BRACELIGHT</code></th>

          <td>34</td>

          <td>This style sets the attributes used when highlighting braces with the <a
          class="message" href="#BraceHighlighting"><code>SCI_BRACEHIGHLIGHT</code></a> message and
          when highlighting the corresponding indentation with <a class="message"
          href="#SCI_SETHIGHLIGHTGUIDE"><code>SCI_SETHIGHLIGHTGUIDE</code></a>.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_BRACEBAD</code></th>

          <td>35</td>

          <td>This style sets the display attributes used when marking an unmatched brace with the
          <a class="message" href="#BraceHighlighting"><code>SCI_BRACEBADLIGHT</code></a>
          message.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_CONTROLCHAR</code></th>

          <td>36</td>

          <td>This style sets the font used when drawing control characters.
	  Only the font, size, bold, italics, and character set attributes are used and not
	  the colour attributes. See
          also: <a class="message"
          href="#SCI_SETCONTROLCHARSYMBOL"><code>SCI_SETCONTROLCHARSYMBOL</code></a>.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_INDENTGUIDE</code></th>

          <td>37</td>

          <td>This style sets the foreground and background colours used when drawing the
          indentation guides.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_LASTPREDEFINED</code></th>

          <td>39</td>

          <td>To make it easier for client code to discover the range of styles that are
          predefined, this is set to the style number of the last predefined style. This is
          currently set to 39 and the last style with an identifier is 37, which reserves space for
          future predefined styles.</td>
        </tr>

        <tr>
          <th align="left"><code>STYLE_MAX</code></th>

          <td>127</td>

          <td>This is not a style but is the number of the maximum style that can be set. Styles
          between <code>STYLE_LASTPREDEFINED</code> and <code>STYLE_MAX</code> would be appropriate
          if you used <a class="message" href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a>
          to set more than 5 style bits.</td>
        </tr>
      </tbody>
    </table>

    <p>各々の装飾番号毎にフォント名、文字の大きさ、太字・イタリック・下線の指定、文字色(前景色)、背景色、および文字集合を設定できます。また、要求された装飾に対してテキストを隠したり、文字をすべて大文字化あるいは小文字化したり、文書途中で内包されている別言語の識別のために行末文字から行末までを塗りつぶすといったこともできます。このほか、試験的に「読み出し専用テキスト」属性が用意されています。</p>
    <p class="eng">For each style you can set the font name, size and use of bold, italic and underline,
    foreground and background colour and the character set. You can also choose to hide text with a
    given style, display all characters as upper or lower case and fill from the last character on
    a line to the end of the line (for embedded languages). There is also an experimental attribute
    to make text read-only.</p>

    <p>装飾をどのように使うかは完全にあなたの責任です。文法解析による色づけを行いたいのであれば、ホワイトスペースに 0 、数字に 1 、キーワードに 2 、文字列に3、プリプロセッサに 4、演算子に 5 …といった具合に自分で定義できます。</p>
    <p class="eng">It is entirely up to you how you use styles. If you want to use syntax colouring you might
    use style 0 for white space, style 1 for numbers, style 2 for keywords, style 3 for strings,
    style 4 for preprocessor, style 5 for operators, and so on.</p>
    <code><a class="message" href="#SCI_STYLERESETDEFAULT">SCI_STYLERESETDEFAULT</a><br />
     <a class="message" href="#SCI_STYLECLEARALL">SCI_STYLECLEARALL</a><br />
     <a class="message" href="#SCI_STYLESETFONT">SCI_STYLESETFONT(int styleNumber, char
    *fontName)</a><br />
     <a class="message" href="#SCI_STYLESETSIZE">SCI_STYLESETSIZE(int styleNumber, int
    sizeInPoints)</a><br />
     <a class="message" href="#SCI_STYLESETBOLD">SCI_STYLESETBOLD(int styleNumber, bool
    bold)</a><br />
     <a class="message" href="#SCI_STYLESETITALIC">SCI_STYLESETITALIC(int styleNumber, bool
    italic)</a><br />
     <a class="message" href="#SCI_STYLESETUNDERLINE">SCI_STYLESETUNDERLINE(int styleNumber, bool
    underline)</a><br />
     <a class="message" href="#SCI_STYLESETFORE">SCI_STYLESETFORE(int styleNumber, int
    colour)</a><br />
     <a class="message" href="#SCI_STYLESETBACK">SCI_STYLESETBACK(int styleNumber, int
    colour)</a><br />
     <a class="message" href="#SCI_STYLESETEOLFILLED">SCI_STYLESETEOLFILLED(int styleNumber, bool
    eolFilled)</a><br />
     <a class="message" href="#SCI_STYLESETCHARACTERSET">SCI_STYLESETCHARACTERSET(int styleNumber,
    int charSet)</a><br />
     <a class="message" href="#SCI_STYLESETCASE">SCI_STYLESETCASE(int styleNumber, int
    caseMode)</a><br />
     <a class="message" href="#SCI_STYLESETVISIBLE">SCI_STYLESETVISIBLE(int styleNumber, bool
    visible)</a><br />
     <a class="message" href="#SCI_STYLESETCHANGEABLE">SCI_STYLESETCHANGEABLE(int styleNumber, bool
    changeable)</a><br />
     <a class="message" href="#SCI_STYLESETHOTSPOT">SCI_STYLESETHOTSPOT(int styleNumber, bool
    hotspot)</a><br />
    </code>
	<h3 id="SCI_STYLERESETDEFAULT">SCI_STYLERESETDEFAULT</h3>
    <p><code>STYLE_DEFAULT</code> を Scintilla が初期化されたときの状態に戻します。</p>
    <p class="eng"><b id="SCI_STYLERESETDEFAULT">SCI_STYLERESETDEFAULT</b><br />
     This message resets <code>STYLE_DEFAULT</code> to its state when Scintilla was
    initialised.</p>
	<h3 id="SCI_STYLECLEARALL">SCI_STYLECLEARALL</h3>
    <p>すべての装飾を <code>STYLE_DEFAULT</code> の状態に設定します。文法による色づけの用途で Scintilla を使っているなら、解析による装飾はおおよそ似たものになるでしょう。装飾設定の手順の一つは次のようになります。</p>
	<ul><li><code>STYLE_DEFAULT</code> に全装飾に共通の要素を設定する。</li>
	<li><code>SCI_STYLECLEARALL</code> で全ての装飾にこれを複製する。</li>
	<li>装飾属性で各々異なる部分を設定する。</li></ul>
    <p class="eng"><b>SCI_STYLECLEARALL</b><br />
     This message sets all styles to have the same attributes as <code>STYLE_DEFAULT</code>. If you
    are setting up Scintilla for syntax colouring, it is likely that the lexical styles you set
    will be very similar. One way to set the styles is to:<br />
     1. Set <code>STYLE_DEFAULT</code> to the common features of all styles.<br />
     2. Use <code>SCI_STYLECLEARALL</code> to copy this to all styles.<br />
     3. Set the style attributes that make your lexical styles different.</p>
	<h3 id="SCI_STYLESETFONT">SCI_STYLESETFONT(int styleNumber, const char *fontName)<br />
     <span id="SCI_STYLESETSIZE">SCI_STYLESETSIZE(int styleNumber, int sizeInPoints)</span><br />
     <span id="SCI_STYLESETBOLD">SCI_STYLESETBOLD(int styleNumber, bool bold)</span><br />
     <span id="SCI_STYLESETITALIC">SCI_STYLESETITALIC(int styleNumber, bool italic)</span></h3>
    <p>これらおよびメッセージ <a class="message"
    href="#SCI_STYLESETCHARACTERSET"><code>SCI_STYLESETCHARACTERSET</code></a> はフォント属性を設定し、これらが要求されたときの合致条件として使用されます。<code>fontName</code> は 0 終端文字列で、フォント名を指定します。Windows では名前の先頭32文字を使用し、大文字小文字は区別されません。内部キャッシュのため、Scintilla は名前でフォントを検索し、フォント名の大文字小文字を合わせようとします。ですから、指定名は一貫性を持たせておいてください(訳注: このあたり特に意味不明)。GTK+ 2.x においては、GDK でも Pango でもテキストを表示できます。Pango であればアンチエイリアステキストを使えますし Unicode を使うこともできますが、GDK は高速に動作します。Pango を使うには '!' の文字をフォント名の先頭に追加してください。</p>
    <p class="eng"><b>SCI_STYLESETFONT(int styleNumber, const char *fontName)</b><br />
     <b>SCI_STYLESETSIZE(int styleNumber, int sizeInPoints)</b><br />
     <b>SCI_STYLESETBOLD(int styleNumber, bool bold)</b><br />
     <b>SCI_STYLESETITALIC(int styleNumber, bool italic)</b><br />
     These messages (plus <a class="message"
    href="#SCI_STYLESETCHARACTERSET"><code>SCI_STYLESETCHARACTERSET</code></a>) set the font
    attributes that are used to match the fonts you request to those available. The
    <code>fontName</code> is a zero terminated string holding the name of a font. Under Windows,
    only the first 32 characters of the name are used and the name is not case sensitive. For
    internal caching, Scintilla tracks fonts by name and does care about the casing of font names,
    so please be consistent. On GTK+ 2.x, either GDK or Pango can be used to display text.
    Pango antialiases text and works well with Unicode but GDK is faster.
    Prepend a '!' character to the font name to use Pango.</p>
	<h3 id="SCI_STYLESETUNDERLINE">SCI_STYLESETUNDERLINE(int styleNumber, bool
    underline)</h3>
    <p>装飾に下線を使うようにします。下線は文字色で描かれます。下線の属性を持つ文字はホワイトスペースも含めてすべて下線が引かれます。</p>
    <p class="eng"><b>SCI_STYLESETUNDERLINE(int styleNumber, bool
    underline)</b><br />
     You can set a style to be underlined. The underline is drawn in the foreground colour. All
    characters with a style that includes the underline attribute are underlined, even if they are
    white space.</p>
	<h3 id="SCI_STYLESETFORE">SCI_STYLESETFORE(int styleNumber, int <a class="jump"
    href="#colour">colour</a>)<br />
     <span id="SCI_STYLESETBACK">SCI_STYLESETBACK(int styleNumber, int <a class="jump"
    href="#colour">colour</a>)</span></h3>
    <p>テキストは前景色(foreground colour)で描かれます。文字を囲む矩形の文字ではない部分は背景色(background colour) で描かれます。</p>
    <p class="eng"><b>SCI_STYLESETFORE(int styleNumber, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b>SCI_STYLESETBACK(int styleNumber, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     Text is drawn in the foreground colour. The space in each character cell that is not occupied
    by the character is drawn in the background colour.</p>
	<h3 id="SCI_STYLESETEOLFILLED">SCI_STYLESETEOLFILLED(int styleNumber, bool
    eolFilled)</h3>
    <p>行の最後にある文字が属性設定を受けた装飾を持つとき、その右側からウィンドウの右端までは最後の文字の背景色で塗りつぶされます。HTML の中の JavaScript など、ある言語の中に別の言語が内包されているときにこの機能は便利です。<code>eolFilled</code> を <code>true</code> に、かつ内包された側の言語の背景色を一定の内包する側とは違う色にすると、この場合なら JavaScript と HTML が区別しやすくなります。</p>
    <p class="eng"><b>SCI_STYLESETEOLFILLED(int styleNumber, bool
    eolFilled)</b><br />
     If the last character in the line has a style with this attribute set, the remainder of the
    line up to the right edge of the window is filled with the background colour set for the last
    character. This is useful when a document contains embedded sections in another language such
    as HTML pages with embedded JavaScript. By setting <code>eolFilled</code> to <code>true</code>
    and a consistent background colour (different from the background colour set for the HTML
    styles) to all JavaScript styles then JavaScript sections will be easily distinguished from
    HTML.</p>
	<h3 id="SCI_STYLESETCHARACTERSET">SCI_STYLESETCHARACTERSET(int styleNumber, int
    charSet)</h3>
    <p>標準とは異なる文字集合に装飾をつけることができます。そういった文字集合が注釈や文字列で使えると便利です。<code>SCI_STYLESETCHARACTERSET(SCE_C_STRING, SC_CHARSET_RUSSIAN)</code> と言うコードはロシア語の文字列を C と C++ で正確に表示します。<code>SCE_C_STRING</code> は C/C++ 解析器で使われている文字列への装飾番号(値は6)です。現在は Windows でのみ全機能が動作します。</p>
    <p class="eng"><b id="SCI_STYLESETCHARACTERSET">SCI_STYLESETCHARACTERSET(int styleNumber, int
    charSet)</b><br />
     You can set a style to use a different character set than the default. The places where such
    characters sets are likely to be useful are comments and literal strings. For example,
    <code>SCI_STYLESETCHARACTERSET(SCE_C_STRING, SC_CHARSET_RUSSIAN)</code> would ensure that
    strings in Russian would display correctly in C and C++ (<code>SCE_C_STRING</code> is the style
    number used by the C and C++ lexer to display literal strings; it has the value 6). This
    feature currently only works fully on Windows.</p>

    <p>Windows で対応できる文字集合は次の通りです。<br /><code>SC_CHARSET_ANSI</code>, <code>SC_CHARSET_ARABIC</code>, <code>SC_CHARSET_BALTIC</code>,
    <code>SC_CHARSET_CHINESEBIG5</code>, <code>SC_CHARSET_DEFAULT</code>,
    <code>SC_CHARSET_EASTEUROPE</code>, <code>SC_CHARSET_GB2312</code>,
    <code>SC_CHARSET_GREEK</code>, <code>SC_CHARSET_HANGUL</code>, <code>SC_CHARSET_HEBREW</code>,
    <code>SC_CHARSET_JOHAB</code>, <code>SC_CHARSET_MAC</code>, <code>SC_CHARSET_OEM</code>,
    <code>SC_CHARSET_SHIFTJIS</code>, <code>SC_CHARSET_SYMBOL</code>, <code>SC_CHARSET_THAI</code>,
    <code>SC_CHARSET_TURKISH</code>, <code>SC_CHARSET_VIETNAMESE</code>.</p>
    <p class="eng">The character sets supported on Windows are:<br />
     <code>SC_CHARSET_ANSI</code>, <code>SC_CHARSET_ARABIC</code>, <code>SC_CHARSET_BALTIC</code>,
    <code>SC_CHARSET_CHINESEBIG5</code>, <code>SC_CHARSET_DEFAULT</code>,
    <code>SC_CHARSET_EASTEUROPE</code>, <code>SC_CHARSET_GB2312</code>,
    <code>SC_CHARSET_GREEK</code>, <code>SC_CHARSET_HANGUL</code>, <code>SC_CHARSET_HEBREW</code>,
    <code>SC_CHARSET_JOHAB</code>, <code>SC_CHARSET_MAC</code>, <code>SC_CHARSET_OEM</code>,
    <code>SC_CHARSET_SHIFTJIS</code>, <code>SC_CHARSET_SYMBOL</code>, <code>SC_CHARSET_THAI</code>,
    <code>SC_CHARSET_TURKISH</code>, and <code>SC_CHARSET_VIETNAMESE</code>.</p>

    <p>GTK+ で対応している文字集合は次の通りです。<br /><code>SC_CHARSET_ANSI</code>, <code>SC_CHARSET_EASTEUROPE</code>,
    <code>SC_CHARSET_GB2312</code>, <code>SC_CHARSET_HANGUL</code>, 
    <code>SC_CHARSET_SHIFTJIS</code>.</p>
    <p class="eng">The character sets supported on GTK+ are:<br />
     <code>SC_CHARSET_ANSI</code>, <code>SC_CHARSET_EASTEUROPE</code>,
    <code>SC_CHARSET_GB2312</code>, <code>SC_CHARSET_HANGUL</code>, and
    <code>SC_CHARSET_SHIFTJIS</code>.</p>
	<h3 id="SCI_STYLESETCASE">SCI_STYLESETCASE(int styleNumber, int caseMode)</h3>
    <p>caseMode によりアルファベットの大文字小文字に関してどのように表示するかを指定します。通常表示(<code>SC_CASE_MIXED</code>, 0)、大文字(<code>SC_CASE_UPPER</code>, 1)、小文字(<code>SC_CASE_LOWER</code>, 2)のいずれかを設定します。この機能は表示方法だけを変更するもので、記憶しているテキスト自体は変更されません。</p>
    <p class="eng"><b>SCI_STYLESETCASE(int styleNumber, int caseMode)</b><br />
     The value of caseMode determines how text is displayed. You can set upper case
    (<code>SC_CASE_UPPER</code>, 1) or lower case (<code>SC_CASE_LOWER</code>, 2) or display
    normally (<code>SC_CASE_MIXED</code>, 0). This does not change the stored text, only how it is
    displayed.</p>
	<h3 id="SCI_STYLESETVISIBLE">SCI_STYLESETVISIBLE(int styleNumber, bool visible)</h3>
    <p>通常、テキストは「見えます」。しかしながら、このメッセージにおいて <code>visible</code> に 0 を指定することによって完全に隠すことができます。埋め込まれた書式化命令や、HTML や XML におけるハイパーテキストのキーワードなどに用いることができます。</p>
    <p class="eng"><b>SCI_STYLESETVISIBLE(int styleNumber, bool visible)</b><br />
     Text is normally visible. However, you can completely hide it by giving it a style with the
    <code>visible</code> set to 0. This could be used to hide embedded formatting instructions or
    hypertext keywords in HTML or XML.</p>
	<h3 id="SCI_STYLESETCHANGEABLE">SCI_STYLESETCHANGEABLE(int styleNumber, bool
    changeable)</h3>
    <p>これはまだ実験的で不完全な実装の装飾属性です。標準では <code>changeable</code> が <code>true</code> に設定されていますがこれを <code>false</code> にすると文字列が読み出し専用になります。現時点では変更不可能とされたテキストの中にキャレットが入り込まないような機能を持つだけで、指定範囲の中に変更不可テキストがあった場合にその削除を避けるといった機能は未実装です。</p>
    <p class="eng"><b>SCI_STYLESETCHANGEABLE(int styleNumber, bool
    changeable)</b><br />
     This is an experimental and incompletely implemented style attribute. The default setting is
    <code>changeable</code> set <code>true</code> but when set <code>false</code> it makes text
    read-only. Currently it only stops the caret from being within not-changeable text and does not
    yet stop deleting a range that contains not-changeable text.</p>
	<h3 id="SCI_STYLESETHOTSPOT">SCI_STYLESETHOTSPOT(int styleNumber, bool
    hotspot)</h3>
    <p>マウスクリックを検出できるテキスト範囲を目立たせるために用いられます。マウスカーソルはホットスポットの上では手の形に変わり、前景色・背景色も変更され、下線が表示されてクリックに反応することを示します。他の文書へのハイパーリンク実装の一部としてつかうことができます。</p>
    <p class="eng"><b>SCI_STYLESETHOTSPOT(int styleNumber, bool
    hotspot)</b><br />
     This style is used to mark ranges of text that can detect mouse clicks.
     The cursor changes to a hand over hotspots, and the foreground, and background colours
     may change and an underline appear to indicate that these areas are sensitive to clicking.
     This may be used to allow hyperlinks to other documents.</p>

    <h2 id="CaretAndSelectionStyles"><span>キャレット・選択範囲・ホットスポットの装飾</span><span class="eng">Caret, selection, and hotspot styles</span></h2>

    <p>選択範囲は文字色・背景色の一方または両方を変更することで表示されます。各々が未設定だった場合は選択範囲に含まれても表示属性が変更されません。標準では背景色が明るい灰色になり、文字色は変更されないままとなっています。選択範囲がない場合は、現在の挿入点がテキストキャレットで印付けられます。キャレットは垂直な線で、通常はユーザが気づきやすいやすいように点滅をしています。</p>
    <p class="eng">The selection is shown by changing the foreground and/or background colours. If one of these
    is not set then that attribute is not changed for the selection. The default is to show the
    selection by changing the background to light gray and leaving the foreground the same as when
    it was not selected. When there is no selection, the current insertion point is marked by the
    text caret. This is a vertical line that is normally blinking on and off to attract the users
    attention.</p>
    <code><a class="message" href="#SCI_SETSELFORE">SCI_SETSELFORE(bool useSelectionForeColour, int
    colour)</a><br />
     <a class="message" href="#SCI_SETSELBACK">SCI_SETSELBACK(bool useSelectionBackColour, int
    colour)</a><br />
     <a class="message" href="#SCI_SETCARETFORE">SCI_SETCARETFORE(int colour)</a><br />
     <a class="message" href="#SCI_GETCARETFORE">SCI_GETCARETFORE</a><br />
     <a class="message" href="#SCI_SETCARETLINEVISIBLE">SCI_SETCARETLINEVISIBLE(bool
    show)</a><br />
     <a class="message" href="#SCI_GETCARETLINEVISIBLE">SCI_GETCARETLINEVISIBLE</a><br />
     <a class="message" href="#SCI_SETCARETLINEBACK">SCI_SETCARETLINEBACK(int colour)</a><br />
     <a class="message" href="#SCI_GETCARETLINEBACK">SCI_GETCARETLINEBACK</a><br />
     <a class="message" href="#SCI_SETCARETPERIOD">SCI_SETCARETPERIOD(int milliseconds)</a><br />
     <a class="message" href="#SCI_GETCARETPERIOD">SCI_GETCARETPERIOD</a><br />
     <a class="message" href="#SCI_SETCARETWIDTH">SCI_SETCARETWIDTH(int pixels)</a><br />
     <a class="message" href="#SCI_GETCARETWIDTH">SCI_GETCARETWIDTH</a><br />
     <a class="message" href="#SCI_SETHOTSPOTACTIVEFORE">SCI_SETHOTSPOTACTIVEFORE</a><br />
     <a class="message" href="#SCI_SETHOTSPOTACTIVEBACK">SCI_SETHOTSPOTACTIVEBACK</a><br />
     <a class="message" href="#SCI_SETHOTSPOTACTIVEUNDERLINE">SCI_SETHOTSPOTACTIVEUNDERLINE</a><br />
     <a class="message" href="#SCI_SETHOTSPOTSINGLELINE">SCI_SETHOTSPOTSINGLELINE</a><br />
     <a class="message" href="#SCI_SETCONTROLCHARSYMBOL">SCI_SETCONTROLCHARSYMBOL(int
    symbol)</a><br />
     <a class="message" href="#SCI_GETCONTROLCHARSYMBOL">SCI_GETCONTROLCHARSYMBOL</a><br />
    </code>
	<h3 id="SCI_SETSELFORE">SCI_SETSELFORE(bool useSelectionForeColour, int <a class="jump"
    href="#colour">colour</a>)</h3>
    <p>選択範囲に対する標準設定を上書きすることができます。 <code>useSelection*Colour</code> を <code>true</code> にすると任意の色を指定できます。<code>false</code> にすると標準の色処理が採用され、<code>colour</code> は無視されます。</p>
    <p class="eng"><b>SCI_SETSELFORE(bool useSelectionForeColour, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b>SCI_SETSELBACK(bool useSelectionBackColour, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     You can choose to override the default selection colouring with these two messages. The colour
    you provide is used if you set <code>useSelection*Colour</code> to <code>true</code>. If it is
    set to <code>false</code>, the default colour colouring is used and the <code>colour</code>
    argument has no effect.</p>
	<h3 id="SCI_SETCARETFORE">SCI_SETCARETFORE(int <a class="jump"
    href="#colour">colour</a>)<br /><span id="SCI_GETCARETFORE">SCI_GETCARETFORE</span></h3>
    <p>キャレットの色を <code>SCI_SETCARETFORE</code> で設定し、 <code>SCI_GETCARETFORE</code> で取得することができます。</p>
    <p class="eng"><b>SCI_SETCARETFORE(int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b>SCI_GETCARETFORE</b><br />
     The colour of the caret can be set with <code>SCI_SETCARETFORE</code> and retrieved with
    <code>SCI_CETCARETFORE</code>.</p>
	<h3 id="SCI_SETCARETLINEVISIBLE">SCI_SETCARETLINEVISIBLE(bool show)<br />
     <span id="SCI_GETCARETLINEVISIBLE">SCI_GETCARETLINEVISIBLE</span><br />
     <span id="SCI_SETCARETLINEBACK">SCI_SETCARETLINEBACK(int <a class="jump"
    href="#colour">colour</a>)</span><br />
     <span id="SCI_GETCARETLINEBACK">SCI_GETCARETLINEBACK</span></h3>
    <p>キャレットのある行に対して特別に背景色を設定できます。<code>SCI_SETCARETLINEBACK</code> で背景色を設定し、次に <code>SCI_SETCARETLINEVISIBLE(true)</code> というコードで有効にします。<code>SCI_SETCARETLINEVISIBLE(false)</code> というコードで無効になります。<code>SCI_GETCARET*</code> の二関数は状態と色を返します。他の印付けによって背景色が変更されていても、この形による背景色は最も高い優先度を持っています。</p>
    <p class="eng"><b>SCI_SETCARETLINEVISIBLE(bool show)</b><br />
     <b>SCI_GETCARETLINEVISIBLE</b><br />
     <b>SCI_SETCARETLINEBACK(int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b>SCI_GETCARETLINEBACK</b><br />
     You can choose to make the background colour of the line containing the caret different with
    these messages. To do this, set the desired background colour with
    <code>SCI_SETCARETLINEBACK</code>, then use <code>SCI_SETCARETLINEVISIBLE(true)</code> to
    enable the effect. You can cancel the effect with <code>SCI_SETCARETLINEVISIBLE(false)</code>.
    The two <code>SCI_GETCARET*</code> functions return the state and the colour. This form of
    background colouring has highest priority when a line has markers that would otherwise change
    the background colour.</p>
	<h3 id="SCI_SETCARETPERIOD">SCI_SETCARETPERIOD(int milliseconds)<br />
     <span id="SCI_GETCARETPERIOD">SCI_GETCARETPERIOD</span></h3>
    <p>キャレットの点滅間隔は <code>SCI_SETCARETPERIOD</code> で設定します。時間はミリ秒単位で、指定時間毎に表示と非表示を繰り返します。0 を指定すると点滅を行いません。標準値は 500 ミリ秒です。<br /><code>SCI_GETCARETPERIOD</code> で現在の値を取得できます。</p>
    <p class="eng"><b>SCI_SETCARETPERIOD(int milliseconds)</b><br />
     <b>SCI_GETCARETPERIOD</b><br />
     The rate at which the caret blinks can be set with <code>SCI_SETCARETPERIOD</code> which
    determines the time in milliseconds that the caret is visible or invisible before changing
    state. Setting the period to 0 stops the caret blinking. The default value is 500 milliseconds.
    <code>SCI_GETCARETPERIOD</code> returns the current setting.</p>
	<h3 id="SCI_SETCARETWIDTH">SCI_SETCARETWIDTH(int pixels)<br /><span id="SCI_GETCARETWIDTH">SCI_GETCARETWIDTH</span></h3>
    <p><code>SCI_SETCARETWIDTH</code> によって、キャレット自身の幅を 0 〜 3 ピクセルのいずれかに変更できます。標準値は 1 ピクセルです。<code>SCI_GETCARETWIDTH</code> で現在の設定を取得することができます。0 はキャレットが見えなくなることを意味します。</p>
    <p class="eng"><b>SCI_SETCARETWIDTH(int pixels)</b><br />
     <b>SCI_GETCARETWIDTH</b><br />
     The width of the caret can be set with <code>SCI_SETCARETWIDTH</code> to a value of 0, 1, 2 or
    3 pixels. The default width is 1 pixel. You can read back the current width with
    <code>SCI_GETCARETWIDTH</code>. A width of 0 makes the caret invisible (added at version
    1.50).</p>
	<h3 id="SCI_SETHOTSPOTACTIVEFORE">SCI_SETHOTSPOTACTIVEFORE(bool useHotSpotForeColour, int <a class="jump"
    href="#colour">colour</a>)<br />
     <span id="SCI_SETHOTSPOTACTIVEBACK">SCI_SETHOTSPOTACTIVEBACK(bool useHotSpotBackColour, int <a class="jump"
    href="#colour">colour</a>)</span><br />
     <span id="SCI_SETHOTSPOTACTIVEUNDERLINE">SCI_SETHOTSPOTACTIVEUNDERLINE(bool underline,)</span><br />
     <span id="SCI_SETHOTSPOTSINGLELINE">SCI_SETHOTSPOTSINGLELINE(bool singleLine,)</span></h3>
    <p>カーソルがホットスポット属性の修飾を受けているテキスト上にあるとき、標準の色づけを変更して下線を引くことができます。単線モードは行クリップをまたいでホットスポットを続けることを抑制します。</p>
    <p class="eng"><b>SCI_SETHOTSPOTACTIVEFORE(bool useHotSpotForeColour, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b>SCI_SETHOTSPOTACTIVEBACK(bool useHotSpotBackColour, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b>SCI_SETHOTSPOTACTIVEUNDERLINE(bool underline,)</b><br />
     <b>SCI_SETHOTSPOTSINGLELINE(bool singleLine,)</b><br />
     While the cursor hovers over text in a style with the hotspot attribute set,
     the default colouring can be modified and an underline drawn with these settings.
     Single line mode stops a hotspot from wrapping onto next line.</p>
	<h3 id="SCI_SETCONTROLCHARSYMBOL">SCI_SETCONTROLCHARSYMBOL(int symbol)<br />
     <span id="SCI_GETCONTROLCHARSYMBOL">SCI_GETCONTROLCHARSYMBOL</span></h3>
    <p>Scintilla は標準設定では制御文字(文字コードが32未満のもの)を角の丸い四角に ASCII による略号で表示します。これらの略号はコンピュータ黎明期の信号からきたもので、一部は現在も利用されています。LF = Line Feed(改行), BS = Back Space(後退), CR =
    Carriage Return (復帰)などです。次のものが表示されます。"NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
    "BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI", "DLE", "DC1", "DC2", "DC3", "DC4", "NAK",
    "SYN", "ETB", "CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US".</p>
    <p class="eng"><b>SCI_SETCONTROLCHARSYMBOL(int symbol)</b><br />
     <b>SCI_GETCONTROLCHARSYMBOL</b><br />
     By default, Scintilla displays control characters (characters with codes less than 32) in a
    rounded rectangle as ASCII mnemonics: "NUL", "SOH", "STX", "ETX", "EOT", "ENQ", "ACK", "BEL",
    "BS", "HT", "LF", "VT", "FF", "CR", "SO", "SI", "DLE", "DC1", "DC2", "DC3", "DC4", "NAK",
    "SYN", "ETB", "CAN", "EM", "SUB", "ESC", "FS", "GS", "RS", "US". These mnemonics come from the
    early days of signaling, though some are still used (LF = Line Feed, BS = Back Space, CR =
    Carriage Return, for example).</p>

    <p>これらの略号を表示する代わりに、32〜255までのアスキーコードを指定して表示させることができます。指定値が 32 未満の場合、上記の略号が表示されます。設定した符号はその文字の修飾集合におけるフォントで表示されます。現在の指定値は <code>SCI_GETCONTROLCHARSYMBOL</code> で取得できます。標準値は 0 です。</p>
    <p class="eng">You can choose to replace these mnemonics by a nominated symbol with an ASCII code in the
    range 32 to 255. If you set a symbol value less than 32, all control characters are displayed
    as mnemonics. The symbol you set is rendered in the font of the style set for the character.
    You can read back the current symbol with the <code>SCI_GETCONTROLCHARSYMBOL</code> message.
    The default symbol value is 0.</p>

    <h2 id="Margins"><span>余白</span><span class="eng">Margins</span></h2>

    <p>テキスト表示の左側には最大三つの余白が存在します。加えて、テキスト表示の上下左右に空間ができます。<a
    class="message" href="#SCI_SETMARGINTYPEN"><code>SCI_SETMARGINTYPEN</code></a> によって、余白の各々は記号や行番号を表示するよう指定できます。余白毎に表示できる目印は <a class="message"
    href="#SCI_SETMARGINMASKN"><code>SCI_SETMARGINMASKN</code></a> で設定できます。可視状態の余白に関係づけられていない目印はテキストの背景色変更のように表示されます。ピクセル単位で余白毎の幅を設定できます。幅が 0 の余白は完全に無視されます。余白でマウスをクリックしたときの動作は <a class="message"
    href="#SCN_MARGINCLICK"><code>SCN_MARGINCLICK</code></a> でコンテナへの通知かテキスト一行の選択かを決めることができます。</p>
    <p class="eng">There may be up to three margins to the left of the text display, plus a gap either side of
    the text. Each margin can be set to display either symbols or line numbers with <a
    class="message" href="#SCI_SETMARGINTYPEN"><code>SCI_SETMARGINTYPEN</code></a>. The markers
    that can be displayed in each margin are set with <a class="message"
    href="#SCI_SETMARGINMASKN"><code>SCI_SETMARGINMASKN</code></a>. Any markers not associated with
    a visible margin will be displayed as changes in background colour in the text. A width in
    pixels can be set for each margin. Margins with a zero width are ignored completely. You can
    choose if a mouse click in a margin sends a <a class="message"
    href="#SCN_MARGINCLICK"><code>SCN_MARGINCLICK</code></a> notification to the container or
    selects a line of text.</p>

    <p>各余白は 0 〜 2 の番号が付けられています。これ以外の余白番号は意味を持ちません。標準では余白番号 0  は行番号を表示するようになっていますが、幅が 0 なので表示されていません。余白番号 1 は折りたたまれて「いない」符号を表示します。16 ピクセルの幅がありますので表示されています。余白 2 は折りたたみを示す符号を表示しますが幅は 0 になっています。これら各余白の幅は変更ができます。</p>
    <p class="eng">The margins are numbered 0 to 2. Using a margin number outside the valid range has no
    effect. By default, margin 0 is set to display line numbers, but is given a width of 0, so it
    is hidden. Margin 1 is set to display non-folding symbols and is given a width of 16 pixels, so
    it is visible. Margin 2 is set to display the folding symbols, but is given a width of 0, so it
    is hidden. Of course, you can set the margins to be whatever you wish.</p>
    <code><a class="message" href="#SCI_SETMARGINTYPEN">SCI_SETMARGINTYPEN(int margin, int
    type)</a><br />
     <a class="message" href="#SCI_GETMARGINTYPEN">SCI_GETMARGINTYPEN(int margin)</a><br />
     <a class="message" href="#SCI_SETMARGINWIDTHN">SCI_SETMARGINWIDTHN(int margin, int
    pixelWidth)</a><br />
     <a class="message" href="#SCI_GETMARGINWIDTHN">SCI_GETMARGINWIDTHN(int margin)</a><br />
     <a class="message" href="#SCI_SETMARGINMASKN">SCI_SETMARGINMASKN(int margin, int
    mask)</a><br />
     <a class="message" href="#SCI_GETMARGINMASKN">SCI_GETMARGINMASKN(int margin)</a><br />
     <a class="message" href="#SCI_SETMARGINSENSITIVEN">SCI_SETMARGINSENSITIVEN(int margin, bool
    sensitive)</a><br />
     <a class="message" href="#SCI_GETMARGINSENSITIVEN">SCI_GETMARGINSENSITIVEN(int
    margin)</a><br />
     <a class="message" href="#SCI_SETMARGINLEFT">SCI_SETMARGINLEFT(&lt;unused&gt;, int
    pixels)</a><br />
     <a class="message" href="#SCI_GETMARGINLEFT">SCI_GETMARGINLEFT</a><br />
     <a class="message" href="#SCI_SETMARGINRIGHT">SCI_SETMARGINRIGHT(&lt;unused&gt;, int
    pixels)</a><br />
     <a class="message" href="#SCI_GETMARGINRIGHT">SCI_GETMARGINRIGHT</a><br />
     <a class="message" href="#SCI_SETFOLDMARGINCOLOUR">SCI_SETFOLDMARGINCOLOUR(bool useSetting, int colour)</a><br />
     <a class="message" href="#SCI_SETFOLDMARGINHICOLOUR">SCI_SETFOLDMARGINHICOLOUR(bool useSetting, int colour)</a><br />
    </code>
	<h3 id="SCI_SETMARGINTYPEN">SCI_SETMARGINTYPEN(int margin, int iType)<br />
     <span id="SCI_GETMARGINTYPEN">SCI_GETMARGINTYPEN(int margin)</span></h3>
    <p>余白の種別を設定あるいは取得します。引数 margin は 0, 1, 2 のいずれかであるべきです。定義済み定数 <code>SC_MARGIN_SYMBOL</code> (0) と <code>SC_MARGIN_NUMBER</code> (1) で符号用余白か行番号表示余白かを設定できます。便宜的に余白番号 0 には行番号が、残りの二つには符号が割り当てられます。</p>
    <p class="eng"><b>SCI_SETMARGINTYPEN(int margin, int iType)</b><br />
     <b>SCI_GETMARGINTYPEN(int margin)</b><br />
     These two routines set and get the type of a margin. The margin argument should be 0, 1 or 2.
    You can use the predefined constants <code>SC_MARGIN_SYMBOL</code> (0) and
    <code>SC_MARGIN_NUMBER</code> (1) to set a margin as either a line number or a symbol margin.
    By convention, margin 0 is used for line numbers and the other two are used for symbols.</p>
	<h3 id="SCI_SETMARGINWIDTHN">SCI_SETMARGINWIDTHN(int margin, int pixelWidth)<br />
     <span id="SCI_GETMARGINWIDTHN">SCI_GETMARGINWIDTHN(int margin)</span></h3>
    <p>余白幅をピクセル単位で設定もしくは取得します。幅 0 の余白は見えなくなります。標準では Scintilla は余白番号 1 に符号用の 16 ピクセルを与えていますので大きさの参考にしてください。行番号用の余白幅は文書内の行数と行番号装飾を考慮すべきです。<a class="message"
    href="#SCI_TEXTWIDTH"><code>SCI_TEXTWIDTH(STYLE_LINENUMBER, "_99999")</code></a> といったコードで適切な幅を得られます。</p>
    <p class="eng"><b>SCI_SETMARGINWIDTHN(int margin, int pixelWidth)</b><br />
     <b>SCI_GETMARGINWIDTHN(int margin)</b><br />
     These routines set and get the width of a margin in pixels. A margin with zero width is
    invisible. By default, Scintilla sets margin 1 for symbols with a width of 16 pixels, so this
    is a reasonable guess if you are not sure what would be appropriate. Line number margins widths
    should take into account the number of lines in the document and the line number style. You
    could use something like <a class="message"
    href="#SCI_TEXTWIDTH"><code>SCI_TEXTWIDTH(STYLE_LINENUMBER, "_99999")</code></a> to get a
    suitable width.</p>
	<h3 id="SCI_SETMARGINMASKN">SCI_SETMARGINMASKN(int margin, int mask)<br />
     <span id="SCI_GETMARGINMASKN">SCI_GETMARGINMASKN(int margin)</span></h3>
    <p>mask は 32 ビットの値で、各ビットが 32 種の論理記号に対応しています。論理記号は符号として余白に表示できるものです。折りたたみを示すことに使われる 7 つの論理記号をマスクするために <code>SC_MASK_FOLDERS</code> (0xFE000000,十進 -33554432) という定数があります。広範囲の符号と色を 32 種の論理記号の各々に割り当てることができます。<a href="#Markers">目印</a>を参考にしてください。<code>(mask
    &amp; SC_MASK_FOLDERS)==0</code> である場合は余白の背景色は装飾番号 33 (<a
    class="message" href="#StyleDefinition"><code>STYLE_LINENUMBER</code></a>)で制御されています。</p>
    <p class="eng"><b>SCI_SETMARGINMASKN(int margin, int mask)</b><br />
     <b>SCI_GETMARGINMASKN(int margin)</b><br />
     The mask is a 32-bit value. Each bit corresponds to one of 32 logical symbols that can be
    displayed in a margin that is enabled for symbols. There is a useful constant,
    <code>SC_MASK_FOLDERS</code> (0xFE000000 or -33554432), that is a mask for the 7 logical
    symbols used to denote folding. You can assign a wide range of symbols and colours to each of
    the 32 logical symbols, see <a href="#Markers">Markers</a> for more information. If <code>(mask
    &amp; SC_MASK_FOLDERS)==0</code>, the margin background colour is controlled by style 33 (<a
    class="message" href="#StyleDefinition"><code>STYLE_LINENUMBER</code></a>).</p>

    <p><a class="message"
    href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a> により、行に対して論理上の目印を加えることができます。可視余白のマスクには現れない目印を持つ行はその行の背景色を変更します。例えば文法エラーのある行に論理番号 10 の目印を使い、背景色を変える場合を考えます。この目印に対するマスクは 0x400 ( 1 &lt;&lt; 10, 1 を左に10回シフトした値 )です。符号余白のいずれもマスクに 0x400 を含んでいなければ、この目印を持つ行の背景色が変更されます。</p>
    <p class="eng">You add logical markers to a line with <a class="message"
    href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a>. If a line has an associated marker that
    does not appear in the mask of any margin with a non-zero width, the marker changes the
    background colour of the line. For example, suppose you decide to use logical marker 10 to mark
    lines with a syntax error and you want to show such lines by changing the background colour.
    The mask for this marker is 1 shifted left 10 times (1&lt;&lt;10) which is 0x400. If you make
    sure that no symbol margin includes 0x400 in its mask, any line with the marker gets the
    background colour changed.</p>

    <p>余白1 に折りたたみ情報以外を設定するときは <code>SCI_SETMARGINMASKN(1, ~SC_MASK_FOLDERS)</code>,  余白 2 に折りたたみ情報余白を設定するときは <code>SCI_SETMARGINMASKN(2, SC_MASK_FOLDERS)</code> といったコードを使います。これらは Scintilla の標準設定となっています。<code>~SC_MASK_FOLDERS</code> は 0x1FFFFFF ( 十進 33554431 ) です。余白に 32 種すべての符号を表示する必要がある場合は <code>SCI_SETMARGINMASKN(余白番号, -1)</code> というコードを使ってください。</p>
    <p class="eng">To set a non-folding margin 1 use <code>SCI_SETMARGINMASKN(1, ~SC_MASK_FOLDERS)</code>; to
    set a folding margin 2 use <code>SCI_SETMARGINMASKN(2, SC_MASK_FOLDERS)</code>. This is the
    default set by Scintilla. <code>~SC_MASK_FOLDERS</code> is 0x1FFFFFF in hexadecimal or 33554431
    decimal. Of course, you may need to display all 32 symbols in a margin, in which case use
    <code>SCI_SETMARGINMASKN(margin, -1)</code>.</p>
	<h3 id="SCI_SETMARGINSENSITIVEN">SCI_SETMARGINSENSITIVEN(int margin, bool
    sensitive)</h3>
    <p>三つの各余白がマウスボタンクリックに反応するかどうかを定めます。反応する設定の余白でクリックすると、そのコンテナに <a class="message"
    href="#SCN_MARGINCLICK"><code>SCN_MARGINCLICK</code></a> <a class="jump"
    href="#Notifications">通知</a> が送信されます。反応しない設定の余白は選択範囲設定用余白として動作します。これは行単位で選択するのに便利です。標準ではどの余白もクリックに反応しない設定になっています。</p>
    <p class="eng"><b>SCI_SETMARGINSENSITIVEN(int margin, bool
    sensitive)</b><br />
     <b id="SCI_GETMARGINSENSITIVEN">SCI_GETMARGINSENSITIVEN(int margin)</b><br />
     Each of the three margins can be set sensitive or insensitive to mouse clicks. A click in a
    sensitive margin sends a <a class="message"
    href="#SCN_MARGINCLICK"><code>SCN_MARGINCLICK</code></a> <a class="jump"
    href="#Notifications">notification</a> to the container. Margins that are not sensitive act as
    selection margins which make it easy to select ranges of lines. By default, all margins are
    insensitive.</p>
	<h3 id="SCI_SETMARGINLEFT">SCI_SETMARGINLEFT(&lt;unused&gt;, int pixels)<br />
     <span id="SCI_GETMARGINLEFT">SCI_GETMARGINLEFT</span><br />
     <span id="SCI_SETMARGINRIGHT">SCI_SETMARGINRIGHT(&lt;unused&gt;, int pixels)</span><br />
     <span id="SCI_GETMARGINRIGHT">SCI_GETMARGINRIGHT</span></h3>
    <p>テキスト部左右の余白幅を設定あるいは取得します。標準設定は左右とも 1 ピクセルです。</p>
    <p class="eng"><b id="SCI_SETMARGINLEFT">SCI_SETMARGINLEFT(&lt;unused&gt;, int pixels)</b><br />
     <b id="SCI_GETMARGINLEFT">SCI_GETMARGINLEFT</b><br />
     <b id="SCI_SETMARGINRIGHT">SCI_SETMARGINRIGHT(&lt;unused&gt;, int pixels)</b><br />
     <b id="SCI_GETMARGINRIGHT">SCI_GETMARGINRIGHT</b><br />
     These messages set and get the width of the blank margin on both sides of the text in pixels.
    The default is to one pixel on each side.</p>
	<h3 id="SCI_SETFOLDMARGINCOLOUR">SCI_SETFOLDMARGINCOLOUR(bool useSetting, int colour)<br />
     <span id="SCI_SETFOLDMARGINHICOLOUR">SCI_SETFOLDMARGINHICOLOUR(bool useSetting, int colour)</span></h3>
    <p>折りたたみ余白の通常と強調時の色に関する変更ができます。Windows においての標準は ::GetSysColor(COLOR_3DFACE), 強調色が ::GetSysColor(COLOR_3DHIGHLIGHT) になっています。</p>
    <p class="eng"><b id="SCI_SETFOLDMARGINCOLOUR">SCI_SETFOLDMARGINCOLOUR(bool useSetting, int colour)</b><br />
     <b id="SCI_SETFOLDMARGINHICOLOUR">SCI_SETFOLDMARGINHICOLOUR(bool useSetting, int colour)</b><br />
     These messages allow changing the colour of the fold margin and fold margin highlight.
     On Windows the fold margin colour defaults to ::GetSysColor(COLOR_3DFACE) and the fold margin highlight
     colour to ::GetSysColor(COLOR_3DHIGHLIGHT).</p>

    <h2 id="OtherSettings"><span>その他の設定</span><span class="eng">Other settings</span></h2>
    <code><a class="message" href="#SCI_SETUSEPALETTE">SCI_SETUSEPALETTE(bool
    allowPaletteUse)</a><br />
     <a class="message" href="#SCI_GETUSEPALETTE">SCI_GETUSEPALETTE</a><br />
     <a class="message" href="#SCI_SETBUFFEREDDRAW">SCI_SETBUFFEREDDRAW(bool isBuffered)</a><br />
     <a class="message" href="#SCI_GETBUFFEREDDRAW">SCI_GETBUFFEREDDRAW</a><br />
     <a class="message" href="#SCI_SETTWOPHASEDRAW">SCI_SETTWOPHASEDRAW(bool twoPhase)</a><br />
     <a class="message" href="#SCI_GETTWOPHASEDRAW">SCI_GETTWOPHASEDRAW</a><br />
     <a class="message" href="#SCI_SETCODEPAGE">SCI_SETCODEPAGE(int codePage)</a><br />
     <a class="message" href="#SCI_GETCODEPAGE">SCI_GETCODEPAGE</a><br />
     <a class="message" href="#SCI_SETWORDCHARS">SCI_SETWORDCHARS(&lt;unused&gt;, const char
    *chars)</a><br />
     <a class="message" href="#SCI_SETWHITESPACECHARS">SCI_SETWHITESPACECHARS(&lt;unused&gt;, const char
    *chars)</a><br />
     <a class="message" href="#SCI_SETCHARSDEFAULT">SCI_SETCHARSDEFAULT</a><br />
     <a class="message" href="#SCI_GRABFOCUS">SCI_GRABFOCUS</a><br />
     <a class="message" href="#SCI_SETFOCUS">SCI_SETFOCUS(bool focus)</a><br />
     <a class="message" href="#SCI_GETFOCUS">SCI_GETFOCUS</a><br />
    </code>
	<h3 id="SCI_SETUSEPALETTE">SCI_SETUSEPALETTE(bool allowPaletteUse)<br />
     <span id="SCI_GETUSEPALETTE">SCI_GETUSEPALETTE</span></h3>
    <p>同時に 256 色しか表示できない8 ビットの表示装置では、表示環境がパレットを用いてアプリケーションの色要求を仲裁します。GTK+ では Scintilla は常にパレットを使います。</p>
    <p class="eng"><b id="SCI_SETUSEPALETTE">SCI_SETUSEPALETTE(bool allowPaletteUse)</b><br />
     <b id="SCI_GETUSEPALETTE">SCI_GETUSEPALETTE</b><br />
     On 8 bit displays, which can only display a maximum of 256 colours, the graphics environment
    mediates between the colour needs of applications through the use of palettes. On GTK+,
    Scintilla always uses a palette.</p>

    <p>Windows でこのようなパレットを使うとアプリケーションを切り替える際に視覚的な発光の問題が起こります。これは Scintilla コントロールを保持するアプリケーションにおいて、いくつかの Scintilla メッセージを転送してパレットコードをうまく動作させるために必要なものです。標準ではパレットは使われず、使う場合はアプリケーションが Scintilla にそのことを通知しなくてはなりません。Scintilla がパレットを使わない場合はすでに使用可能な色を単に表示します。この色はしばしば Windows のシステム色 20 色が使われます。。</p>
    <p class="eng">On Windows, there are some problems with visual flashing when switching between applications
    with palettes and it is also necessary for the application containing the Scintilla control to
    forward some messages to Scintilla for its palette code to work. Because of this, by default,
    the palette is not used and the application must tell Scintilla to use one. If Scintilla is not
    using a palette, it will only display in those colours already available, which are often the
    20 Windows system colours.</p>

    <p>Scintilla がどのようにしてパレットを利用可能にしているかについては、SciTE で <code>WM_PALETTECHANGED</code>, <code>WM_QUERYNEWPALETTE</code>, <code>SCI_SETUSEPALETTE</code> を検索してください。転送すべき Windows メッセージは次の通りです。<br />
     <code>WM_SYSCOLORCHANGE</code>, <code>WM_PALETTECHANGED</code>,
    <code>WM_QUERYNEWPALETTE</code> (<code>TRUE</code> を返すべき).</p>
    <p class="eng">To see an example of how to enable palette support in Scintilla, search the text of SciTE
    for <code>WM_PALETTECHANGED</code>, <code>WM_QUERYNEWPALETTE</code> and
    <code>SCI_SETUSEPALETTE</code>. The Windows messages to forward are:<br />
     <code>WM_SYSCOLORCHANGE</code>, <code>WM_PALETTECHANGED</code>,
    <code>WM_QUERYNEWPALETTE</code> (should return <code>TRUE</code>).</p>

    <p><code>(WM_XXXX, WPARAM, LPARAM)</code> を Scintilla に転送するには <code>SendMessage(hScintilla, WM_XXXX, WPARAM, LPARAM)</code> というコードが使えます。hScintilla は Scintilla ウィンドウを作ったときに返されるそのウィンドウへのハンドルです。</p>
    <p class="eng">To forward a message <code>(WM_XXXX, WPARAM, LPARAM)</code> to Scintilla, you can use
    <code>SendMessage(hScintilla, WM_XXXX, WPARAM, LPARAM)</code> where <code>hScintilla</code> is
    the handle to the Scintilla window you created as your editor.</p>

    <p>Windows のメッセージを転送する状況にある間、トップレベルウィンドウはすべての <code>WM_SETTINGCHANGE</code> メッセージを Scintilla に送らなくてはなりません。このメッセージは現在マウス設定の正確な変更に使われていますが、将来別のユーザインタフェイス部品のために使われる可能性があります。</p>
    <p class="eng">While we are on the subject of forwarding messages in Windows, the top level window should
    forward any <code>WM_SETTINGCHANGE</code> messages to Scintilla (this is currently used to
    collect changes to mouse settings, but could be used for other user interface items in the
    future).</p>
	<h3 id="SCI_SETBUFFEREDDRAW">SCI_SETBUFFEREDDRAW(bool isBuffered)<br />
     <span id="SCI_GETBUFFEREDDRAW">SCI_GETBUFFEREDDRAW</span></h3>
    <p>描画バッファを使うかどうかの設定と現在状態の取得を行います。描画バッファを用いると、各行毎に直接画面に描画するのではなくいったんパッファに書き込みを行い、その後画面に複製を行います。バッファを使うとちらつきが抑えられますが処理速度は落ちます。初期状態ではバッファを使います。</p>
    <p class="eng"><b>SCI_SETBUFFEREDDRAW(bool isBuffered)</b><br />
     <b>SCI_GETBUFFEREDDRAW</b><br />
     These messages turn buffered drawing on or off and report the buffered drawing state. Buffered
    drawing draws each line into a bitmap rather than directly to the screen and then copies the
    bitmap to the screen. This avoids flickering although it does take longer. The default is for
    drawing to be buffered.</p>
	<h3 id="SCI_SETTWOPHASEDRAW">SCI_SETTWOPHASEDRAW(bool twoPhase)<br />
     <span id="SCI_GETTWOPHASEDRAW">SCI_GETTWOPHASEDRAW</span></h3>
    <p>テキストの二段階描画はよりきれいになりますが処理速度は落ちます。単段階描画では同じ装飾を受ける一連の文字を背景とともに描画します。その一続きの最後の文字が次の文字にかかるような場合、具体的には "<i>V</i>_" のように "<i>V</i>" が 異なる装飾の "_" の直前に来るような場合、"<i>V</i>" の右半分は "_" の背景色に塗りつぶされて切れてしまいます。二段階描画では、この現象を避けるためにまず背景色をすべて処理してしまい、その上から文字を背景透過指定で描画します。二段階描画を描画バッファなしで用いると単段階描画よりもちらつきが大きくなります。初期状態では二段階描画になっています。</p>
    <p class="eng"><b>SCI_SETTWOPHASEDRAW(bool twoPhase)</b><br />
     <b>SCI_GETTWOPHASEDRAW</b><br />
     Two phase drawing is a better but slower way of drawing text.
     In single phase drawing each run of characters in one style is drawn along with its background.
     If a character overhangs the end of a run, such as in "<i>V</i>_" where the
     "<i>V</i>" is in a different style from the "_", then this can cause the right hand
     side of the "<i>V</i>" to be overdrawn by the background of the "_" which
     cuts it off. Two phase drawing
     fixes this by drawing all the backgrounds first and then drawing the text in
     transparent mode. Two phase drawing may flicker more than single phase
     unless buffered drawing is on. The default is for drawing to be two phase.</p>
	<h3 id="SCI_SETCODEPAGE">SCI_SETCODEPAGE(int codePage)<br />
     <span id="SCI_GETCODEPAGE">SCI_GETCODEPAGE</span></h3>
    <p>Scintilla は日本語・中国語・韓国語の DBCS に対応しています。<code>codePage</code> にコードページを指定すると Scintilla はダブルバイト文字を一文字として扱うように保証されます。キャレットはダブルバイト文字を割るような位置には来なくなります。 <code>codePage</code> に 0 を指定すると DBCS 対応は無効となります。初期状態では <code>SCI_SETCODEPAGE(0)</code> です。</p>
    <p class="eng"><b>SCI_SETCODEPAGE(int codePage)</b><br />
     <b>SCI_GETCODEPAGE</b><br />
     Scintilla has some support for Japanese, Chinese and Korean DBCS. Use this message with
    <code>codePage</code> set to the code page number to set Scintilla to use code page information
    to ensure double byte characters are treated as one character rather than two. This also stops
    the caret from moving between the two bytes in a double byte character. Call with
    <code>codePage</code> set to zero to disable DBCS support. The default is
    <code>SCI_SETCODEPAGE(0)</code>.</p>

    <p><code>SC_CP_UTF8</code> (65001) というコードページは Scintilla を Unicode モードにして文書を UTF-8 で書かれた文字の流れとして扱います。テキストは描画される前にその環境における通常の Unicode エンコーディングを通して変換されます。この結果ヘブライ語・アラビア語・キリル語・漢字を表示できるようになります。二文字が一行の中で縦に並ぶことがあるタイ語のような言語でもほぼ動作しますが、このような文字が分離して視覚的に異常な表示になる問題があります。双方向テキストは未対応です。</p>
    <p class="eng">Code page <code>SC_CP_UTF8</code> (65001) sets Scintilla into Unicode mode with the document
    treated as a sequence of characters expressed in UTF-8. The text is converted to the platform's
    normal Unicode encoding before being drawn by the OS and thus can display Hebrew, Arabic,
    Cyrillic, and Han characters. Languages which can use two characters stacked vertically in one
    horizontal space, such as Thai, will mostly work but there are some issues where the characters
    are drawn separately leading to visual glitches. Bi-directional text is not supported.</p>

    <p>Windows ではコードページに 932(日本語 Shift-JIS), 936 (簡体中文 GBK), 
    949 (韓国語), and 950 (繁体中文 Big5) を設定できます。ただし、言語依存の実装が環境側に要求される可能性があります。</p>
    <p class="eng">On Windows, code page can be set to 932 (Japanese Shift-JIS), 936 (Simplified Chinese GBK), 
    949 (Korean), and 950 (Traditional Chinese Big5) although these may require installation of language 
    specific support.</p>

    <p>GTK+ では <code>SC_CP_DBCS</code> (1) を指定することで Scintilla を多バイト文字モードにすることができます。日本語 EUC のようなものの処理に使われます。</p>
    <p class="eng">On GTK+, code page <code>SC_CP_DBCS</code> (1) sets Scintilla into
    multi byte character mode as is required for Japanese language processing with
    the EUC encoding.</p>

    <p>GTK+ では、ロケールは <code>setlocale(LC_CTYPE, "en_US.UTF-8")</code> といったコードで Unicode に設定されなくてはなりません。<code>"iso10646"</code> レジストリにあるフォントがフォント集合の中で用いられます。フォント集合はコンマで区切られた部分フォント仕様の一覧で、各々のフォント仕様は次のいずれかになります。<br /><code>foundry-fontface-charsetregistry-encoding</code>, <br />
    <code>fontface-charsetregistry-encoding</code>, <br /><code>foundry-fontface</code>, <br />
    <code>fontface</code><br />例えば <code>"misc-fixed-iso10646-1,*"</code> という形になります。</p>
    <p class="eng">For GTK+, the locale should be set to a Unicode locale with a call similar to
    <code>setlocale(LC_CTYPE, "en_US.UTF-8")</code>. Fonts with an <code>"iso10646"</code> registry
    should be used in a font set. Font sets are a comma separated list of partial font
    specifications where each partial font specification can be in the form:
    <code>foundry-fontface-charsetregistry-encoding</code> or
    <code>fontface-charsetregistry-encoding</code> or <code>foundry-fontface</code> or
    <code>fontface</code>. An example is <code>"misc-fixed-iso10646-1,*"</code>.</p>

    <p><code>codePage</code>を  <code>SC_CP_UTF8</code> でも 0 でもない値にした場合の動作は OS に依存します。</p>
    <p class="eng">Setting <code>codePage</code> to a non-zero value that is not <code>SC_CP_UTF8</code> is
    operating system dependent.</p>
	<h3 id="SCI_SETWORDCHARS">SCI_SETWORDCHARS(&lt;unused&gt;, const char *chars)</h3>
    <p>Scintilla は単語単位の処理を行う関数をいくつか保有しています。単語は特定の文字集合からの文字列のひとつながりで構成されます。どれを単語を構成する文字とみなすかを設定することができます。文字集合は指定されるまでは標準値を保持しています。<br />例えば、'_' を文字集合の一部とみなしたくない場合は次のようなコードを使います。<br /><code>SCI_SETWORDCHARS(0, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")</code>;</p>
    <p class="eng"><b>SCI_SETWORDCHARS(&lt;unused&gt;, const char *chars)</b><br />
     Scintilla has several functions that operate on words, which are defined to be contiguous
    sequences of characters from a particular set of characters. This message defines which
    characters are members of that set. The character sets are set to default values before processing this
    function.
    For example, if you don't allow '_' in your set of characters
    use:<br />
     <code>SCI_SETWORDCHARS(0, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")</code>;</p>
	<h3 id="SCI_SETWHITESPACECHARS">SCI_SETWHITESPACECHARS(&lt;unused&gt;, const char *chars)</h3>
    <p><code>SCI_SETWORDCHARS</code> と似ていますが、こちらはどの文字をホワイトスペースとみなすかを設定します。ホワイトスペース文字を指定することで Scintilla はユーザに最適のキャレット移動性能を持たせることができます。単語の先頭や末尾への移動などです。例えば、句読点文字をホワイトスペースと定義すると、Ctrl を押しながら左右矢印キーを入力したときに通過されます。この関数は <code>SCI_SETWORDCHARS</code> の後に呼び出されるべきです。<code>SCI_SETWORDCHARS</code> はホワイトスペースの設定を初期状態に戻してしまいます。</p>
    <p class="eng"><b id="SCI_SETWHITESPACECHARS">SCI_SETWHITESPACECHARS(&lt;unused&gt;, const char *chars)</b><br />
     Similar to <code>SCI_SETWORDCHARS</code>, this message allows the user to define which chars Scintilla considers
	as whitespace.  Setting the whitespace chars allows the user to fine-tune Scintilla's behaviour doing
	such things as moving the cursor to the start or end of a word; for example, by defining punctuation chars
	as whitespace, they will be skipped over when the user presses ctrl+left or ctrl+right.
	This function should be called after <code>SCI_SETWORDCHARS</code> as it will
	reset the whitespace characters to the default set.</p>
	<h3 id="SCI_SETCHARSDEFAULT">SCI_SETCHARSDEFAULT</h3>
    <p>単語とホワイトスペースを標準設定をに戻します。空白・タブ文字・コードが 0x20 未満の文字をホワイトスペース、英数字と '_' を単語に使用される文字と考えるようになります。</p>
    <p class="eng"><b>SCI_SETCHARSDEFAULT</b><br />
     Use the default sets of word and whitespace characters. This sets whitespace to space, tab and other
     characters with codes less than 0x20, with word characters set to alphanumeric and '_'.
    </p>

<h3 id="SCI_GRABFOCUS">SCI_GRABFOCUS<br />
     <span id="SCI_SETFOCUS">SCI_SETFOCUS(bool focus)</span><br />
     <span id="SCI_GETFOCUS">SCI_GETFOCUS</span></h3>
    <p>GTK+ は Windows よりもフォーカスの制御が少し複雑です。Scintilla はこのメッセージでフォーカスを変えることができます。</p>
    <p class="eng"><b id="SCI_GRABFOCUS">SCI_GRABFOCUS</b><br />
     <b id="SCI_SETFOCUS">SCI_SETFOCUS(bool focus)</b><br />
     <b id="SCI_GETFOCUS">SCI_GETFOCUS</b><br />
     On GTK+, focus handling is more complicated than on Windows, so Scintilla can be told with
    this message to grab the focus.</p>

    <p>内部フォーカスフラグは <code>SCI_SETFOCUS</code> で設定することができます。複雑なフォーカス要求を持つクライアントで使われます。自身が実際のフォーカスを持っていながら、Scintilla が論理的なフォーカスを持っているように示さなくてはならない場合などデス。</p>
    <p class="eng">The internal focus flag can be set with <code>SCI_SETFOCUS</code>. This is used by clients
    that have complex focus requirements such as having their own window that gets the real focus
    but with the need to indicate that Scintilla has the logical focus.</p>

    <h2 id="BraceHighlighting"><span>括弧の強調</span><span class="eng">Brace highlighting</span></h2>
    <code><a class="message" href="#SCI_BRACEHIGHLIGHT">SCI_BRACEHIGHLIGHT(int pos1, int
    pos2)</a><br />
     <a class="message" href="#SCI_BRACEBADLIGHT">SCI_BRACEBADLIGHT(int pos1)</a><br />
     <a class="message" href="#SCI_BRACEMATCH">SCI_BRACEMATCH(int position, int
    maxReStyle)</a><br />
    </code>
	<h3 id="SCI_BRACEHIGHLIGHT">SCI_BRACEHIGHLIGHT(int pos1, int pos2)</h3>
    <p>最大二文字が「括弧の強調装飾」で強調されます。装飾番号は <a class="message" href="#StyleDefinition"><code>STYLE_BRACELIGHT</code></a> (34) です。字下げ誘導が有効になっている場合、括弧に関連する字下げも強調したいと考えることがあるでしょう。<a class="message"
    href="#SCI_GETCOLUMN"><code>SCI_GETCOLUMN</code></a> で桁の位置を取得し、<a
    class="message" href="#SCI_SETHIGHLIGHTGUIDE"><code>SCI_SETHIGHLIGHTGUIDE</code></a> で字下げの強調を行うことができます。 </p>
    <p class="eng"><b>SCI_BRACEHIGHLIGHT(int pos1, int pos2)</b><br />
     Up to two characters can be highlighted in a 'brace highlighting style', which is defined as
    style number <a class="message" href="#StyleDefinition"><code>STYLE_BRACELIGHT</code></a> (34).
    If you have enabled indent guides, you may also wish to highlight the indent that corresponds
    with the brace. You can locate the column with <a class="message"
    href="#SCI_GETCOLUMN"><code>SCI_GETCOLUMN</code></a> and highlight the indent with <a
    class="message" href="#SCI_SETHIGHLIGHTGUIDE"><code>SCI_SETHIGHLIGHTGUIDE</code></a>.</p>
	<h3 id="SCI_BRACEBADLIGHT">SCI_BRACEBADLIGHT(int pos1)</h3>
    <p>対応する括弧が見つからない場合は <a class="jump" href="#StyleDefinition">括弧の不正に対する強調装飾</a>で対応のない括弧を強調することができます。装飾番号は <code>BRACE_BADLIGHT</code> (35) です。位置に <code>INVALID_POSITION</code> (-1) を指定するとこの強調は取り除かれます。</p>
    <p class="eng"><b>SCI_BRACEBADLIGHT(int pos1)</b><br />
     If there is no matching brace then the <a class="jump" href="#StyleDefinition">brace
    badlighting style</a>, style <code>BRACE_BADLIGHT</code> (35), can be used to show the brace
    that is unmatched. Using a position of <code>INVALID_POSITION</code> (-1) removes the
    highlight.</p>
	<h3 id="SCI_BRACEMATCH">SCI_BRACEMATCH(int pos, int maxReStyle)</h3>
    <p><code>SCI_BRACEMATCH</code> は位置<code>pos</code> の文字と関係づけられた対応する括弧を差がします。制御される括弧文字は '(', ')', '[',
    ']', '{', '}', '&lt;', '&gt;' です。開き括弧からは文書の進行方向、閉じ括弧からはその逆方向に検索します。もし指定位置の文字が括弧ではなかった場合や対応する括弧が見つからなかった場合は、-1 を返します。そうでなければ戻り値は対応する括弧の位置となります。</p>
    <p class="eng"><b>SCI_BRACEMATCH(int pos, int maxReStyle)</b><br />
     The <code>SCI_BRACEMATCH</code> message finds a corresponding matching brace given
    <code>pos</code>, the position of one brace. The brace characters handled are '(', ')', '[',
    ']', '{', '}', '&lt;', and '&gt;'. The search is forwards from an opening brace and backwards
    from a closing brace. If the character at position is not a brace character, or a matching
    brace cannot be found, the return value is -1. Otherwise, the return value is the position of
    the matching brace.</p>

    <p>対応する括弧はともに同じ装飾を持っているか、装飾部の端を越えているかしていなくてはなりません。入れ語の括弧は正しく処理されます。媒介変数 <code>maxReStyle</code> は現時点では必ず 0 にしてください。将来、括弧の検索の長さを制限する目的に使われる予定です。</p>
    <p class="eng">A match only occurs if the style of the matching brace is the same as the starting brace or
    the matching brace is beyond the end of styling. Nested braces are handled correctly. The
    <code>maxReStyle</code> parameter must currently be 0 - it may be used in the future to limit
    the length of brace searches.</p>

    <h2 id="TabsAndIndentationGuides"><span>タブと字下げの誘導</span><span class="eng">Tabs and Indentation Guides</span></h2>

    <p>字下げ(行先頭のホワイトスペース)はプログラマーが構造を明確にするためによく使われる他、Python のような一部の言語では文法の一部となっています。タブキーは通常エディタで用いられ、タブ文字を挿入するか次のタブ位置まで空白を詰めていくかするために使われます。</p>
    <p class="eng">Indentation (the white space at the start of a line) is often used by programmers to clarify
    program structure and in some languages, for example Python, it may be part of the language
    syntax. Tabs are normally used in editors to insert a tab character or to pad text with spaces
    up to the next tab.</p>

    <p>行頭のホワイトスペース内において、タブや後退の入力を特別に扱うことができます。タブキーで現在の文字位置に単にタブ文字を入れる代わりに次の字下げ位置まで進め、後退キーで文字を削除する代わりに字下げを解除していくなどです。Scintila は字下げ誘導(垂直な線)を表示することができます。コードの生成に役立てることができます。</p>
    <p class="eng">Scintilla can be set to treat tab and backspace in the white space at the start of a line in
    a special way: inserting a tab indents the line to the next indent position rather than just
    inserting a tab at the current character position and backspace unindents the line rather than
    deleting a character. Scintilla can also display indentation guides (vertical lines) to help
    you to generate code.</p>
    <code><a class="message" href="#SCI_SETTABWIDTH">SCI_SETTABWIDTH(int widthInChars)</a><br />
     <a class="message" href="#SCI_GETTABWIDTH">SCI_GETTABWIDTH</a><br />
     <a class="message" href="#SCI_SETUSETABS">SCI_SETUSETABS(bool useTabs)</a><br />
     <a class="message" href="#SCI_GETUSETABS">SCI_GETUSETABS</a><br />
     <a class="message" href="#SCI_SETINDENT">SCI_SETINDENT(int widthInChars)</a><br />
     <a class="message" href="#SCI_GETINDENT">SCI_GETINDENT</a><br />
     <a class="message" href="#SCI_SETTABINDENTS">SCI_SETTABINDENTS(bool tabIndents)</a><br />
     <a class="message" href="#SCI_GETTABINDENTS">SCI_GETTABINDENTS</a><br />
     <a class="message" href="#SCI_SETBACKSPACEUNINDENTS">SCI_SETBACKSPACEUNINDENTS(bool
    bsUnIndents)</a><br />
     <a class="message" href="#SCI_GETBACKSPACEUNINDENTS">SCI_GETBACKSPACEUNINDENTS</a><br />
     <a class="message" href="#SCI_SETLINEINDENTATION">SCI_SETLINEINDENTATION(int line, int
    indentation)</a><br />
     <a class="message" href="#SCI_GETLINEINDENTATION">SCI_GETLINEINDENTATION(int line)</a><br />
     <a class="message" href="#SCI_GETLINEINDENTPOSITION">SCI_GETLINEINDENTPOSITION(int
    line)</a><br />
     <a class="message" href="#SCI_SETINDENTATIONGUIDES">SCI_SETINDENTATIONGUIDES(bool
    view)</a><br />
     <a class="message" href="#SCI_GETINDENTATIONGUIDES">SCI_GETINDENTATIONGUIDES</a><br />
     <a class="message" href="#SCI_SETHIGHLIGHTGUIDE">SCI_SETHIGHLIGHTGUIDE(int column)</a><br />
     <a class="message" href="#SCI_GETHIGHLIGHTGUIDE">SCI_GETHIGHLIGHTGUIDE</a><br />
    </code>
	<h3 id="SCI_SETTABWIDTH">SCI_SETTABWIDTH(int widthInChars)<br />
     <span id="SCI_GETTABWIDTH">SCI_GETTABWIDTH</span></h3>
    <p><code>SCI_SETTABWIDTH</code> でタブの大きさを <code>STYLE_DEFAULT</code> の整数倍の空白文字で定義します。初期状態のタブ幅は 8 文字です。タブ幅に制限はありませんが 1 未満とか大きすぎる値などは想定外の動作をすることがあります。</p>
    <p class="eng"><b>SCI_SETTABWIDTH(int widthInChars)</b><br />
     <b>SCI_GETTABWIDTH</b><br />
     <code>SCI_SETTABWIDTH</code> sets the size of a tab as a multiple of the size of a space
    character in <code>STYLE_DEFAULT</code>. The default tab width is 8 characters. There are no
    limits on tab sizes, but values less than 1 or large values may have undesirable effects.</p>
	<h3 id="SCI_SETUSETABS">SCI_SETUSETABS(bool useTabs)<br />
     <span id="SCI_GETUSETABS">SCI_GETUSETABS</span></h3>
    <p><code>SCI_SETUSETABS</code> によって、字下げがタブ文字と空白文字の混成にならないようにしたり空白文字だけになったりするように設定できます。<code>useTabs</code> を <code>false</code> (0) にすると素手のタブと字下げに空白文字を使わなくなります。初期状態では <code>true</code> です。<a class="message" href="#SCI_GETCOLUMN"><code>SCI_GETCOLUMN</code></a> を使うとタブ幅を考慮に入れた桁位置を取得することができます。</p>
    <p class="eng"><b>SCI_SETUSETABS(bool useTabs)</b><br />
     <b>SCI_GETUSETABS</b><br />
     <code>SCI_SETUSETABS</code> determines whether indentation should be created out of a mixture
    of tabs and spaces or be based purely on spaces. Set <code>useTabs</code> to <code>false</code>
    (0) to create all tabs and indents out of spaces. The default is <code>true</code>. You can use
    <a class="message" href="#SCI_GETCOLUMN"><code>SCI_GETCOLUMN</code></a> to get the column of a
    position taking the width of a tab into account.</p>
	<h3 id="SCI_SETINDENT">SCI_SETINDENT(int widthInChars)<br />
     <span id="SCI_GETINDENT">SCI_GETINDENT</span></h3>
	<p><code>SCI_SETINDENT</code> は <a
    class="message" href="#StyleDefinition"><code>STYLE_DEFAULT</code></a> で設定された空白の幅から字下げ幅を設定します。0 を指定すると字下げ幅はタブ幅と同じになります。字下げ幅に制限はありませんが、0 未満や大きすぎる値は想定外の挙動を起こすことがあります。</p>
	<p class="eng">
    <b id="SCI_SETINDENT">SCI_SETINDENT(int widthInChars)</b><br />
     <b id="SCI_GETINDENT">SCI_GETINDENT</b><br />
     <code>SCI_SETINDENT</code> sets the size of indentation in terms of the width of a space in <a
    class="message" href="#StyleDefinition"><code>STYLE_DEFAULT</code></a>. If you set a width of
    0, the indent size is the same as the tab size. There are no limits on indent sizes, but values
    less than 0 or large values may have undesirable effects. <br />
     <br /></p>

	<h3 id="SCI_SETTABINDENTS">SCI_SETTABINDENTS(bool tabIndents)<br />
     <span id="SCI_GETTABINDENTS">SCI_GETTABINDENTS</span><br />
     <span id="SCI_SETBACKSPACEUNINDENTS">SCI_SETBACKSPACEUNINDENTS(bool bsUnIndents)</span><br />
     <span id="SCI_GETBACKSPACEUNINDENTS">SCI_GETBACKSPACEUNINDENTS</span></h3>
    <p class="eng"><b>SCI_SETTABINDENTS(bool tabIndents)</b><br />
     <b>SCI_GETTABINDENTS</b><br />
     <b>SCI_SETBACKSPACEUNINDENTS(bool bsUnIndents)</b><br />
     <b>SCI_GETBACKSPACEUNINDENTS</b><br />
    </p>

    <p>字下げのホワイトスペース内では、タブキーと後退キーを字下げとその解除に使うことができます。それぞれ <code>SCI_SETTABINDENTS</code> と <code>SCI_SETBACKSPACEUNINDENTS</code> 関数で指定します。</p>
    <p class="eng">Inside indentation white space, the tab and backspace keys can be made to indent and
    unindent rather than insert a tab character or delete a character with the
    <code>SCI_SETTABINDENTS</code> and <code>SCI_SETBACKSPACEUNINDENTS</code> functions.</p>
	<h3 id="SCI_SETLINEINDENTATION">SCI_SETLINEINDENTATION(int line, int indentation)<br />
     <span id="SCI_GETLINEINDENTATION">SCI_GETLINEINDENTATION(int line)</span></h3>
    <p><code>SCI_GETLINEINDENTATION</code> と <code>SCI_SETLINEINDENTATION</code> により、ある行の字下げ量の取得または設定ができます。字下げは文字単位の桁数で計測されます。文字単位とは空白文字の幅に関係づけられたものです。</p>
    <p class="eng"><b>SCI_SETLINEINDENTATION(int line, int indentation)</b><br />
     <b>SCI_GETLINEINDENTATION(int line)</b><br />
     The amount of indentation on a line can be discovered and set with
    <code>SCI_GETLINEINDENTATION</code> and <code>SCI_SETLINEINDENTATION</code>. The indentation is
    measured in character columns, which correspond to the width of space characters.</p>
	<h3 id="SCI_GETLINEINDENTPOSITION">SCI_GETLINEINDENTPOSITION(int line)</h3>
    <p>指定行の字下げの終了位置を返します。</p>
    <p class="eng"><b>SCI_GETLINEINDENTPOSITION(int line)</b><br />
     This returns the position at the end of indentation of a line.</p>
<h3 id="SCI_SETINDENTATIONGUIDES">SCI_SETINDENTATIONGUIDES(bool view)<br />
     <span id="SCI_GETINDENTATIONGUIDES">SCI_GETINDENTATIONGUIDES</span></h3>
    <p>字下げ誘導は垂直の点線で、字下げの空白の中に字下げ幅毎に現れます。これにより、特に複数ページに渡るような場合に、各行がどの構造に属しているのかがわかりやすくなります。装飾番号 <a class="message"
    href="#StyleDefinition"><code>STYLE_INDENTGUIDE</code></a> (37) は字下げ誘導に文字色と背景色をつけることに使われます。</p>
    <p class="eng"><b>SCI_SETINDENTATIONGUIDES(bool view)</b><br />
     <b>SCI_GETINDENTATIONGUIDES</b><br />
     Indentation guides are dotted vertical lines that appear within indentation white space every
    indent size columns. They make it easy to see which constructs line up especially when they
    extend over multiple pages. Style <a class="message"
    href="#StyleDefinition"><code>STYLE_INDENTGUIDE</code></a> (37) is used to specify the
    foreground and background colour of the indentation guides.</p>
<h3 id="SCI_SETHIGHLIGHTGUIDE">SCI_SETHIGHLIGHTGUIDE(int column)<br />
     <span id="SCI_GETHIGHLIGHTGUIDE">SCI_GETHIGHLIGHTGUIDE</span></h3>
    <p>括弧の強調が発生したとき、この括弧に関係する字下げ誘導をも強調することができます。これは装飾番号 <a class="message"
    href="#StyleDefinition"><code>STYLE_BRACELIGHT</code></a> (34) の情報が使用されます。<code>column</code> に 0 を指定すると強調が行われません。</p>
    <p class="eng"><b>SCI_SETHIGHLIGHTGUIDE(int column)</b><br />
     <b>SCI_GETHIGHLIGHTGUIDE</b><br />
     When brace highlighting occurs, the indentation guide corresponding to the braces may be
    highlighted with the brace highlighting style, <a class="message"
    href="#StyleDefinition"><code>STYLE_BRACELIGHT</code></a> (34). Set <code>column</code> to 0 to
    cancel this highlight.</p>

    <h2 id="Markers"><span>マーカ</span><span class="eng">Markers</span></h2>

    <p>0 〜 31 に番号づけられたマーカがあり、これらの任意の組み合わせを各行に指定することができます。マーカはテキストの左にある選択用余白の中に現れます。選択用余白の幅が 0 の場合は、代わりに行全体の背景色が変わります。マーカ番号 25 〜 31 は Scintilla が折りたたみ余白の中で使い、<code>SC_MARKNUM_</code>* と言う形の参照名が与えられています。<code>SC_MARKNUM_FOLDEROPEN</code> といったものがあります。</p>
    <p class="eng">There are 32 markers, numbered 0 to 31, and you can assign any combination of them to each
    line in the document. Markers appear in the <a class="jump" href="#Margins">selection
    margin</a> to the left of the text. If the selection margin is set to zero width, the
    background colour of the whole line is changed instead. Marker numbers 25 to 31 are used by
    Scintilla in folding margins, and have symbolic names of the form <code>SC_MARKNUM_</code>*,
    for example <code>SC_MARKNUM_FOLDEROPEN</code>.</p>

    <p>マーカ番号 0 〜 24 は機能を定義されておらず、Scintilla を利用する側で文法エラーや実行位置、ブレークポイント、その他の必要な標示に使用することができます。折りたたみ機能が不要の場合は 32 種すべてのマーカを好きな目的に使用することができます。</p>
    <p class="eng">Marker numbers 0 to 24 have no pre-defined function; you can use them to mark syntax errors
    or the current point of execution, break points, or whatever you need marking. If you do not
    need folding, you can use all 32 for any purpose you wish.</p>

    <p>マーカ番号はこれに関係づけられた符号を持っています。マーカ番号毎に前景色と背景色を指定することができますので、同じ符号を別目的の別の色で使うことができます。Scintilla は符号の集合を持っており、(<code>SC_MARK_</code>*) に割り当てたり、文字を使ったりすることができます。初期状態では、32 の全てのマーカが <code>SC_MARK_CIRCLE</code> に割り当てられており、前景色が黒、背景色が白となっています。</p>
    <p class="eng">Each marker number has a symbol associated with it. You can also set the foreground and
    background colour for each marker number, so you can use the same symbol more than once with
    different colouring for different uses. Scintilla has a set of symbols you can assign
    (<code>SC_MARK_</code>*) or you can use characters. By default, all 32 markers are set to
    <code>SC_MARK_CIRCLE</code> with a black foreground and a white background.</p>

    <p>マーカはその番号順に描画されます。したがって番号の大きいマーカが低いマーカの上に現れます。マーカがある行が移動する場合、行頭の移動先を追跡することでマーカの移動が試みられます。もしマーカのある行が削除された場合、マーカの情報はその前の行のマーカ情報と <code>OR</code> 演算で合成されます。</p>
    <p class="eng">The markers are drawn in the order of their numbers, so higher numbered markers appear on
    top of lower numbered ones. Markers try to move with their text by tracking where the start of
    their line moves. When a line is deleted, its markers are combined, by an <code>OR</code>
    operation, with the markers of the previous line.</p>
    <code><a class="message" href="#SCI_MARKERDEFINE">SCI_MARKERDEFINE(int markerNumber, int
    markerSymbols)</a><br />
     <a class="message" href="#SCI_MARKERDEFINEPIXMAP">SCI_MARKERDEFINEPIXMAP(int markerNumber,
    const char *xpm)</a><br />
     <a class="message" href="#SCI_MARKERSETFORE">SCI_MARKERSETFORE(int markerNumber, int
    colour)</a><br />
     <a class="message" href="#SCI_MARKERSETBACK">SCI_MARKERSETBACK(int markerNumber, int
    colour)</a><br />
     <a class="message" href="#SCI_MARKERADD">SCI_MARKERADD(int line, int markerNumber)</a><br />
     <a class="message" href="#SCI_MARKERDELETE">SCI_MARKERDELETE(int line, int
    markerNumber)</a><br />
     <a class="message" href="#SCI_MARKERDELETEALL">SCI_MARKERDELETEALL(int markerNumber)</a><br />
     <a class="message" href="#SCI_MARKERGET">SCI_MARKERGET(int line)</a><br />
     <a class="message" href="#SCI_MARKERNEXT">SCI_MARKERNEXT(int lineStart, int
    markerMask)</a><br />
     <a class="message" href="#SCI_MARKERPREVIOUS">SCI_MARKERPREVIOUS(int lineStart, int
    markerMask)</a><br />
     <a class="message" href="#SCI_MARKERLINEFROMHANDLE">SCI_MARKERLINEFROMHANDLE(int
    handle)</a><br />
     <a class="message" href="#SCI_MARKERDELETEHANDLE">SCI_MARKERDELETEHANDLE(int handle)</a><br />
    </code>
	<h3 id="SCI_MARKERDEFINE">SCI_MARKERDEFINE(int markerNumber, int markerSymbols)</h3>
    <p>0 〜 31 のマーカ番号とマーカシンボルもしくは ASCII 文字を関係づけます。目的の特化されていないシンボルは現在以下のものが用意されています。<br /><code>SC_MARK_CIRCLE</code>, <code>SC_MARK_ROUNDRECT</code>, <code>SC_MARK_ARROW</code>,
    <code>SC_MARK_SMALLRECT</code>, <code>SC_MARK_SHORTARROW</code>, <code>SC_MARK_EMPTY</code>,
    <code>SC_MARK_ARROWDOWN</code>, <code>SC_MARK_MINUS</code>, <code>SC_MARK_PLUS</code>,
    <code>SC_MARK_ARROWS</code>, <code>SC_MARK_DOTDOTDOT</code>, <code>SC_MARK_EMPTY</code>,
    <code>SC_MARK_BACKGROUND</code></p>
    <p class="eng"><b>SCI_MARKERDEFINE(int markerNumber, int markerSymbols)</b><br />
     This message associates a marker number in the range 0 to 31 with one of the marker symbols or
    an ASCII character. The general-purpose marker symbols currently available are:<br />
     <code>SC_MARK_CIRCLE</code>, <code>SC_MARK_ROUNDRECT</code>, <code>SC_MARK_ARROW</code>,
    <code>SC_MARK_SMALLRECT</code>, <code>SC_MARK_SHORTARROW</code>, <code>SC_MARK_EMPTY</code>,
    <code>SC_MARK_ARROWDOWN</code>, <code>SC_MARK_MINUS</code>, <code>SC_MARK_PLUS</code>,
    <code>SC_MARK_ARROWS</code>, <code>SC_MARK_DOTDOTDOT</code>, <code>SC_MARK_EMPTY</code> and
    <code>SC_MARK_BACKGROUND</code>.</p>
	<h3 id="SCI_MARKERDEFINEPIXMAP">SCI_MARKERDEFINEPIXMAP(int markerNumber, const char
    *xpm)</h3>
    <p>マーカは pixmap にすることができます。XPM 形式が pixmap に用いられます。pixmap は 1 オクテットで 1 ピクセルを表すという制限があります。データは 0 終端でなくてはなりません。pixmap はマーカ用シンボル <code>SC_MARK_PIXMAP</code> を使います。<a class="jump" href="http://koala.ilog.fr/lehors/xpm.html">XPM 形式の全容</a>は別途参照してください。</p>
    <p class="eng"><b>SCI_MARKERDEFINEPIXMAP(int markerNumber, const char
    *xpm)</b><br />
     Markers can be set to pixmaps with this message. The XPM format is used for the pixmap and it
    is limited to pixmaps that use one character per pixel. The data should be null terminated.
    Pixmaps use the <code>SC_MARK_PIXMAP</code> marker symbol. You can find the full description of
    the XPM format <a class="jump" href="http://koala.ilog.fr/lehors/xpm.html">here</a>.</p>

    <p>マーカ <code>SC_MARK_BACKGROUND</code> は行の背景色を変更するだけです。<br /><code>SC_MARK_EMPTY</code> は見えないマーカで、行を追跡することに使えます。また、折りたたみへの装飾を変更して <code>SC_FOLDERNUM_</code>* を関係のないシンボルと結びつけたいときにも使えます。</p>
    <p class="eng">The <code>SC_MARK_BACKGROUND</code> marker changes the background colour of the line only.
    The <code>SC_MARK_EMPTY</code> symbol is invisible, allowing client code to track the movement
    of lines. You would also use it if you changed the folding style and wanted one or more of the
    <code>SC_FOLDERNUM_</code>* markers to have no associated symbol.</p>

    <p>余白の中で平坦な木の形に折りたたみを表現するためのマーカシンボルは次の通りです。<br />
     <code>SC_MARK_BOXMINUS</code>, <code>SC_MARK_BOXMINUSCONNECTED</code>,
    <code>SC_MARK_BOXPLUS</code>, <code>SC_MARK_BOXPLUSCONNECTED</code>,
    <code>SC_MARK_CIRCLEMINUS</code>, <code>SC_MARK_CIRCLEMINUSCONNECTED</code>,
    <code>SC_MARK_CIRCLEPLUS</code>, <code>SC_MARK_CIRCLEPLUSCONNECTED</code>,
    <code>SC_MARK_LCORNER</code>, <code>SC_MARK_LCORNERCURVE</code>, <code>SC_MARK_TCORNER</code>,
    <code>SC_MARK_TCORNERCURVE</code>, <code>SC_MARK_VLINE</code></p>
    <p class="eng">There are also marker symbols designed for use in the folding margin in a flattened tree
    style.<br />
     <code>SC_MARK_BOXMINUS</code>, <code>SC_MARK_BOXMINUSCONNECTED</code>,
    <code>SC_MARK_BOXPLUS</code>, <code>SC_MARK_BOXPLUSCONNECTED</code>,
    <code>SC_MARK_CIRCLEMINUS</code>, <code>SC_MARK_CIRCLEMINUSCONNECTED</code>,
    <code>SC_MARK_CIRCLEPLUS</code>, <code>SC_MARK_CIRCLEPLUSCONNECTED</code>,
    <code>SC_MARK_LCORNER</code>, <code>SC_MARK_LCORNERCURVE</code>, <code>SC_MARK_TCORNER</code>,
    <code>SC_MARK_TCORNERCURVE</code>, and <code>SC_MARK_VLINE</code>.</p>

	<p>文字もマーカとして利用可能です。文字の ASCII 値に <code>SC_MARK_CHARACTER</code> (10000) を加えて指定してください。例えば 'A' (ASCII コード 65) をマーカ番号 1 に使うのであれば <code>SCI_MARKETDEFINE(1, SC_MARK_CHARACTER+65)</code> というコードを実行します。</p>
	 <p class="eng">
     Characters can be used as markers by adding the ASCII value of the character to
    <code>SC_MARK_CHARACTER</code> (10000). For example, to use 'A' (ASCII code 65) as marker
    number 1 use:<br />
     <code>SCI_MARKETDEFINE(1, SC_MARK_CHARACTER+65)</code>. </p>


    <p>マーカ番号 <code>SC_MARKNUM_FOLDER</code> と <code>SC_MARKNUM_FOLDEROPEN</code> は折りたたみ部分が開いているか閉じているかを標示するために使われます。どのシンボルもこの目的で割り当てることができますが、(<code>SC_MARK_PLUS</code>, <code>SC_MARK_MINUS</code>) もしくは (<code>SC_MARK_ARROW</code>, <code>SC_MARK_ARROWDOWN</code>) の組を選択するのがよいでしょう。平坦木で表示するにはほかにも次のものへの割り当てが必要です。<code>SC_MARKNUM_FOLDEREND</code>, <code>SC_MARKNUM_FOLDERMIDTAIL</code>,
    <code>SC_MARKNUM_FOLDEROPENMID</code>, <code>SC_MARKNUM_FOLDERSUB</code>,
    <code>SC_MARKNUM_FOLDERTAIL</code><br />
	折りたたみに使う分のビットは <code>SC_MASK_FOLDERS</code> で表現できます。これは通常折りたたみ用の余白に対して <code>SCI_SETMARGINMASKN</code> の引数で用いられます。</p>
    <p class="eng">The marker numbers <code>SC_MARKNUM_FOLDER</code> and <code>SC_MARKNUM_FOLDEROPEN</code> are
    used for showing that a fold is present and open or closed. Any symbols may be assigned for
    this purpose although the (<code>SC_MARK_PLUS</code>, <code>SC_MARK_MINUS</code>) pair or the
    (<code>SC_MARK_ARROW</code>, <code>SC_MARK_ARROWDOWN</code>) pair are good choices. As well as
    these two, more assignments are needed for the flattened tree style:
    <code>SC_MARKNUM_FOLDEREND</code>, <code>SC_MARKNUM_FOLDERMIDTAIL</code>,
    <code>SC_MARKNUM_FOLDEROPENMID</code>, <code>SC_MARKNUM_FOLDERSUB</code>, and
    <code>SC_MARKNUM_FOLDERTAIL</code>. The bits used for folding are specified by
    <code>SC_MASK_FOLDERS</code>, which is commonly used as an argument to
    <code>SCI_SETMARGINMASKN</code> when defining a margin to be used for folding.</p>

    <p>次の表は、四種の折りたたみ表示においてどの <code>SC_MARK_</code>* シンボルがどのマーカ番号 <code>SC_MARKNUM_</code>* に割り当てられるべきかを示しています。Macintosh を模した矢印、'+' と '-' で閉じた折りたたみと開いた折りたたみを表現したもの、丸い記号の木、四角の記号の木がこの四種です。</p>
    <p class="eng">This table shows which <code>SC_MARK_</code>* symbols should be assigned to which
    <code>SC_MARKNUM_</code>* marker numbers to obtain four folding styles: Arrow (mimics
    Macintosh), plus/minus shows folded lines as '+' and opened folds as '-', Circle tree, Box
    tree.</p>

    <table cellpadding="1" cellspacing="2" border="0" summary="折りたたみに使うマーカ">
      <thead align="left">
        <tr>
          <th><code>SC_MARKNUM_</code>*</th>

          <th>矢印</th>

          <th>＋−</th>

          <th>丸記号の木</th>

          <th>四角記号の木</th>
        </tr>
      </thead>

      <tbody valign="top">
        <tr>
          <th align="left"><code>FOLDEROPEN</code></th>

          <td><code>ARROWDOWN</code></td>

          <td><code>MINUS</code></td>

          <td><code>CIRCLEMINUS</code></td>

          <td><code>BOXMINUS</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDER</code></th>

          <td><code>ARROW</code></td>

          <td><code>PLUS</code></td>

          <td><code>CIRCLEPLUS</code></td>

          <td><code>BOXPLUS</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDERSUB</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>VLINE</code></td>

          <td><code>VLINE</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDERTAIL</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>LCORNERCURVE</code></td>

          <td><code>LCORNER</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDEREND</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>CIRCLEPLUSCONNECTED</code></td>

          <td><code>BOXPLUSCONNECTED</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDEROPENMID</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>CIRCLEMINUSCONNECTED</code></td>

          <td><code>BOXMINUSCONNECTED</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDERMIDTAIL</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>TCORNERCURVE</code></td>

          <td><code>TCORNER</code></td>
        </tr>
      </tbody>
    </table>
    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Markers used for folding">
      <thead align="left">
        <tr>
          <th><code>SC_MARKNUM_</code>*</th>

          <th>Arrow</th>

          <th>Plus/minus</th>

          <th>Circle tree</th>

          <th>Box tree</th>
        </tr>
      </thead>

      <tbody valign="top">
        <tr>
          <th align="left"><code>FOLDEROPEN</code></th>

          <td><code>ARROWDOWN</code></td>

          <td><code>MINUS</code></td>

          <td><code>CIRCLEMINUS</code></td>

          <td><code>BOXMINUS</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDER</code></th>

          <td><code>ARROW</code></td>

          <td><code>PLUS</code></td>

          <td><code>CIRCLEPLUS</code></td>

          <td><code>BOXPLUS</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDERSUB</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>VLINE</code></td>

          <td><code>VLINE</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDERTAIL</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>LCORNERCURVE</code></td>

          <td><code>LCORNER</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDEREND</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>CIRCLEPLUSCONNECTED</code></td>

          <td><code>BOXPLUSCONNECTED</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDEROPENMID</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>CIRCLEMINUSCONNECTED</code></td>

          <td><code>BOXMINUSCONNECTED</code></td>
        </tr>

        <tr>
          <th align="left"><code>FOLDERMIDTAIL</code></th>

          <td><code>EMPTY</code></td>

          <td><code>EMPTY</code></td>

          <td><code>TCORNERCURVE</code></td>

          <td><code>TCORNER</code></td>
        </tr>
      </tbody>
    </table>


	<h3 id="SCI_MARKERSETFORE">SCI_MARKERSETFORE(int markerNumber, int <a class="jump"
    href="#colour">colour</a>)<br />
     <span id="SCI_MARKERSETBACK">SCI_MARKERSETBACK(int markerNumber, int <a class="jump"
    href="#colour">colour</a>)</span></h3>
	<p>マーカ番号に対する前景色と背景色を設定します。</p>
    <p class="eng"><b>SCI_MARKERSETFORE(int markerNumber, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b>SCI_MARKERSETBACK(int markerNumber, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     These two messages set the foreground and background colour of a marker number.</p>
	<h3 id="SCI_MARKERADD">SCI_MARKERADD(int line, int markerNumber)</h3>
    <p>指定行に指定番号のマーカを追加します。行番号がおかしい場合やメモリ不足などで失敗すると -1 を返します。それ以外の場合は追加後のマーカ制御番号を返します。マーカ制御番号は、移動や行の結合後のマーカを探す際の <a class="message"
    href="#SCI_MARKERLINEFROMHANDLE"><code>SCI_MARKERLINEFROMHANDLE</code></a> や、マーカを削除する際の <a class="message"
    href="#SCI_MARKERDELETEHANDLE"><code>SCI_MARKERDELETEHANDLE</code></a> で使用することができます。<br/ >指定されたマーカ番号自身や、すでにその行にマーカがあるかどうかは調べません。</p>
    <p class="eng"><b>SCI_MARKERADD(int line, int markerNumber)</b><br />
     This message adds marker number <code>markerNumber</code> to a line. The message returns -1 if
    this fails (illegal line number, out of memory) or it returns a marker handle number that
    identifies the added marker. You can use this returned handle with <a class="message"
    href="#SCI_MARKERLINEFROMHANDLE"><code>SCI_MARKERLINEFROMHANDLE</code></a> to find where a
    marker is after moving or combining lines and with <a class="message"
    href="#SCI_MARKERDELETEHANDLE"><code>SCI_MARKERDELETEHANDLE</code></a> to delete the marker
    based on its handle. The message does not check the value of markerNumber, nor does it
    check if the line already contains the marker.</p>
	<h3 id="SCI_MARKERDELETE">SCI_MARKERDELETE(int line, int markerNumber)</h3>
    <p>指定行番号で指定マーカ番号を探し、そのマーカがあればマーカを削除します。同じマーカを複数回加えていた場合はこれを一回にひとつずつ削除していきます。マーカ番号に -1 を指定すると、その行のすべてのマーカが削除されます。</p>
    <p class="eng"><b>SCI_MARKERDELETE(int line, int markerNumber)</b><br />
     This searches the given line number for the given marker number and deletes it if it is
    present. If you added the same marker more than once to the line, this will delete one copy
    each time it is used. If you pass in a marker number of -1, all markers are deleted from the
    line.</p>
	<h3 id="SCI_MARKERDELETEALL">SCI_MARKERDELETEALL(int markerNumber)</h3>
    <p>全ての行から指定番号のマーカを削除します。マーカ番号が -1 の場合はすべての行のすべてのマーカが削除されます。</p>
    <p class="eng"><b>SCI_MARKERDELETEALL(int markerNumber)</b><br />
     This removes markers of the given number from all lines. If markerNumber is -1, it deletes all
    markers from all lines.</p>
	<h3 id="SCI_MARKERGET">SCI_MARKERGET(int line)</h3>
    <p>指定行にどのマーカがあるかを示す 32 ビット整数値を返します。低位ビットから順にマーカ番号 0, 1, 2 … に対応します。</p>
    <p class="eng"><b>SCI_MARKERGET(int line)</b><br />
     This returns a 32-bit integer that indicates which markers were present on the line. Bit 0 is
    set if marker 0 is present, bit 1 for marker 1 and so on.</p>
	<h3 id="SCI_MARKERNEXT">SCI_MARKERNEXT(int lineStart, int markerMask)<br />
     <span id="SCI_MARKERPREVIOUS">SCI_MARKERPREVIOUS(int lineStart, int markerMask)</span></h3>
    <p>指定された行以前または以後から指定されたマーカの集合を検索します。検索は行番号 <code>lineStart</code> の行から始まり、ファイルの終端方向(<code>SCI_MARKERNEXT</code>)もしくは開始位置方向(<code>SCI_MARKERPREVIOUS</code>) へ検索を続けます。引数 <code>markerMask</code> は検索したいマーカを示す少なくとも一つのビットが指定されているべきです。低位ビットからマーカ番号 0, 1, 2 …に対応しており、立てられると検索対象となります。<code>markerMask</code> に含まれているマーカのいずれかがはじめて見つかった行番号を返します。見つからなかった場合は -1 を返します。</p>
    <p class="eng"><b>SCI_MARKERNEXT(int lineStart, int markerMask)</b><br />
     <b>SCI_MARKERPREVIOUS(int lineStart, int markerMask)</b><br />
     These messages search efficiently for lines that include a given set of markers. The search
    starts at line number <code>lineStart</code> and continues forwards to the end of the file
    (<code>SCI_MARKERNEXT</code>) or backwards to the start of the file
    (<code>SCI_MARKERPREVIOUS</code>). The <code>markerMask</code> argument should have one bit set
    for each marker you wish to find. Set bit 0 to find marker 0, bit 1 for marker 1 and so on. The
    message returns the line number of the first line that contains one of the markers in
    <code>markerMask</code> or -1 if no marker is found.</p>
	<h3 id="SCI_MARKERLINEFROMHANDLE">SCI_MARKERLINEFROMHANDLE(int markerHandle)</h3>
    <p>引数 <code>markerHandle</code> は <a
    class="message" href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a> から返されたマーカへの識別子です。この関数はこの識別子があるマーカを検索します。見つかればその行番号、見つからなければ -1 を返します。</p>
    <p class="eng"><b>SCI_MARKERLINEFROMHANDLE(int markerHandle)</b><br />
     The <code>markerHandle</code> argument is an identifier for a marker returned by <a
    class="message" href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a>. This function searches
    the document for the marker with this handle and returns the line number that contains it or -1
    if it is not found.</p>
	<h3 id="SCI_MARKERDELETEHANDLE">SCI_MARKERDELETEHANDLE(int markerHandle)</h3>
    <p>引数 <code>markerHandle</code> は <a
    class="message" href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a> から返されたマーカへの識別子です。この関数はこの識別子があるマーカを検索し、見つかればこのマーカを削除します。</p>
    <p class="eng"><b>SCI_MARKERDELETEHANDLE(int markerHandle)</b><br />
     The <code>markerHandle</code> argument is an identifier for a marker returned by <a
    class="message" href="#SCI_MARKERADD"><code>SCI_MARKERADD</code></a>. This function searches
    the document for the marker with this handle and deletes the marker if it is found.</p>

    <h2 id="Indicators"><span>標示</span><span class="eng">Indicators</span></h2>

    <p>初期状態の Scintilla は文字毎に対応している装飾オクテットを 5 ビットと 3 ビットに分け、前者を装飾情報( 32 種)、後者を標示情報としています。ですから、文法エラー・非推奨の名前・不正な字下げを一度に標示することができます。標示は次のいずれかになります。単純な下線、波線、小さな "T" の形の線、斜めのハッチング、打ち消し線、テキストの周りを囲む矩形。</p>
    <p class="eng">By default, Scintilla organizes the style byte associated with each text byte as 5 bits of
    style information (for 32 styles) and 3 bits of indicator information for 3 independent
    indicators so that, for example, syntax errors, deprecated names and bad indentation could all
    be displayed at once. Indicators may be displayed as simple underlines, squiggly underlines, a
    line of small 'T' shapes, a line of diagonal hatching, a strike-out or a rectangle around the text.</p>

    <p>標示は <a class="message"
    href="#SCI_STARTSTYLING"><code>SCI_STARTSTYLING</code></a> で <code>INDICS_MASK</code> マスクを用い、<a class="message" href="#SCI_SETSTYLING"><code>SCI_SETSTYLING</code></a> で <code>INDIC0_MASK</code>, <code>INDIC1_MASK</code>, <code>INDIC2_MASK</code> を用いることで設定されます。</p>
    <p class="eng">The indicators are set using <a class="message"
    href="#SCI_STARTSTYLING"><code>SCI_STARTSTYLING</code></a> with a <code>INDICS_MASK</code> mask
    and <a class="message" href="#SCI_SETSTYLING"><code>SCI_SETSTYLING</code></a> with the values
    <code>INDIC0_MASK</code>, <code>INDIC1_MASK</code> and <code>INDIC2_MASK</code>.</p>

    <p>装飾に使うビット数は  <a class="message"
    href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a> によって 0 〜 7 の範囲で変更できます。残りのビットが標示に使われますので標示は 1 〜 8 ビットの範囲のいずれかです。しかしながら <code>Scintilla.h</code> で定義されている定数 <code>INDIC*_MASK</code> はすべて 5 ビットの装飾情報と 3 ビットの標示情報を前提としています。これと異なる配分を使う場合は自分で定数を定める必要があります。</p>
    <p class="eng">The number of bits used for styles can be altered with <a class="message"
    href="#SCI_SETSTYLEBITS"><code>SCI_SETSTYLEBITS</code></a> from 0 to 7 bits. The remaining bits
    can be used for indicators, so there can be from 1 to 8 indicators. However, the
    <code>INDIC*_MASK</code> constants defined in <code>Scintilla.h</code> all assume 5 bits of
    styling information and 3 indicators. If you use a different arrangement, you must define your
    own constants.</p>

    <p><code>SCI_INDIC*</code> メッセージは標示の視覚的状態を取得あるいは設定します。これらはすべて引数 <code>indicatorNumber</code> を使い、これは 0 〜 7 の範囲で指定の標示に装飾を与えるために使われます。初期設定では標示番号 0, 1, 2 だけが使えます。</p>
    <p class="eng">The <code>SCI_INDIC*</code> messages allow you to get and set the visual appearance of the
    indicators. They all use an <code>indicatorNumber</code> argument in the range 0 to 7 to set
    the indicator to style. With the default settings, only indicators 0, 1 and 2 will have any
    visible effect.</p>
    <code><a class="message" href="#SCI_INDICSETSTYLE">SCI_INDICSETSTYLE(int indicatorNumber, int
    indicatorStyle)</a><br />
     <a class="message" href="#SCI_INDICGETSTYLE">SCI_INDICGETSTYLE(int indicatorNumber)</a><br />
     <a class="message" href="#SCI_INDICSETFORE">SCI_INDICSETFORE(int indicatorNumber, int
    colour)</a><br />
     <a class="message" href="#SCI_INDICGETFORE">SCI_INDICGETFORE(int indicatorNumber)</a><br />
    </code>
	<h3 id="SCI_INDICSETSTYLE">SCI_INDICSETSTYLE(int indicatorNumber, int
    indicatorStyle)<br /><span id="SCI_INDICGETSTYLE">SCI_INDICGETSTYLE(int indicatorNumber)</span></h3>
    <p>特性の標示が使っている装飾の設定または取得を行います。標示のための装飾は現在次のものが使えます。</p>
    <p class="eng"><b>SCI_INDICSETSTYLE(int indicatorNumber, int
    indicatorStyle)</b><br />
     <b id="SCI_INDICGETSTYLE">SCI_INDICGETSTYLE(int indicatorNumber)</b><br />
     These two messages set and get the style for a particular indicator. The indicator styles
    currently available are:</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="Indicators">
      <tbody>
        <tr>
          <th align="left">定数</th>

          <th>値</th>

          <th align="left">視覚効果</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>INDIC_PLAIN</code></td>

          <td align="center">0</td>

          <td>単純な直線の下線がつきます。</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_SQUIGGLE</code></td>

          <td align="center">1</td>

          <td>波状の下線がつきます。</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_TT</code></td>

          <td align="center">2</td>

          <td>小さな T が並んだような下線がつきます。.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_DIAGONAL</code></td>

          <td align="center">3</td>

          <td>斜線のハッチがつきます。</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_STRIKE</code></td>

          <td align="center">4</td>

          <td>打ち消し線がつきます。</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_HIDDEN</code></td>

          <td align="center">5</td>

          <td>標示に対して視覚効果はありません。</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_BOX</code></td>

          <td align="center">6</td>

          <td>テキストを矩形で囲みます。</td>
        </tr>
      </tbody>
    </table>

 
    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Indicators">
      <tbody>
        <tr>
          <th align="left">Symbol</th>

          <th>Value</th>

          <th align="left">Visual effect</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>INDIC_PLAIN</code></td>

          <td align="center">0</td>

          <td>Underlined with a single, straight line.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_SQUIGGLE</code></td>

          <td align="center">1</td>

          <td>A squiggly underline.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_TT</code></td>

          <td align="center">2</td>

          <td>A line of small T shapes.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_DIAGONAL</code></td>

          <td align="center">3</td>

          <td>Diagonal hatching.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_STRIKE</code></td>

          <td align="center">4</td>

          <td>Strike out.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_HIDDEN</code></td>

          <td align="center">5</td>

          <td>An indicator with no visual effect.</td>
        </tr>

        <tr>
          <td align="left"><code>INDIC_BOX</code></td>

          <td align="center">6</td>

          <td>A rectangle around the text.</td>
        </tr>
      </tbody>
    </table>

    <p>初期状態の標示装飾は次と等価です。<br />
     <code>SCI_INDICSETSTYLE(0, INDIC_SQUIGGLE);</code><br />
     <code>SCI_INDICSETSTYLE(1, INDIC_TT);</code><br />
     <code>SCI_INDICSETSTYLE(2, INDIC_PLAIN);</code></p>
    <p class="eng">The default indicator styles are equivalent to:<br />
     <code>SCI_INDICSETSTYLE(0, INDIC_SQUIGGLE);</code><br />
     <code>SCI_INDICSETSTYLE(1, INDIC_TT);</code><br />
     <code>SCI_INDICSETSTYLE(2, INDIC_PLAIN);</code></p>
	<h3 id="SCI_INDICSETFORE">SCI_INDICSETFORE(int indicatorNumber, int <a class="jump"
    href="#colour">colour</a>)<br />
     <span id="SCI_INDICGETFORE">SCI_INDICGETFORE(int indicatorNumber)</span></h3>
    <p>標示を描画するための色を設定あるいは取得します。初期状態の標示の色は次と等価です。<br />
     <code>SCI_INDICSETFORE(0, 0x007f00);</code> (暗い緑)<br />
     <code>SCI_INDICSETFORE(1, 0xff0000);</code> (明るい青)<br />
     <code>SCI_INDICSETFORE(2, 0x0000ff);</code> (明るい赤)</p>
    <p class="eng"><b>SCI_INDICSETFORE(int indicatorNumber, int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b>SCI_INDICGETFORE(int indicatorNumber)</b><br />
     These two messages set and get the colour used to draw an indicator. The default indicator
    colours are equivalent to:<br />
     <code>SCI_INDICSETFORE(0, 0x007f00);</code> (dark green)<br />
     <code>SCI_INDICSETFORE(1, 0xff0000);</code> (light blue)<br />
     <code>SCI_INDICSETFORE(2, 0x0000ff);</code> (light red)</p>

    <h2 id="Autocompletion"><span>自動補完</span><span class="eng">Autocompletion</span></h2>

    <p>自動補完機能はリストボックスを使ってユーザが入力した文字に近い識別子を表示するものです。ユーザは候補をタブキーで選択するか、更に候補を絞るために入力を続けるかします。候補は <code>SCI_AUTOCSETFILLUPS</code> で定義します。自動補完は Scintilla 自身ではなく実装側が起動させます。例えば、C 言語でユーザが <code>fred</code> とだけ入力したとすると、一覧の中へ <code>fred</code> を調べ、見つかれば自動補完一覧として提示することができます。またユーザの入力を監視し、その入力に近い候補を提示したら以後は入力毎に候補の絞り込みを行うこともできます。さらに別の方法として、一覧表示を呼び出すためのキーを定義しておくといった使い方もあります。</p>
    <p class="eng">Autocompletion displays a list box showing likely identifiers based upon the users typing.
    The user chooses the currently selected item by pressing the tab character or another character
    that is a member of the fillup character set defined with <code>SCI_AUTOCSETFILLUPS</code>.
    Autocompletion is triggered by your application. For example, in C if you detect that the user
    has just typed <code>fred.</code> you could look up <code>fred</code>, and if it has a known
    list of members, you could offer them in an autocompletion list. Alternatively, you could
    monitor the user's typing and offer a list of likely items once their typing has narrowed down
    the choice to a reasonable list. As yet another alternative, you could define a key code to
    activate the list.</p>

    <p>自動補完を機能させるには、文書に追加されていく文字を逐一監視していなくてはなりません。SciTEBase.cxx の <code>SciTEBase::CharAdded()</code> 関数が自動補完の例となっています。</p>
    <p class="eng">To make use of autocompletion you must monitor each character added to the document. See
    <code>SciTEBase::CharAdded()</code> in SciTEBase.cxx for an example of autocompletion.</p>
    <code><a class="message" href="#SCI_AUTOCSHOW">SCI_AUTOCSHOW(int lenEntered, const char
    *list)</a><br />
     <a class="message" href="#SCI_AUTOCCANCEL">SCI_AUTOCCANCEL</a><br />
     <a class="message" href="#SCI_AUTOCACTIVE">SCI_AUTOCACTIVE</a><br />
     <a class="message" href="#SCI_AUTOCPOSSTART">SCI_AUTOCPOSSTART</a><br />
     <a class="message" href="#SCI_AUTOCCOMPLETE">SCI_AUTOCCOMPLETE</a><br />
     <a class="message" href="#SCI_AUTOCSTOPS">SCI_AUTOCSTOPS(&lt;unused&gt;, const char
    *chars)</a><br />
     <a class="message" href="#SCI_AUTOCSETSEPARATOR">SCI_AUTOCSETSEPARATOR(char
    separator)</a><br />
     <a class="message" href="#SCI_AUTOCGETSEPARATOR">SCI_AUTOCGETSEPARATOR</a><br />
     <a class="message" href="#SCI_AUTOCSELECT">SCI_AUTOCSELECT(&lt;unused&gt;, const char
    *select)</a><br />
     <a class="message" href="#SCI_AUTOCGETCURRENT">SCI_AUTOCGETCURRENT</a><br />
     <a class="message" href="#SCI_AUTOCSETCANCELATSTART">SCI_AUTOCSETCANCELATSTART(bool
    cancel)</a><br />
     <a class="message" href="#SCI_AUTOCGETCANCELATSTART">SCI_AUTOCGETCANCELATSTART</a><br />
     <a class="message" href="#SCI_AUTOCSETFILLUPS">SCI_AUTOCSETFILLUPS(&lt;unused&gt;, const char
    *chars)</a><br />
     <a class="message" href="#SCI_AUTOCSETCHOOSESINGLE">SCI_AUTOCSETCHOOSESINGLE(bool
    chooseSingle)</a><br />
     <a class="message" href="#SCI_AUTOCGETCHOOSESINGLE">SCI_AUTOCGETCHOOSESINGLE</a><br />
     <a class="message" href="#SCI_AUTOCSETIGNORECASE">SCI_AUTOCSETIGNORECASE(bool
    ignoreCase)</a><br />
     <a class="message" href="#SCI_AUTOCGETIGNORECASE">SCI_AUTOCGETIGNORECASE</a><br />
     <a class="message" href="#SCI_AUTOCSETAUTOHIDE">SCI_AUTOCSETAUTOHIDE(bool autoHide)</a><br />
     <a class="message" href="#SCI_AUTOCGETAUTOHIDE">SCI_AUTOCGETAUTOHIDE</a><br />
     <a class="message" href="#SCI_AUTOCSETDROPRESTOFWORD">SCI_AUTOCSETDROPRESTOFWORD(bool
    dropRestOfWord)</a><br />
     <a class="message" href="#SCI_AUTOCGETDROPRESTOFWORD">SCI_AUTOCGETDROPRESTOFWORD</a><br />
     <a class="message" href="#SCI_REGISTERIMAGE">SCI_REGISTERIMAGE</a><br />
     <a class="message" href="#SCI_CLEARREGISTEREDIMAGES">SCI_CLEARREGISTEREDIMAGES</a><br />
     <a class="message" href="#SCI_AUTOCSETTYPESEPARATOR">SCI_AUTOCSETTYPESEPARATOR(char separatorCharacter)</a><br />
     <a class="message" href="#SCI_AUTOCGETTYPESEPARATOR">SCI_AUTOCGETTYPESEPARATOR</a><br />
    </code>
	<h3>SCI_AUTOCSHOW(int lenEntered, const char *list)</h3>
    <p>項目群を表示します。<code>lenEntered</code> は入力済みの文字数、<code>list</code> は特定の文字で区切られた単語項目群です。初期状態の区切り文字は空白ですが、<a class="message" href="#SCI_AUTOCSETSEPARATOR"><code>SCI_AUTOCSETSEPARATOR</code></a>
    および <a class="message"
    href="#SCI_AUTOCGETSEPARATOR"><code>SCI_AUTOCGETSEPARATOR</code></a> で変更あるいは取得が可能です。</p>
    <p class="eng"><b id="SCI_AUTOCSHOW">SCI_AUTOCSHOW(int lenEntered, const char *list)</b><br />
     This message causes a list to be displayed. <code>lenEntered</code> is the number of
    characters of the word already entered and <code>list</code> is the list of words separated by
    separator characters. The initial separator character is a space but this can be set or got
    with <a class="message" href="#SCI_AUTOCSETSEPARATOR"><code>SCI_AUTOCSETSEPARATOR</code></a>
    and <a class="message"
    href="#SCI_AUTOCGETSEPARATOR"><code>SCI_AUTOCGETSEPARATOR</code></a>.</p>

    <p>単語項目群は並べ替えが済んでいるものでなくてはなりません。 <a
    class="message" href="#SCI_AUTOCSETIGNORECASE"><code>SCI_AUTOCSETIGNORECASE</code></a> によって大文字小文字を区別しないように設定されている場合は、検索の前に大文字に変換されます。並べ替えを行った項目群は句読点文字のうち '[', '\', ']', '^', '_', '`' が他の文字の後ろに来ていなくてはならないことになります。</p>
    <p class="eng">The list of words should be in sorted order. If set to ignore case mode with <a
    class="message" href="#SCI_AUTOCSETIGNORECASE"><code>SCI_AUTOCSETIGNORECASE</code></a>, then
    strings are matched after being converted to upper case. One result of this is that the list
    should be sorted with the punctuation characters '[', '\', ']', '^', '_', and '`' sorted after
    letters.</p>
	<h3 id="SCI_AUTOCCANCEL">SCI_AUTOCCANCEL</h3>
    <p>項目群の表示を中断します。自動補完実行中、どの項目の一部分にも該当しないことになる文字の入力があったときは項目群の表示は消去されるべきです。たとえば識別子の入力中に '.', '(','[' といった文字が来た場合などです。自動補完を中断する文字の集合は  <a class="message"
    href="#SCI_AUTOCSTOPS"><code>SCI_AUTOCSTOPS</code></a> で指定できます。</p>
    <p class="eng"><b>SCI_AUTOCCANCEL</b><br />
     This message cancels any displayed autocompletion list. When in autocompletion mode, the list
    should disappear when the user types a character that can not be part of the autocompletion,
    such as '.', '(' or '[' when typing an identifier. A set of characters that will cancel
    autocompletion can be specified with <a class="message"
    href="#SCI_AUTOCSTOPS"><code>SCI_AUTOCSTOPS</code></a>.</p>
	<h3 id="SCI_AUTOCACTIVE">SCI_AUTOCACTIVE</h3>
    <p>活性化中の自動補完項目群があれば 0 以外、なければ 0 を返します。</p>
    <p class="eng"><b>SCI_AUTOCACTIVE</b><br />
     This message returns non-zero if there is an active autocompletion list and zero if there is
    not.</p>
	<h3 id="SCI_AUTOCPOSSTART">SCI_AUTOCPOSSTART</h3>
    <p><code>SCI_AUTOCSHOW</code> が項目群の表示を開始しているときに、現在位置を返します。</p>
    <p class="eng"><b>SCI_AUTOCPOSSTART</b><br />
     This returns the value of the current position when <code>SCI_AUTOCSHOW</code> started display
    of the list.</p>
	<h3 id="SCI_AUTOCCOMPLETE">SCI_AUTOCCOMPLETE</h3>
    <p>自動補完機能を活性化させます。タブキーと同じ効果を持ちます。</p>
    <p class="eng"><b>SCI_AUTOCCOMPLETE</b><br />
     This message triggers autocompletion. This has the same effect as the tab key.</p>
	<h3 id="SCI_AUTOCSTOPS">SCI_AUTOCSTOPS(&lt;unused&gt;, const char *chars)</h3>
    <p>引数 <code>chars</code> は自動補完項目群表示を自動で中断する文字の一覧になっている文字列です。エディタを開始した時点では、どの文字も自動中断を行わない設定となっています。</p>
    <p class="eng"><b>SCI_AUTOCSTOPS(&lt;unused&gt;, const char *chars)</b><br />
     The <code>chars</code> argument is a string containing a list of characters that will
    automatically cancel the autocompletion list. When you start the editor, this list is
    empty.</p>
	<h3 id="SCI_AUTOCSETSEPARATOR">SCI_AUTOCSETSEPARATOR(char separator)<br /><span id="SCI_AUTOCGETSEPARATOR">SCI_AUTOCGETSEPARATOR</span></h3>
    <p><code>SCI_AUTOCSHOW</code> で指定する項目群の区切り文字を設定もしくは取得します。初期設定は空白文字です。</p>
    <p class="eng"><b>SCI_AUTOCSETSEPARATOR(char separator)</b><br />
     <b>SCI_AUTOCGETSEPARATOR</b><br />
     These two messages set and get the separator character used to separate words in the
    <code>SCI_AUTOCSHOW</code> list. The default is the space character.</p>
	<h3 id="SCI_AUTOCSELECT">SCI_AUTOCSELECT(&lt;unused&gt;, const char *select)<br /><span id="SCI_AUTOCGETCURRENT">SCI_AUTOCGETCURRENT</span></h3>
    <p>自動補完項目群の中から<code>select</code> に最初に合致する項目を選択します。初期状態では大文字小文字を区別しますが <a class="message"
    href="#SCI_AUTOCSETIGNORECASE"><code>SCI_AUTOCSETIGNORECASE</code></a> で区別しないようにもできます。合致検査は <code>select</code> と一文字ずつ行われます。select が "Fred" であれば "Fred" で始まる項目群の最初にある例えば "Frederick" が合致するものとみなされます。項目が見つかればこれが選択されます。<a class="message"
    href="#SCI_AUTOCSETAUTOHIDE"><code>SCI_AUTOCSETAUTOHIDE</code></a> で自動消去が有効になっている場合、項目が見つからなければ項目群表示が消去されます。現在選択されている項目は <code>SCI_AUTOCGETCURRENT</code> で取得できます。</p>
    <p class="eng"><b>SCI_AUTOCSELECT(&lt;unused&gt;, const char *select)</b><br />
     <b>SCI_AUTOCGETCURRENT</b><br />
     This message selects an item in the autocompletion list. It searches the list of words for the
    first that matches <code>select</code>. By default, comparisons are case sensitive, but you can
    change this with <a class="message"
    href="#SCI_AUTOCSETIGNORECASE"><code>SCI_AUTOCSETIGNORECASE</code></a>. The match is character
    by character for the length of the <code>select</code> string. That is, if select is "Fred" it
    will match "Frederick" if this is the first item in the list that begins with "Fred". If an
    item is found, it is selected. If the item is not found, the autocompletion list closes if
    auto-hide is true (see <a class="message"
    href="#SCI_AUTOCSETAUTOHIDE"><code>SCI_AUTOCSETAUTOHIDE</code></a>).<br />
    The current selection can be retrieved with <code>SCI_AUTOCGETCURRENT</code>
    </p>
	<h3 id="SCI_AUTOCSETCANCELATSTART">SCI_AUTOCSETCANCELATSTART(bool cancel)<br />
     <span id="SCI_AUTOCGETCANCELATSTART">SCI_AUTOCGETCANCELATSTART</span></h3>
    <p>初期状態では、項目群の表示が行われたときよりもキャレットが後退方向に移動したときにその項目群が取り消されるようになっています。引数に <code>false</code> を与えて SCI_AUTOCSETCANCELATSTART を呼び出すと、補完対象となる単語の最初の文字より前に戻るまで項目群は取り消されません。</p>
    <p class="eng"><b>SCI_AUTOCSETCANCELATSTART(bool cancel)</b><br />
     <b">SCI_AUTOCGETCANCELATSTART</b><br />
     The default behavior is for the list to be cancelled if the caret moves before the location it
    was at when the list was displayed. By calling this message with a <code>false</code> argument,
    the list is not cancelled until the caret moves before the first character of the word being
    completed.</p>
	<h3 id="SCI_AUTOCSETFILLUPS">SCI_AUTOCSETFILLUPS(&lt;unused&gt;, const char *chars)</h3>
    <p>自動補完項目群が活性化しているときに決定を意味する文字を入力すると、現在選択中の項目とそれに続いてその決定を促した文字が入力されます。一般的な決定文字は '(', '[', '.' ですが、使っている言語によりその他の文字も使われます。初期状態ではこのような決定文字は定義されていません。</p>
    <p class="eng"><b>SCI_AUTOCSETFILLUPS(&lt;unused&gt;, const char *chars)</b><br />
     If a fillup character is typed with an autocompletion list active, the currently selected item
    in the list is added into the document, then the fillup character is added. Common fillup
    characters are '(', '[' and '.' but others are possible depending on the language. By default,
    no fillup characters are set.</p>
	<h3 id="SCI_AUTOCSETCHOOSESINGLE">SCI_AUTOCSETCHOOSESINGLE(bool chooseSingle)<br />
     <span id="SCI_AUTOCGETCHOOSESINGLE">SCI_AUTOCGETCHOOSESINGLE</span></h3>
    <p><code>SCI_AUTOCSETCHOOSESINGLE(1)</code> を実行している場合、項目を一つしか取り得ない状態ならば項目群の表示なしで自動的にその項目が入力されます。初期状態では、項目が一つしかない場合でも項目群の形で表示されます。</p>
    <p class="eng"><b>SCI_AUTOCSETCHOOSESINGLE(bool chooseSingle)</b><br />
     <b>SCI_AUTOCGETCHOOSESINGLE</b><br />
     If you use <code>SCI_AUTOCSETCHOOSESINGLE(1)</code> and a list has only one item, it is
    automatically added and no list is displayed. The default is to display the list even if there
    is only a single item.</p>
	<h3 id="SCI_AUTOCSETIGNORECASE">SCI_AUTOCSETIGNORECASE(bool ignoreCase)<br />
     <span id="SCI_AUTOCGETIGNORECASE">SCI_AUTOCGETIGNORECASE</span></h3>
    <p>項目群をなす項目群が大文字小文字を区別するかどうかを設定または取得します。初期状態では区別します。</p>
    <p class="eng"><b>SCI_AUTOCSETIGNORECASE(bool ignoreCase)</b><br />
     <b>SCI_AUTOCGETIGNORECASE</b><br />
     By default, matching of characters to list members is case sensitive. These messages let you
    set and get case sensitivity.</p>
	<h3 id="SCI_AUTOCSETAUTOHIDE">SCI_AUTOCSETAUTOHIDE(bool autoHide)<br />
     <span id="SCI_AUTOCGETAUTOHIDE">SCI_AUTOCGETAUTOHIDE</span></h3>
    <p>初期状態では、取りうる項目が無くなってしまった場合は項目群が取り消されます。どの項目にも合致しない入力があった場合がそれです。<code>autoHide</code> を  <code>false</code> にすると、このようなときに元の項目群を保持し続けます。この指定は <a class="message"
    href="#SCI_AUTOCSELECT"><code>SCI_AUTOCSELECT</code></a> にも影響を与えます。</p>
    <p class="eng"><b>SCI_AUTOCSETAUTOHIDE(bool autoHide)</b><br />
     <b>SCI_AUTOCGETAUTOHIDE</b><br />
     By default, the list is cancelled if there are no viable matches (the user has typed
    characters that no longer match a list entry). If you want to keep displaying the original
    list, set <code>autoHide</code> to <code>false</code>. This also effects <a class="message"
    href="#SCI_AUTOCSELECT"><code>SCI_AUTOCSELECT</code></a>.</p>
<h3 id="SCI_AUTOCSETDROPRESTOFWORD">SCI_AUTOCSETDROPRESTOFWORD(bool dropRestOfWord)<br />
     <span id="SCI_AUTOCGETDROPRESTOFWORD">SCI_AUTOCGETDROPRESTOFWORD</span></h3>
    <p><code>dropRestOfWord</code> が <code>true</code> に設定されていると、項目が選択されたときにキャレットのうしろの単語構成文字が先だって消去されます。初期設定では <code>false</code> になっています。</p>
    <p class="eng"><b>SCI_AUTOCSETDROPRESTOFWORD(bool dropRestOfWord)</b><br />
     <b>SCI_AUTOCGETDROPRESTOFWORD</b><br />
     When an item is selected, any word characters following the caret are first erased if
    <code>dropRestOfWord</code> is set <code>true</code>. The default is <code>false</code>.</p>
	<h3 id="SCI_REGISTERIMAGE">SCI_REGISTERIMAGE(int type, const char *xpmData)<br />
      <span id="SCI_CLEARREGISTEREDIMAGES">SCI_CLEARREGISTEREDIMAGES</span><br />
      <span id="SCI_AUTOCSETTYPESEPARATOR">SCI_AUTOCSETTYPESEPARATOR(char separatorCharacter)</span><br />
      <span id="SCI_AUTOCGETTYPESEPARATOR">SCI_AUTOCGETTYPESEPARATOR</span></h3>
    <p>自動補完項目群は文字列の代わりに画像で表示することもできます。各画像は整数型で登録され、'?' で区切られた項目群文字列の形で使われます。"fclose?2 fopen" という文字列は画像番号 2 を "fclose" の前に表示し、"fopen" の前には画像がないという指定になります。画像は <a class="message" href="#SCI_MARKERDEFINEPIXMAP"><code>SCI_MARKERDEFINEPIXMAP</code></a> 用の XPM 形式です。登録した画像は <code>SCI_CLEARREGISTEREDIMAGES</code> で消去できます。また、上記説明の区切り '?' は <code>SCI_AUTOCSETTYPESEPARATOR</code> で変更できます。</p>
    <p class="eng">
      <b>SCI_REGISTERIMAGE(int type, const char *xpmData)</b><br />
      <b>SCI_CLEARREGISTEREDIMAGES</b><br />
      <b>SCI_AUTOCSETTYPESEPARATOR(char separatorCharacter)</b><br />
      <b>SCI_AUTOCGETTYPESEPARATOR</b><br />

      Autocompletion list items may display an image as well as text. Each image is first registered with an integer
      type. Then this integer is included in the text of the list separated by a '?' from the text. For example,
      "fclose?2 fopen" displays image 2 before the string "fclose" and no image before "fopen".
      The images are in XPM format as is described for
      <a class="message" href="#SCI_MARKERDEFINEPIXMAP"><code>SCI_MARKERDEFINEPIXMAP</code></a>
      The set of registered images can be cleared with <code>SCI_CLEARREGISTEREDIMAGES</code> and the '?' separator changed
      with <code>SCI_AUTOCSETTYPESEPARATOR</code>.
    </p>

    <h2 id="UserLists"><span>ユーザによる項目群</span><span class="eng">User lists</span></h2>

    <p>ユーザによる項目群は、自動補完と内部的に同じ機構を使っています。自動補完機能用の呼び出しをそのまま適用することができます。自動補完項目群が活性化しているときはユーザ項目群は表示できません。また次のような違いがあります。</p>
    <p class="eng">User lists use the same internal mechanisms as autocompletion lists, and all the calls
    listed for autocompletion work on them; you cannot display a user list at the same time as an
    autocompletion list is active. They differ in the following respects:</p>

	<ul>
	<li><code><a class="message"
    href="#SCI_AUTOCSETCHOOSESINGLE">SCI_AUTOCSETCHOOSESINGLE</a></code> は無効です。</li>
	<li>ユーザが選択を行ったときは<a class="jump"
    href="#Notifications">通知メッセージ</a> <code><a class="message"
    href="#SCN_USERLISTSELECTION">SCN_USERLISTSELECTION</a></code> が送られます。</li>
	</ul>
    <p class="eng">o The <code><a class="message"
    href="#SCI_AUTOCSETCHOOSESINGLE">SCI_AUTOCSETCHOOSESINGLE</a></code> message has no
    effect.<br />
     o When the user makes a selection you are sent a <code><a class="message"
    href="#SCN_USERLISTSELECTION">SCN_USERLISTSELECTION</a></code> <a class="jump"
    href="#Notifications">notification message</a>.</p>

    <p>注意: (訳注: 原文の構造が理解不能) まだ活性化状態のユーザ項目群で使われている文字について、決定文字や停止文字に指定されている場合、エディタにユーザが文字入力をすることで、ユーザ項目群が選択されたり取り消されたりすることがあります。</p>
    <p class="eng">BEWARE: if you have set fillup characters or stop characters, these will still be active
    with the user list, and may result in items being selected or the user list cancelled due to
    the user typing into the editor.</p>
	<h3 id="SCI_USERLISTSHOW">SCI_USERLISTSHOW(int listType, const char *list)</h3>
    <p>媒介変数 <code>listType</code> は <a class="message" href="#SCNotification"><code>SCNotification</code></a> 構造体の <code>wParam</code> フィールドとしてのコンテナです。Scintilla が自動補完項目群とユーザ項目群を区別できるようにするため、これは 0 より大きくなくてはなりません。バッファの項目群とマクロの項目群、といった異種の項目群があるときは <code>listType</code> でどの種類のものを返すのか設定できます。</p>
    <p class="eng"><b>SCI_USERLISTSHOW(int listType, const char *list)</b><br />
     The <code>listType</code> parameter is returned to the container as the <code>wParam</code>
    field of the <a class="message" href="#SCNotification"><code>SCNotification</code></a>
    structure. It must be greater than 0 as this is how Scintilla tells the difference between an
    autocompletion list and a user list. If you have different types of list, for example a list of
    buffers and a list of macros, you can use <code>listType</code> to tell which one has returned
    a selection. </p>

    <h2 id="CallTips"><span>コールチップ</span><span class="eng">Call tips</span></h2>

    <p>コールチップとは関数の引数を表示する小さなウィンドウで、ユーザが関数名を入力した後に表示されるものです。コールチップは自動補完項目群との間で一部内部的動作を行います。コールチップは活性化状態の自動補完項目群を取り消す、などです。</p>
    <p class="eng">Call tips are small windows displaying the arguments to a function and are displayed after
    the user has typed the name of the function. There is some interaction between call tips and
    autocompletion lists in that showing a call tip cancels any active autocompletion list, and
    vice versa.</p>

    <p>コールチップは、その中の文字列の一部を強調することができます。カンマなどを数えて関数内の現在の引数を強調することなどに利用できます。コールチップの使い方については <code>SciTEBase.cxx</code> の <code>SciTEBase::CharAdded()</code> 関数を参照してください。</p>
    <p class="eng">Call tips can highlight part of the text within them. You could use this to highlight the
    current argument to a function by counting the number of commas (or whatever separator your
    language uses). See <code>SciTEBase::CharAdded()</code> in <code>SciTEBase.cxx</code> for an
    example of call tip use.</p>

    <p>コールチップ上でマウスボタンクリックを行うことができ、クリックされるとそのコンテナに <code><a class="message" href="#SCN_CALLTIPCLICK">SCN_CALLTIPCLICK</a></code> を送信します。'\001' や '\002' の文字を入れることで、小さな上下の矢印を表示することができます。ある関数名に対するオーバロードされた形のものを表示するときに利用し、ユーザが矢印をクリックすることでオーバロード関数を巡回させる目的などに使えます。</p>
    <p class="eng">The mouse may be clicked on call tips and this causes a
    <code><a class="message" href="#SCN_CALLTIPCLICK">SCN_CALLTIPCLICK</a></code>
    notification to be sent to the container. Small up an down arrows may be displayed within
    a call tip by, respectively, including the characters '\001', or '\002'. This is useful
    for showing that there are overloaded variants of one function name and that the user can
    click on the arrows to cycle through the overloads.</p>

    <p>そのほか、<a class="jump"
    href="#Notifications">通知</a> <code><a class="message"
    href="#SCN_DWELLSTART">SCN_DWELLSTART</a></code> への応答として、単語の上で少し止まっていたマウスカーソルが去った時にコールチップを表示させ、<code><a class="message"
    href="#SCN_DWELLEND">SCN_DWELLEND</a></code> の応答の際に消去することができます。この手法はデバッガで変数の値を表示したり、編集中にマウスカーソル下の単語についての情報を提供したりすることに使えます。</p>
    <p class="eng">Alternatively, call tips can be displayed when you leave the mouse pointer for a while over
    a word in response to the <code><a class="message"
    href="#SCN_DWELLSTART">SCN_DWELLSTART</a></code> <a class="jump"
    href="#Notifications">notification</a> and cancelled in response to <code><a class="message"
    href="#SCN_DWELLEND">SCN_DWELLEND</a></code>. This method could be used in a debugger to give
    the value of a variable, or during editing to give information about the word under the
    pointer.</p>
    <code><a class="message" href="#SCI_CALLTIPSHOW">SCI_CALLTIPSHOW(int posStart, const char
    *definition)</a><br />
     <a class="message" href="#SCI_CALLTIPCANCEL">SCI_CALLTIPCANCEL</a><br />
     <a class="message" href="#SCI_CALLTIPACTIVE">SCI_CALLTIPACTIVE</a><br />
     <a class="message" href="#SCI_CALLTIPPOSSTART">SCI_CALLTIPPOSSTART</a><br />
     <a class="message" href="#SCI_CALLTIPSETHLT">SCI_CALLTIPSETHLT(int highlightStart, int
    highlightEnd)</a><br />
     <a class="message" href="#SCI_CALLTIPSETBACK">SCI_CALLTIPSETBACK(int colour)</a><br />
     <a class="message" href="#SCI_CALLTIPSETFORE">SCI_CALLTIPSETFORE(int colour)</a><br />
     <a class="message" href="#SCI_CALLTIPSETFOREHLT">SCI_CALLTIPSETFOREHLT(int colour)</a><br />
    </code>


<h3 id="SCI_CALLTIPSHOW">SCI_CALLTIPSHOW(int posStart, const char *definition)</h3>
    <p>コールチップウィンドウの表示によってプロセスを開始します。コールチップがすでに活性化されている場合は何もしません。<br /><code>posStart</code> は、コールチップが添えられる文書内での位置です。コールチップ文字列は指定位置から一行下に沿って表示されます。<br /><code>definition</code> がコールチップに表示する文字列を定義します。 '\n' (改行、ASCII コード 10) によって複数行にすることができます。</p>
    <p class="eng"><b>SCI_CALLTIPSHOW(int posStart, const char *definition)</b><br />
     This message starts the process by displaying the call tip window. If a call tip is already
    active, this has no effect.<br />
     <code>posStart</code> is the position in the document at which to align the call tip. The call
    tip text is aligned to start 1 line below this character.<br />
     <code>definition</code> is the call tip text. This can contain multiple lines separated by
    '\n' (Line Feed, ASCII code 10) characters.</p>
	<h3 id="SCI_CALLTIPCANCEL">SCI_CALLTIPCANCEL</h3>
    <p>表示されているコールチップを消去します。Scintilla は編集中の関数における引数項目群と互換性のないキーボードによる指示を使ったときもコールチップを消去します。</p>
    <p class="eng"><b>SCI_CALLTIPCANCEL</b><br />
     This message cancels any displayed call tip. Scintilla will also cancel call tips for you if
    you use any keyboard commands that are not compatible with editing the argument list of a
    function.</p>
	<h3 id="SCI_CALLTIPACTIVE">SCI_CALLTIPACTIVE</h3>
    <p>コールチップが活性化されているならば 1 、そうでなければ 0 を返します。</p>
    <p class="eng"><b>SCI_CALLTIPACTIVE</b><br />
     This returns 1 if a call tip is active and 0 if it is not active.</p>
	<h3 id="SCI_CALLTIPPOSSTART">SCI_CALLTIPPOSSTART</h3>
    <p><code>SCI_CALLTIPSHOW</code> がコールチップを表示し始めたときにその現在位置をこのメッセージが返します。</p>
    <p class="eng"><b>SCI_CALLTIPPOSSTART</b><br />
     This message returns the value of the current position when <code>SCI_CALLTIPSHOW</code>
    started to display the tip.</p>
	<h3 id="SCI_CALLTIPSETHLT">SCI_CALLTIPSETHLT(int hlStart, int hlEnd)</h3>
    <p>強調装飾で表示するコールチップ文字列の範囲を指定します。<code>hlStart</code> は 0 基準の強調開始文字位置、<code>hlEnd</code> は次に強調されない文字の最初の位置となります。<code>hlEnd</code> は <code>hlStart</code> よりも大きくなくてはなりません。<code>hlEnd-hlStart</code> は強調する文字数となります。指定により行末より後ろも強調することもできます。</p>
    <p class="eng"><b>SCI_CALLTIPSETHLT(int hlStart, int hlEnd)</b><br />
     This sets the region of the call tips text to display in a highlighted style.
    <code>hlStart</code> is the zero-based index into the string of the first character to
    highlight and <code>hlEnd</code> is the index of the first character after the highlight.
    <code>hlEnd</code> must be greater than <code>hlStart</code>; <code>hlEnd-hlStart</code> is the
    number of characters to highlight. Highlights can extend over line ends if this is
    required.</p>

    <p>強調されていない文字は「中くらいの灰色」で描画されます。選択された文字列は暗い黒が使われます。背景色は白です。これらは <code>SCI_CALLTIPSETBACK</code>,
    <code>SCI_CALLTIPSETFORE</code>,
    <code>SCI_CALLTIPSETFOREHLT</code> で変更できます。</p>
    <p class="eng">Unhighlighted text is drawn in a mid gray. Selected text is drawn in a dark blue. The
    background is white. These can be changed with
    <code>SCI_CALLTIPSETBACK</code>,
    <code>SCI_CALLTIPSETFORE</code>, and
    <code>SCI_CALLTIPSETFOREHLT</code>.
    </p>
	<h3 id="SCI_CALLTIPSETBACK">SCI_CALLTIPSETBACK(int colour)</h3>
    <p>コールチップの背景色を設定します。初期状態では白です。選択されていない文字が灰色に、選択された文字が暗い青になっているという事情から、暗い色を背景色にするのはよくありません。</p>
    <p class="eng"><b>SCI_CALLTIPSETBACK(int colour)</b><br />
     The background colour of call tips can be set with this message; the default colour is white.
    It is not a good idea to set a dark colour as the background as the unselected text is drawn in
    mid gray and the selected text in a dark blue.</p>
	<h3 id="SCI_CALLTIPSETFORE">SCI_CALLTIPSETFORE(int colour)</h3>
    <p>コールチップ文字列の色を指定します。初期状態では暗い青です。</p>
    <p class="eng"><b>SCI_CALLTIPSETFORE(int colour)</b><br />
     The colour of call tip text can be set with this message; the default colour is mid gray.</p>
	<h3 id="SCI_CALLTIPSETFOREHLT">SCI_CALLTIPSETFOREHLT(int colour)</h3>
    <p>コールチップで強調されている文字列の色を設定します。初期状態では暗い青です。</p>
    <p class="eng"><b>SCI_CALLTIPSETFOREHLT(int colour)</b><br />
     The colour of highlighted call tip text can be set with this message; the default colour is dark blue.</p>

    <h2 id="KeyboardCommands"><span>キーボードによる指示</span><span class="eng">Keyboard commands</span></h2>

    <p>Scintilla のコンテナとなるアプリケーションが、ユーザのキー入力ですべての機能を使えるようにするという目的でキーボードによる行動はすべてメッセージにされます。これらは媒介変数をとりません。これらの指示はメッセージ <a class="message"
    href="#SCI_ASSIGNCMDKEY"><code>SCI_ASSIGNCMDKEY</code></a> によるキー割り当ての再定義でも用いられます。</p>
    <p class="eng">To allow the container application to perform any of the actions available to the user with
    keyboard, all the keyboard actions are messages. They do not take any parameters. These
    commands are also used when redefining the key bindings with the <a class="message"
    href="#SCI_ASSIGNCMDKEY"><code>SCI_ASSIGNCMDKEY</code></a> message.</p>

    <table border="0" summary="Keyboard commands">
      <tbody>
        <tr>
          <td><code>SCI_LINEDOWN</code></td>

          <td><code>SCI_LINEDOWNEXTEND</code></td>

          <td><code>SCI_LINEDOWNRECTEXTEND</code></td>

          <td><code>SCI_LINESCROLLDOWN</code></td>
        </tr>

        <tr>
          <td><code>SCI_LINEUP</code></td>

          <td><code>SCI_LINEUPEXTEND</code></td>

          <td><code>SCI_LINEUPRECTEXTEND</code></td>

          <td><code>SCI_LINESCROLLUP</code></td>
        </tr>

        <tr>
          <td><code>SCI_PARADOWN</code></td>

          <td><code>SCI_PARADOWNEXTEND</code></td>

          <td><code>SCI_PARAUP</code></td>

          <td><code>SCI_PARAUPEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_CHARLEFT</code></td>

          <td><code>SCI_CHARLEFTEXTEND</code></td>

          <td><code>SCI_CHARLEFTRECTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_CHARRIGHT</code></td>

          <td><code>SCI_CHARRIGHTEXTEND</code></td>

          <td><code>SCI_CHARRIGHTRECTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_WORDLEFT</code></td>

          <td><code>SCI_WORDLEFTEXTEND</code></td>

          <td><code>SCI_WORDRIGHT</code></td>

          <td><code>SCI_WORDRIGHTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_WORDLEFTEND</code></td>

          <td><code>SCI_WORDLEFTENDEXTEND</code></td>

          <td><code>SCI_WORDRIGHTEND</code></td>

          <td><code>SCI_WORDRIGHTENDEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_WORDPARTLEFT</code></td>

          <td><code>SCI_WORDPARTLEFTEXTEND</code></td>

          <td><code>SCI_WORDPARTRIGHT</code></td>

          <td><code>SCI_WORDPARTRIGHTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_HOME</code></td>

          <td><code>SCI_HOMEEXTEND</code></td>

          <td><code>[SCI_HOMERECTEXTEND]</code></td>
        </tr>

        <tr>
          <td><code>SCI_HOMEDISPLAY</code></td>

          <td><code>SCI_HOMEDISPLAYEXTEND</code></td>

          <td><code>SCI_HOMEWRAP</code></td>

          <td><code>SCI_HOMEWRAPEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_VCHOME</code></td>

          <td><code>SCI_VCHOMEEXTEND</code></td>

          <td><code>SCI_VCHOMERECTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_VCHOMEWRAP</code></td>

          <td><code>SCI_VCHOMEWRAPEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_LINEEND</code></td>

          <td><code>SCI_LINEENDEXTEND</code></td>

          <td><code>SCI_LINEENDRECTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_LINEENDDISPLAY</code></td>

          <td><code>SCI_LINEENDDISPLAYEXTEND</code></td>

          <td><code>SCI_LINEENDWRAP</code></td>

          <td><code>SCI_LINEENDWRAPEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_DOCUMENTSTART</code></td>

          <td><code>SCI_DOCUMENTSTARTEXTEND</code></td>

          <td><code>SCI_DOCUMENTEND</code></td>

          <td><code>SCI_DOCUMENTENDEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_PAGEUP</code></td>

          <td><code>SCI_PAGEUPEXTEND</code></td>

          <td><code>SCI_PAGEUPRECTEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_PAGEDOWN</code></td>

          <td><code>SCI_PAGEDOWNEXTEND</code></td>

          <td><code>SCI_PAGEDOWNRECTEXTEND</code></td>
        </tr>


        <tr>
          <td><code>SCI_STUTTEREDPAGEUP</code></td>

          <td><code>SCI_STUTTEREDPAGEUPEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_STUTTEREDPAGEDOWN</code></td>

          <td><code>SCI_STUTTEREDPAGEDOWNEXTEND</code></td>
        </tr>

        <tr>
          <td><code>SCI_DELETEBACK</code></td>

          <td><code>SCI_DELETEBACKNOTLINE</code></td>

          <td><code>SCI_DELWORDLEFT</code></td>

          <td><code>SCI_DELWORDRIGHT</code></td>
        </tr>

        <tr>
          <td><code>SCI_DELLINELEFT</code></td>

          <td><code>SCI_DELLINERIGHT</code></td>

          <td><code>SCI_LINEDELETE</code></td>
        </tr>

        <tr>
          <td><code>SCI_LINECUT</code></td>

          <td><code>SCI_LINECOPY</code></td>

          <td><code>SCI_LINETRANSPOSE</code></td>

          <td><code>SCI_LINEDUPLICATE</code></td>
        </tr>

        <tr>
          <td><code>SCI_LOWERCASE</code></td>

          <td><code>SCI_UPPERCASE</code></td>

          <td><code>SCI_CANCEL</code></td>

          <td><code>SCI_EDITTOGGLEOVERTYPE</code></td>
        </tr>

        <tr>
          <td><code>SCI_NEWLINE</code></td>

          <td><code>SCI_FORMFEED</code></td>

          <td><code>SCI_TAB</code></td>

          <td><code>SCI_BACKTAB</code></td>
        </tr>
     </tbody>
    </table>

    <p><code>SCI_*EXTEND</code> は選択範囲を拡げます。</p>
    <p class="eng">The <code>SCI_*EXTEND</code> messages extend the selection.</p>

    <p><code>SCI_*RECTEXTEND</code> は矩形選択を拡げ、通常の選択範囲があればこれを矩形選択に変換します。</p>
    <p class="eng">The <code>SCI_*RECTEXTEND</code> messages extend the rectangular selection
    (and convert regular selection to rectangular one, if any).</p>

    <p><code>SCI_WORDPART*</code> は単語要素間の移動に使われます。大文字毎 (aCamelCaseIdentifier) か 下線毎 (an_under_bar_ident) に印づけられた位置を移動します。</p>
    <p class="eng">The <code>SCI_WORDPART*</code> commands are used to move between word segments marked by
    capitalisation (aCamelCaseIdentifier) or underscores (an_under_bar_ident).</p>

    <p><code>SCI_HOME*</code> は行頭にキャレットを移動します。<code>SCI_VCHOME*</code> が行内の最初の非空白文字種に(つまり字下げの直後に)移動するのに対して、いきなり行頭へ移動します。<code>SCI_VCHOME*</code> のときでも、すでに字下げ直後に移動している場合は <code>SCI_HOME*</code> と同じ動作になります。</p>
    <p class="eng">The <code>SCI_HOME*</code> commands move the caret to the start of the line, while the
    <code>SCI_VCHOME*</code>commands move the caret to the first non-blank character of the line
    (ie. just after the indentation) unless it is already there; in this case, it acts as SCI_HOME*.</p>

    <p><code>SCI_[HOME|LINEEND]</code> は行頭または行末に移動します。これに対し、行クリップを有効にしているときに <code>SCI_[HOME|LINEEND]DISPLAY*</code> を実行すると表示行単位での行頭または行末に移動します。</p>
    <p class="eng">The <code>SCI_[HOME|LINEEND]DISPLAY*</code> commands are used when in line wrap mode to
    allow movement to the start or end of display lines as opposed to the normal
    <code>SCI_[HOME|LINEEND]</code> commands which move to the start or end of document lines.</p>

    <p><code>SCI_[[VC]HOME|LINEEND]WRAP*</code> と <code>SCI_[[VC]HOME|LINEEND]*</code> は行クリップが有効なときに異なる動作をします。<code>SCI_[HOME|LINEEND]DISPLAY*</code> 同様に いずれも最初は表示行単位での行頭もしくは行末に移動します。すでにその位置にあるときは、<code>SCI_[[VC]HOME|LINEEND]*</code> だけが論理行の先頭に移動します。</p>
    <p class="eng">The <code>SCI_[[VC]HOME|LINEEND]WRAP*</code> commands are like their namesakes
    <code>SCI_[[VC]HOME|LINEEND]*</code> except they behave differently when word-wrap is enabled:
     They go first to the start / end of the display line, like <code>SCI_[HOME|LINEEND]DISPLAY*</code>,
     but if the cursor is already at the point, it goes on to the start or end of the document line,
     as appropriate for <code>SCI_[[VC]HOME|LINEEND]*</code>.
     </p>

    <h2 id="KeyBindings"><span>キー割り当て</span><span class="eng">Key bindings</span></h2>

    <p>Scintilla のソースファイル <code>KeyMap.cxx</code> の中で定数 <code>KeyMap::MapDefault[]</code> がキー入力による指示の初期設定を定義しています。この表はキーを、媒介変数のない <code>SCI_*</code> メッセージ群に対応づけています。大部分は前掲の <a
    class="jump" href="#KeyboardCommands">キーボードによる指示</a> がこれに当たるのですが媒介変数のない Scintilla の指示であれば何でも割り当てができます。自分の好みに合うようにキー割り当てを変更することができます。</p>
    <p class="eng">There is a default binding of keys to commands that is defined in the Scintilla source in
    the file <code>KeyMap.cxx</code> by the constant <code>KeyMap::MapDefault[]</code>. This table
    maps key definitions to <code>SCI_*</code> messages with no parameters (mostly the <a
    class="jump" href="#KeyboardCommands">keyboard commands</a> discussed above, but any Scintilla
    command that has no arguments can be mapped). You can change the mapping to suit your own
    requirements.</p>
    <code><a class="message" href="#SCI_ASSIGNCMDKEY">SCI_ASSIGNCMDKEY(int keyDefinition, int
    sciCommand)</a><br />
     <a class="message" href="#SCI_CLEARCMDKEY">SCI_CLEARCMDKEY(int keyDefinition)</a><br />
     <a class="message" href="#SCI_CLEARALLCMDKEYS">SCI_CLEARALLCMDKEYS</a><br />
     <a class="message" href="#SCI_NULL">SCI_NULL</a><br />
    </code>
	<h3 id="keyDefinition">keyDefinition</h3>
    <p>キー定義は下位 16 ビットのキーコード、上位 16 ビットの修飾キーからなっています。<code>キーコード</code> と <code>修飾キー</code> は次のようにして結合します。</p>
	<p><code>キー定義 = キーコード + (修飾キー &lt;&lt; 16)</code></p>
    <p class="eng"><b>keyDefinition</b><br />
     A key definition contains the key code in the low 16-bits and the key modifiers in the high
    16-bits. To combine <code>keyCode</code> and <code>keyMod</code> set:<br />
    <br />
     <code>keyDefinition = keyCode + (keyMod &lt;&lt; 16)</code></p>

    <p>キーコードは可視であるか制御文字であるか、あるいは <code>SCK_*</code> に列挙されているものです。列挙されているものには次のものがあります。<br />
     <code>SCK_ADD</code>, <code>SCK_BACK</code>, <code>SCK_DELETE</code>, <code>SCK_DIVIDE</code>,
    <code>SCK_DOWN</code>, <code>SCK_END</code>, <code>SCK_ESCAPE</code>, <code>SCK_HOME</code>,
    <code>SCK_INSERT</code>, <code>SCK_LEFT</code>, <code>SCK_NEXT</code> (Page Down),
    <code>SCK_PRIOR</code> (Page Up), <code>SCK_RETURN</code>, <code>SCK_RIGHT</code>,
    <code>SCK_SUBTRACT</code>, <code>SCK_TAB</code>, <code>SCK_UP</code>.</p>
    <p class="eng">The key code is a visible or control character or a key from the <code>SCK_*</code>
    enumeration, which contains:<br />
     <code>SCK_ADD</code>, <code>SCK_BACK</code>, <code>SCK_DELETE</code>, <code>SCK_DIVIDE</code>,
    <code>SCK_DOWN</code>, <code>SCK_END</code>, <code>SCK_ESCAPE</code>, <code>SCK_HOME</code>,
    <code>SCK_INSERT</code>, <code>SCK_LEFT</code>, <code>SCK_NEXT</code> (Page Down),
    <code>SCK_PRIOR</code> (Page Up), <code>SCK_RETURN</code>, <code>SCK_RIGHT</code>,
    <code>SCK_SUBTRACT</code>, <code>SCK_TAB</code>, and <code>SCK_UP</code>.</p>

    <p>修飾キーは 0 と <code>SCMOD_ALT</code>,
    <code>SCMOD_CTRL</code>, <code>SCMOD_SHIFT</code> の結合で表します。表を作るときには修飾キーのないことを意味する <code>SCMOD_NORM</code> を使うこともできます。</p>
    <p class="eng">The modifiers are a combination of zero or more of <code>SCMOD_ALT</code>,
    <code>SCMOD_CTRL</code>, and <code>SCMOD_SHIFT</code>. If you are building a table, you might
    want to use <code>SCMOD_NORM</code>, which has the value 0, to mean no modifiers.</p>
	<h3 id="SCI_ASSIGNCMDKEY">SCI_ASSIGNCMDKEY(int <a class="jump"
    href="#keyDefinition">keyDefinition</a>, int sciCommand)</h3>
    <p>指定したキーの定義を Scintilla への指示 <code>sciCommand</code> と結びつけます。<code>sciCommand</code> には引数のない任意の <code>SCI_*</code> 指示を指定することができます。</p>
    <p class="eng"><b>SCI_ASSIGNCMDKEY(int <a class="jump"
    href="#keyDefinition">keyDefinition</a>, int sciCommand)</b><br />
     This assigns the given key definition to a Scintilla command identified by
    <code>sciCommand</code>. <code>sciCommand</code> can be any <code>SCI_*</code> command that has
    no arguments.</p>
	<h3 id="SCI_CLEARCMDKEY">SCI_CLEARCMDKEY(int <a class="jump"
    href="#keyDefinition">keyDefinition</a>)</h3>
    <p>キーの定義に何もしないことを意味する <code>SCI_NULL</code> を割り当てます。</p>
    <p class="eng"><b>SCI_CLEARCMDKEY(int <a class="jump"
    href="#keyDefinition">keyDefinition</a>)</b><br />
     This makes the given key definition do nothing by assigning the action <code>SCI_NULL</code>
    to it.</p>
	<h3 id="SCI_CLEARALLCMDKEYS">SCI_CLEARALLCMDKEYS</h3>
    <p>すべてのキー割り当てを改称します。空の割り当て表が使われます。</p>
    <p class="eng"><b>SCI_CLEARALLCMDKEYS</b><br />
     This command removes all keyboard command mapping by setting an empty mapping table.</p>
	<h3 id="SCI_NULL">SCI_NULL</h3>
    <p><code>SCI_NULL</code> は何もしないことを意味する値で、キー定義に割り当てる目的でこの値があります。</p>
    <p class="eng"><b id="SCI_NULL">SCI_NULL</b><br />
     The <code>SCI_NULL</code> does nothing and is the value assigned to keys that perform no
    action.</p>

    <h2 id="PopupEditMenu"><span>ポップアップ編集メニュー</span><span class="eng">Popup edit menu</span></h2>
	<h3 id="SCI_USEPOPUP">SCI_USEPOPUP(bool bEnablePopup)</h3>
    <p>マウスの誤ったボタンをクリックすると小さな初期状態の編集メニューが出てきます。これを抑制するには <code>SCI_USEPOPUP(0)</code> を実行します。抑制されている場合は Scintilla がコンテキストメニュー指示 (Windows では <code>WM_CONTEXTMENU</code>) を扱わないようになります。この結果 Scintilla の親ウィンドウはメッセージを扱う機会を得ることができます。</p>
    <p class="eng"><b id="SCI_USEPOPUP">SCI_USEPOPUP(bool bEnablePopup)</b><br />
     Clicking the wrong button on the mouse pops up a short default editing menu. This may be
    turned off with <code>SCI_USEPOPUP(0)</code>. If you turn it off, context menu commands (in
    Windows, <code>WM_CONTEXTMENU</code>) will not be handled by Scintilla, so the parent of the
    Scintilla window will have the opportunity to handle the message.</p>

    <h2 id="MacroRecording"><span>マクロの記録</span><span class="eng">Macro recording</span></h2>

    <p>ここではマクロ記録の開始と停止についてを記述します。マクロ記録モードでは、行動がコンテナに<a class="jump" href="#Notifications">通知</a> <code><a class="message" href="#SCN_MACRORECORD">SCN_MACRORECORD</a></code> を通して報告されます。将来再現するためにこれらの行動を記録するのはコンテナまで関わってきます。
    </p>
    <p class="eng">Start and stop macro recording mode. In macro recording mode, actions are reported to the
    container through <code><a class="message" href="#SCN_MACRORECORD">SCN_MACRORECORD</a></code>
    <a class="jump" href="#Notifications">notifications</a>. It is then up to the container to
    record these actions for future replay.</p>
	<h3 id="SCI_STARTRECORD">SCI_STARTRECORD<br /><span id="SCI_STOPRECORD">SCI_STOPRECORD</span></h3>
    <p>マクロ記録の開始または停止を行います。</p>
    <p class="eng"><b>SCI_STARTRECORD</b><br />
     <b>SCI_STOPRECORD</b><br />
     These two messages turn macro recording on and off.</p>

    <h2 id="Printing"><span>印刷</span><span class="eng">Printing</span></h2>

    <p>Windows では <code>SCI_FORMATRANGE</code> を使って表示コンテキスト上に文字を描画することができます。これにはプリンタ表示コンテキストも含まれます。印刷出力には文字列の装飾が画面同様になされますが、行番号以外の余白、特殊マーカ効果、選択範囲、キャレットは印刷されません。</p>
    <p class="eng">On Windows <code>SCI_FORMATRANGE</code> can be used to draw the text onto a display context
    which can include a printer display context. Printed output shows text styling as on the
    screen, but it hides all margins except a line number margin. All special marker effects are
    removed and the selection and caret are hidden.</p>
    <code><a class="message" href="#SCI_FORMATRANGE">SCI_FORMATRANGE(bool bDraw, RangeToFormat
    *pfr)</a><br />
     <a class="message" href="#SCI_SETPRINTMAGNIFICATION">SCI_SETPRINTMAGNIFICATION(int
    magnification)</a><br />
     <a class="message" href="#SCI_GETPRINTMAGNIFICATION">SCI_GETPRINTMAGNIFICATION</a><br />
     <a class="message" href="#SCI_SETPRINTCOLOURMODE">SCI_SETPRINTCOLOURMODE(int mode)</a><br />
     <a class="message" href="#SCI_GETPRINTCOLOURMODE">SCI_GETPRINTCOLOURMODE</a><br />
     <a class="message" href="#SCI_SETPRINTWRAPMODE">SCI_SETPRINTWRAPMODE</a><br />
     <a class="message" href="#SCI_GETPRINTWRAPMODE">SCI_GETPRINTWRAPMODE</a><br />
    </code>
	<h3 id="SCI_FORMATRANGE">SCI_FORMATRANGE(bool bDraw, RangeToFormat *pfr)</h3>
    <p>Windows で、指定範囲の文字列をデバイスコンテキストにレンダリングします。これを印刷に用いた場合、ページのヘッダやフッタも欲しいところですが、Scintilla は特に何もしません。<code>SciTEWinDlg.cxx</code> の <code>SciTEWin::Print()</code>のコードを例として参照してください。これらのメッセージはそれぞれテキストを矩形範囲にレンダリングし、文書内で次に印刷を始める位置を返します。</p>
    <p class="eng"><b>SCI_FORMATRANGE(bool bDraw, RangeToFormat *pfr)</b><br />
     This call allows Windows users to render a range of text into a device context. If you use
    this for printing, you will probably want to arrange a page header and footer; Scintilla does
    not do this for you. See <code>SciTEWin::Print()</code> in <code>SciTEWinDlg.cxx</code> for an
    example. Each use of this message renders a range of text into a rectangular area and returns
    the position in the document of the next character to print.</p>

    <p><code>bDraw</code> は出力が実行されたかどうかを制御します。丁づけする場合は false にしてください。たとえば MFC でつかうなら各頁を出力する前に <code>OnBeginPrinting()</code> の中で丁づけする必要があるでしょう。</p>
    <p class="eng"><code>bDraw</code> controls if any output is done. Set this to false if you are paginating
    (for example, if you use this with MFC you will need to paginate in
    <code>OnBeginPrinting()</code> before you output each page.</p>
<pre>
struct RangeToFormat {
    SurfaceID hdc;        // 印刷の対象となる HDC (デバイスコンテキスト)
    SurfaceID hdcTarget;  // 計測に使う HDC (hdc と同じでよい)
    PRectangle rc;        // 印刷範囲を示す矩形
    PRectangle rcPage;    // 物理的なページの大きさ
    CharacterRange chrg;  // 印刷する文字の範囲
};
</pre>
<pre class="eng">
struct RangeToFormat {
    SurfaceID hdc;        // The HDC (device context) we print to
    SurfaceID hdcTarget;  // The HDC we use for measuring (may be same as hdc)
    PRectangle rc;        // Rectangle in which to print
    PRectangle rcPage;    // Physically printable page size
    CharacterRange chrg;  // Range of characters to print
};
</pre>

    <p><code>hdc</code> と <code>hdcTarget</code> は両方とも出力デバイス(通常はプリンタ)のデバイスコンテキストハンドルです。Windows メタファイル(拡張メタファイルではないようなもの)とは異なるメタファイルに印刷するときは、返値の情報にすべての API を実装しないでください。この場合、<code>hdcTarget</code> には画面のデバイスコンテキストを設定します。<br /><code>rcPage</code> は <code>{0, 0, maxX, maxY}</code> の形で指定する矩形です。<code>maxX+1</code> と <code>maxY+1</code> は物理的な印刷可能ピクセル数の横方向と縦方向の値です。<br /><code>rc</code> はテキストをレンダリングする範囲です。当然ながら rcPage の内側に収まるように指定します。<br /><code>chrg.cpMin</code> と<code>chrg.cpMax</code> は出力する文字の開始位置と最大位置を指定します。</p>
    <p class="eng"><code>hdc</code> and <code>hdcTarget</code> should both be set to the device context handle
    of the output device (usually a printer). If you print to a metafile these will not be the same
    as Windows metafiles (unlike extended metafiles) do not implement the full API for returning
    information. In this case, set <code>hdcTarget</code> to the screen DC.<br />
     <code>rcPage</code> is the rectangle <code>{0, 0, maxX, maxY}</code> where <code>maxX+1</code>
    and <code>maxY+1</code> are the number of physically printable pixels in x and y.<br />
     <code>rc</code> is the rectangle to render the text in (which will, of course, fit within the
    rectangle defined by rcPage).<br />
     <code>chrg.cpMin</code> and <code>chrg.cpMax</code> define the start position and maximum
    position of characters to output.</p>

    <p>印刷に当たってもっとも面倒なのは、ヘッダとフッタの印刷や印刷不可区域を考えた上の余白をどうすればいいかいうことです。SciTE の印刷に関するコードでは、その大部分をこの構造体によって定めています。余白、印刷不可区域、ヘッダ、フッタを切り落としてしまえば Scintilla のテキストレンダリングループはとても単純です。</p>
    <p class="eng">When printing, the most tedious part is always working out what the margins should be to
    allow for the non-printable area of the paper and printing a header and footer. If you look at
    the printing code in SciTE, you will find that most of it is taken up with this. The loop that
    causes Scintilla to render text is quite simple if you strip out all the margin, non-printable
    area, header and footer code.</p>
	<h3 id="SCI_SETPRINTMAGNIFICATION">SCI_SETPRINTMAGNIFICATION(int magnification)<br />
     <span id="SCI_GETPRINTMAGNIFICATION">SCI_GETPRINTMAGNIFICATION</span></h3>
    <p>画面のフォントとは異なる大きさで印刷するには <code>SCI_GETPRINTMAGNIFICATION</code> を用います。<code>magnification</code> は画面上での大きさに加算される値でポイント単位です。-3 や -4 は小さく印刷するの便利です。この値は <code>SCI_GETPRINTMAGNIFICATION</code> で取得できます。</p>
    <p class="eng"><b>SCI_SETPRINTMAGNIFICATION(int magnification)</b><br />
     <b>SCI_GETPRINTMAGNIFICATION</b><br />
     <code>SCI_GETPRINTMAGNIFICATION</code> lets you to print at a different size than the screen
    font. <code>magnification</code> is the number of points to add to the size of each screen
    font. A value of -3 or -4 gives reasonably small print. You can get this value with
    <code>SCI_GETPRINTMAGNIFICATION</code>.</p>
	<h3 id="SCI_SETPRINTCOLOURMODE">SCI_SETPRINTCOLOURMODE(int mode)<br />
     <span id="SCI_GETPRINTCOLOURMODE">SCI_GETPRINTCOLOURMODE</span></h3>
    <p>通常白紙を使うプリンタで色が付いたテキストをレンダリングする手法を設定あるいは取得します。画面上では暗い色あるいは黒の背景色を使っている場合には色の扱いの考慮はとても重要なこととなります。黒字に白という印刷は他の方法よりもトナーとインクを速く使い切ってしまいます。以下のうちから一つ、モードを設定できます。</p>
    <p class="eng"><b>SCI_SETPRINTCOLOURMODE(int mode)</b><br />
     <b>SCI_GETPRINTCOLOURMODE</b><br />
     These two messages set and get the method used to render coloured text on a printer that is
    probably using white paper. It is especially important to consider the treatment of colour if
    you use a dark or black screen background. Printing white on black uses up toner and ink very
    many times faster than the other way around. You can set the mode to one of:</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="Colour printing modes">
      <tbody>
        <tr>
          <th align="left">定数名</th>

          <th>値</th>

          <th align="left">目的</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_PRINT_NORMAL</code></td>

          <td align="center">0</td>

          <td>現在の画面の色をそのまま印刷します。これが初期状態です。</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_INVERTLIGHT</code></td>

          <td align="center">1</td>

          <td>暗い背景色の場合は、明度を反転して白地に印刷することでインクを節約します。</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_BLACKONWHITE</code></td>

          <td align="center">2</td>

          <td>すべての文字を白地に黒文字で印刷します。</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_COLOURONWHITE</code></td>

          <td align="center">3</td>

          <td>白地に画面通りの色で印刷します。</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_COLOURONWHITEDEFAULTBG</code></td>

          <td align="center">4</td>

          <td>白地に画面通りの色で印刷しますが、行番号だけは自分自身の背景色を使います。</td>
        </tr>
      </tbody>
    </table>


    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Colour printing modes">
      <tbody>
        <tr>
          <th align="left">Symbol</th>

          <th>Value</th>

          <th align="left">Purpose</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_PRINT_NORMAL</code></td>

          <td align="center">0</td>

          <td>Print using the current screen colours. This is the default.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_INVERTLIGHT</code></td>

          <td align="center">1</td>

          <td>If you use a dark screen background this saves ink by inverting the light value of
          all colours and printing on a white background.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_BLACKONWHITE</code></td>

          <td align="center">2</td>

          <td>Print all text as black on a white background.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_COLOURONWHITE</code></td>

          <td align="center">3</td>

          <td>Everything prints in its own colour on a white background.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PRINT_COLOURONWHITEDEFAULTBG</code></td>

          <td align="center">4</td>

          <td>Everything prints in its own colour on a white background except that line numbers
          use their own background colour.</td>
        </tr>
      </tbody>
    </table>

	<h3 id="SCI_SETPRINTWRAPMODE">SCI_SETPRINTWRAPMODE(int wrapMode)<br />
     <span id="SCI_GETPRINTWRAPMODE">SCI_GETPRINTWRAPMODE</span></h3>
	<p>プリンタの行クリップモードを設定または取得します。<code>wrapMode</code> は <code>SC_WRAP_NONE</code> (0) と <code>SC_WRAP_WORD</code> (1) のいずれかです。初期設定では <code>SC_WRAP_WORD</code> になっており、これは行クリップを行うのですべての文字が印刷範囲の矩形に収まります。<code>SC_WRAP_NONE</code> を指定すると、文書の各行が一行として出力されますので、印刷範囲からはみ出るような長い行は切り捨てられてしまいます。</p>
	<p>SC_WRAP_CHAR (2) は SC_WRAP_WORD と異なり行クリップのために空白文字列を検索せず、必要な場所で文字を問わずに折り返すようになります。日本語のように空白文字類を原則的に利用しない自然言語を使うときのために訳者が実装したものです。</p>
    <p class="eng"><b>SCI_SETPRINTWRAPMODE(int wrapMode)</b><br />
     <b>SCI_GETPRINTWRAPMODE</b><br />
     These two functions get and set the printer wrap mode. <code>wrapMode</code> can be
     set to <code>SC_WRAP_NONE</code> (0) or <code>SC_WRAP_WORD</code> (1). The default is
     <code>SC_WRAP_WORD</code>, which wraps printed output so that all characters fit
     into the print rectangle. If you set <code>SC_WRAP_NONE</code>, each line of text
     generates one line of output and the line is truncated if it is too long to fit
     into the print area.</p>

    <h2 id="DirectAccess"><span>直接アクセス</span><span class="eng">Direct access</span></h2>
    <code><a class="message" href="#SCI_GETDIRECTFUNCTION">SCI_GETDIRECTFUNCTION</a><br />
     <a class="message" href="#SCI_GETDIRECTPOINTER">SCI_GETDIRECTPOINTER</a><br />
    </code>

    <p>Windows では、Scintilla とそのコンテナとの間のメッセージ受け渡し手順は OS の <code>SendMessage</code> 関数によって実装されており、集中的に呼び出したときには処理速度が落ちてしまいます。このオーバヘッドを避けるため、Scintilla はそのメッセージ関数を直接呼び出すメッセージを提供しています。C/C++ ではこれを次の形で行います。</p>
    <p class="eng">On Windows, the message-passing scheme used to communicate between the container and
    Scintilla is mediated by the operating system <code>SendMessage</code> function and can lead to
    bad performance when calling intensively. To avoid this overhead, Scintilla provides messages
    that allow you to call the Scintilla message function directly. The code to do this in C/C++ is
    of the form:</p>
<pre>
#include "Scintilla.h"
SciFnDirect pSciMsg = (SciFnDirect)SendMessage(hSciWnd, SCI_GETDIRECTFUNCTION, 0, 0);
sptr_t pSciWndData = (sptr_t)SendMessage(hSciWnd, SCI_GETDIRECTPOINTER, 0, 0);

// now a wrapper to call Scintilla directly
sptr_t CallScintilla(unsigned int iMessage, uptr_t wParam, sptr_t lParam){
    return pSciMsg(pSciWndData, iMessage, wParam, lParam);
}
</pre>

    <p><code>SciFnDirect</code>, <code>sptr_t</code>, <code>uptr_t</code> は <code>Scintilla.h</code> で宣言されています。<code>hSciWnd</code> は Scintilla ウィンドウを作ったときに返されているウィンドウハンドルです。</p>
    <p class="eng"><code>SciFnDirect</code>, <code>sptr_t</code> and <code>uptr_t</code> are declared in
    <code>Scintilla.h</code>. <code>hSciWnd</code> is the window handle returned when you created
    the Scintilla window.</p>

    <p>この直接呼び出しは高速ですが、Scintilla ウィンドウがあるものとは異なるスレッドから呼び出すと問題を起こします。<code>SendMessage(hSciWnd, SCI_*,
    wParam, lParam)</code> はウィンドウのスレッドと同期を取らなくてはならないからです。</p>
    <p class="eng">While faster, this direct calling will cause problems if performed from a different thread
    to the native thread of the Scintilla window in which case <code>SendMessage(hSciWnd, SCI_*,
    wParam, lParam)</code> should be used to synchronize with the window's thread.</p>

    <p>この機能は GTK+ でも動作しますが、明示的な高速化には繋がりません。</p>
    <p class="eng">This feature also works on GTK+ but has no significant impact on speed.</p>

    <p>版 1.47 以降、Windows においては Scintilla が <code>Scintilla_DirectFunction</code> 関数をエクスポートしています。これは <code>SCI_GETDIRECTFUNCTION</code> の戻り値と同じように使うことができます。これを使うと <code>SCI_GETDIRECTFUNCTION</code> の呼び出しを省略し、関数ポインタを介して Scintilla を直接呼び出す必要がなくなります。</p>
    <p class="eng">From version 1.47 on Windows, Scintilla exports a function called
    <code>Scintilla_DirectFunction</code> that can be used the same as the function returned by
    <code>SCI_GETDIRECTFUNCTION</code>. This saves you the call to
    <code>SCI_GETDIRECTFUNCTION</code> and the need to call Scintilla indirectly via the function
    pointer.</p>
	<h3 id="SCI_GETDIRECTFUNCTION">SCI_GETDIRECTFUNCTION</h3>
    <p>Scintilla のメッセージを扱う関数へのポインタのアドレスを返します。このポインタを使って Windows のメッセージ系を通すことによるオーバヘッドを回避することができます。Scintilla のウィンドウがいくつあっても、この関数を呼び出すのは一度で構いません。</p>
    <p class="eng"><b>SCI_GETDIRECTFUNCTION</b><br />
     This message returns the address of the function to call to handle Scintilla messages without
    the overhead of passing through the Windows messaging system. You need only call this once,
    regardless of the number of Scintilla windows you create.</p>
	<h3 id="SCI_GETDIRECTPOINTER">SCI_GETDIRECTPOINTER</h3>
    <p>Scintilla ウィンドウが使用中のデータへのポインタを返します。これは Scintilla ウィンドウを作る毎に一度呼び出す必要があります。直接関数を呼び出すときは、対象ウィンドウに関係づけられた直接ポインタを渡さなくてはなりません。</p>
    <p class="eng"><b>SCI_GETDIRECTPOINTER</b><br />
     This returns a pointer to data that identifies which Scintilla window is in use. You must call
    this once for each Scintilla window you create. When you call the direct function, you must
    pass in the direct pointer associated with the target window.</p>

    <h2 id="MultipleViews"><span>可視部の多重化</span><span class="eng">Multiple views</span></h2>

    <p>Scintilla のウィンドウとその中に表示する文書とは別々の実体になっています。新しいウィンドウを作る時、同じように新しい空の文書も作ります。文書はそれぞれ初期値が 1 の参照値を持っています。文書は Scintilla ウィンドウの一覧をも持っていて、それで Scintilla ウィンドウに接続しています。ですから、あるウィンドウの中で文書が変更されたら文書から接続されている他のウィンドウは更新を求める通知を受け取ります。このような形になっているため、単一の Scintilla ウィンドウで多くの文書を扱うこともできますし、単一の文書をスプリッタを用いた複数のウィンドウで表示することもできます。</p>
    <p class="eng">A Scintilla window and the document that it displays are separate entities. When you create
    a new window, you also create a new, empty document. Each document has a reference count that
    is initially set to 1. The document also has a list of the Scintilla windows that are linked to
    it so when any window changes the document, all other windows in which it appears are notified
    to cause them to update. The system is arranged in this way so that you can work with many
    documents in a single Scintilla window and so you can display a single document in multiple
    windows (for use with splitter windows).</p>

    <p>これらのメッセージは将来の Scintilla との互換性のために <code>document *pDoc</code> を用いますが、<code>pDoc</code> は不透明な <code>void*</code> として扱わなくてはなりません。本節に説明するポインタとして利用あるいは格納することができますが、参照を解除することはできません。</p>
    <p class="eng">Although these messages use <code>document *pDoc</code>, to ensure compatibility with future
    releases of Scintilla you should treat <code>pDoc</code> as an opaque <code>void*</code>. That
    is, you can use and store the pointer as described in this section but you should not
    dereference it.</p>
    <code><a class="message" href="#SCI_GETDOCPOINTER">SCI_GETDOCPOINTER</a><br />
     <a class="message" href="#SCI_SETDOCPOINTER">SCI_SETDOCPOINTER(&lt;unused&gt;, document
    *pDoc)</a><br />
     <a class="message" href="#SCI_CREATEDOCUMENT">SCI_CREATEDOCUMENT</a><br />
     <a class="message" href="#SCI_ADDREFDOCUMENT">SCI_ADDREFDOCUMENT(&lt;unused&gt;, document
    *pDoc)</a><br />
     <a class="message" href="#SCI_RELEASEDOCUMENT">SCI_RELEASEDOCUMENT(&lt;unused&gt;, document
    *pDoc)</a><br />
    </code>
	<h3 id="SCI_GETDOCPOINTER">SCI_GETDOCPOINTER</h3>
    <p>ウィンドウに現在使われている文書へのポインタを返します。他には何もしません。</p>
    <p class="eng"><b>SCI_GETDOCPOINTER</b><br />
     This returns a pointer to the document currently in use by the window. It has no other
    effect.</p>
	<h3 id="SCI_SETDOCPOINTER">SCI_SETDOCPOINTER(&lt;unused&gt;, document *pDoc)</h3>
    <p>次のことを行います。</p>
	<ol>
	<li>現在の文書に保持されている一覧から現在のウィンドウを取り除きます。</li>
	<li>その文書の参照数をひとつ減らします。</li>
	<li>参照数が 0 になったら、その文書を削除します。</li>
	<li><code>pDoc</code> を先ほど除かれたウィンドウの新しい文書として設定します。</li>
	<li><code>pDoc</code> が 0 のときは新しい空の文書が作成され、同様にそのウィンドウに接続されます。</li>
	</ol>
<p class="eng"><b>SCI_SETDOCPOINTER(&lt;unused&gt;, document *pDoc)</b><br />
     This message does the following:<br />
     1. It removes the current window from the list held by the current document.<br />
     2. It reduces the reference count of the current document by 1.<br />
     3. If the reference count reaches 0, the document is deleted.<br />
     4. <code>pDoc</code> is set as the new document for the window.<br />
     5. If <code>pDoc</code> was 0, a new, empty document is created and attached to the
    window.</p>
	<h3 id="SCI_CREATEDOCUMENT">SCI_CREATEDOCUMENT</h3>
    <p>新しい空の文書を作成し、それへのポインタを返します。この文書はエディタに選択されておらず、一方で参照数は 1 になっています。ですから、文書の所有権はポインタを返されたコードにあります。<code>SCI_SETDOCPOINTER</code> を使った後に参照数をひとつ減らして Scitilla ウィンドウに文書を所有させるか、アプリケーション終了前に <code>SCI_RELEASEDOCUMENT</code>  で参照数をひとつ減らすかしてメモリーリークを避ける必要があります。</p>
    <p class="eng"><b>SCI_CREATEDOCUMENT</b><br />
     This message creates a new, empty document and returns a pointer to it. This document is not
    selected into the editor and starts with a reference count of 1. This means that you have
    ownership of it and must either reduce its reference count by 1 after using
    <code>SCI_SETDOCPOINTER</code> so that the Scintilla window owns it or you must make sure that
    you reduce the reference count by 1 with <code>SCI_RELEASEDOCUMENT</code> before you close the
    application to avoid memory leaks.</p>
	<h3 id="SCI_ADDREFDOCUMENT">SCI_ADDREFDOCUMENT(&lt;unused&gt;, document *pDoc)</h3>
    <p>文書の参照数をひとつ増やします。Scintilla ウィンドウの現在注目中の文書を交換し、またその所有権を持ちたい場合は次の手順を踏みます。一つのウィンドウで多数の文書を編集する場合がこれにあたります。</p>
	<ol>
	<li><code>SCI_GETDOCPOINTER</code> を用いて文書へのポインタを取得します。</li>
	<li><code>SCI_ADDREFDOCUMENT(0, pDoc)</code> というコードで参照数を増やします。</li>
	<li><code>SCI_SETDOCPOINTER(0, pNewDoc)</code> というコードで別の文書を割り当てます。新しく割り当てる文書へのポインタ <code>pNewDoc</code> が 0 であったときは、新しい空の文書が割り当てられます。</li>
	</ol>
    <p class="eng"><b>SCI_ADDREFDOCUMENT(&lt;unused&gt;, document *pDoc)</b><br />
     This increases the reference count of a document by 1. If you want to replace the current
    document in the Scintilla window and take ownership of the current document, for example if you
    are editing many documents in one window, do the following:<br />
     1. Use <code>SCI_GETDOCPOINTER</code> to get a pointer to the document,
    <code>pDoc</code>.<br />
     2. Use <code>SCI_ADDREFDOCUMENT(0, pDoc)</code> to increment the reference count.<br />
     3. Use <code>SCI_SETDOCPOINTER(0, pNewDoc)</code> to set a different document or
    <code>SCI_SETDOCPOINTER(0, 0)</code> to set a new, empty document.</p>
	<h3 id="SCI_RELEASEDOCUMENT">SCI_RELEASEDOCUMENT(&lt;unused&gt;, document *pDoc)</h3>
    <p><code>pDoc</code> で示された文書の参照数をひとつ減らします。pDoc は <code>SCI_GETDOCPOINTER</code> や <code>SCI_CREATEDOCUMENT</code> の戻り値でなくてはなりません。また、すでに実在する文書へのポインタでなくてはなりません。Scintilla ウィンドウに接続されたままの参照数 1 の文書に対して呼び出されると不整合が発生します。ちきうがへいわにまわっていられるように、<code>SCI_RELEASEDOCUMENT</code> と <code>SCI_CREATEDOCUMENT</code> + <code>SCI_ADDREFDOCUMENT</code> の回数を合わせることを忘れないでください。</p>
    <p class="eng"><b>SCI_RELEASEDOCUMENT(&lt;unused&gt;, document *pDoc)</b><br />
     This message reduces the reference count of the document identified by <code>pDoc</code>. pDoc
    must be the result of <code>SCI_GETDOCPOINTER</code> or <code>SCI_CREATEDOCUMENT</code> and
    must point at a document that still exists. If you call this on a document with a reference
    count of 1 that is still attached to a Scintilla window, bad things will happen. To keep the
    world spinning in its orbit you must balance each call to <code>SCI_CREATEDOCUMENT</code> or
    <code>SCI_ADDREFDOCUMENT</code> with a call to <code>SCI_RELEASEDOCUMENT</code>.</p>

    <h2 id="Folding"><span>折りたたみ</span><span class="eng">Folding</span></h2>

    <p>折りたたみの基本的な動作は、行の可視化と不可視化です。行を見ることができるかどうかは文書ではなく可視部の特性ですので、可視部の各々は異なる行を表示することができます。ユーザから見ると、折りたたみ点で行が隠されたり表示されたりしています。一般的に折りたたみ点は、文書の階層構造を元に設定されます。Python では階層が字下げによって定められますし、C++ では波括弧文字で定められます。文書オブジェクトの各行に“折りたたみ階層数”を接続することで、この階層構造が表現されます。折りたたみ階層数の大部分は解析器によって設定されますが、メッセージによって設定することも可能です。</p>
    <p class="eng">The fundamental operation in folding is making lines invisible or visible. Line visibility
    is a property of the view rather than the document so each view may be displaying a different
    set of lines. From the point of view of the user, lines are hidden and displayed using fold
    points. Generally, the fold points of a document are based on the hierarchical structure of the
    document contents. In Python, the hierarchy is determined by indentation and in C++ by brace
    characters. This hierarchy can be represented within a Scintilla document object by attaching a
    numeric "fold level" to each line. The fold level is most easily set by a lexer, but you can
    also set it with messages.</p>

    <p>ユーザの行動と折りたたみの実行・解除との対応付けは Scintilla を扱う側のコードが責任を持ちます。一番よい方法は、 SciTE のソースコードで本節のメッセージが使われているところを探してそこを見てください。マーカと折りたたみ余白も、実装の完成に必要となります。折りたたみを有効にするには <code>SCI_SETPROPERTY("fold", "1")</code> というコードで <code>"fold"</code> 特性を <code>"1"</code> にしなくてはなりません。</p>
    <p class="eng">It is up to your code to set the connection between user actions and folding and unfolding.
    The best way to see how this is done is to search the SciTE source code for the messages used
    in this section of the documentation and see how they are used. You will also need to use
    markers and a folding margin to complete your folding implementation.
    The <code>"fold"</code> property should be set to <code>"1"</code> with 
    <code>SCI_SETPROPERTY("fold", "1")</code> to enable folding. </p>
    <code><a class="message" href="#SCI_VISIBLEFROMDOCLINE">SCI_VISIBLEFROMDOCLINE(int
    docLine)</a><br />
     <a class="message" href="#SCI_DOCLINEFROMVISIBLE">SCI_DOCLINEFROMVISIBLE(int
    displayLine)</a><br />
     <a class="message" href="#SCI_SHOWLINES">SCI_SHOWLINES(int lineStart, int lineEnd)</a><br />
     <a class="message" href="#SCI_HIDELINES">SCI_HIDELINES(int lineStart, int lineEnd)</a><br />
     <a class="message" href="#SCI_GETLINEVISIBLE">SCI_GETLINEVISIBLE(int line)</a><br />
     <a class="message" href="#SCI_SETFOLDLEVEL">SCI_SETFOLDLEVEL(int line, int level)</a><br />
     <a class="message" href="#SCI_GETFOLDLEVEL">SCI_GETFOLDLEVEL(int line)</a><br />
     <a class="message" href="#SCI_SETFOLDFLAGS">SCI_SETFOLDFLAGS(int flags)</a><br />
     <a class="message" href="#SCI_GETLASTCHILD">SCI_GETLASTCHILD(int line, int level)</a><br />
     <a class="message" href="#SCI_GETFOLDPARENT">SCI_GETFOLDPARENT(int line)</a><br />
     <a class="message" href="#SCI_SETFOLDEXPANDED">SCI_SETFOLDEXPANDED(int line, bool
    expanded)</a><br />
     <a class="message" href="#SCI_GETFOLDEXPANDED">SCI_GETFOLDEXPANDED(int line)</a><br />
     <a class="message" href="#SCI_TOGGLEFOLD">SCI_TOGGLEFOLD(int line)</a><br />
     <a class="message" href="#SCI_ENSUREVISIBLE">SCI_ENSUREVISIBLE(int line)</a><br />
     <a class="message" href="#SCI_ENSUREVISIBLEENFORCEPOLICY">SCI_ENSUREVISIBLEENFORCEPOLICY(int
    line)</a><br />
    </code>
<h3 id="SCI_VISIBLEFROMDOCLINE">SCI_VISIBLEFROMDOCLINE(int docLine)</h3>
    <p>いくつかの行が折りたたまれているとき、以後の行は文書上の行位置とは違うところに表示されます。折りたたまれている行がないとき、このメッセージは <code>docLine</code> を返します。そうでない場合、このメッセージは隠されていない行数を返します。折りたたまれて不可視になっている行が指定された場合、それより文書開始方向にある最初の可視行の番号を返します。可視行のうち、文書内で先頭の行の番号が 0 となります。<code>docLine</code> がもとの文書の行数範囲の外を指示していた場合は -1 を返します。行クリップが有効な場合はひとつの行が表示上の複数行になっていることがあります。</p>
    <p class="eng"><b>SCI_VISIBLEFROMDOCLINE(int docLine)</b><br />
     When some lines are folded, then a particular line in the document may be displayed at a
    different position to its document position. If no lines are folded, this message returns
    <code>docLine</code>. Otherwise, this returns the display line (counting the very first visible
    line as 0). The display line of an invisible line is the same as the previous visible line. The
    display line number of the first line in the document is 0. If there is folding and
    <code>docLine</code> is outside the range of lines in the document, the return value is -1.
    Lines can occupy more than one display line if they wrap.</p>
<h3 id="SCI_DOCLINEFROMVISIBLE">SCI_DOCLINEFROMVISIBLE(int displayLine)</h3>
    <p>隠されている行がある場合、以後の行は文書上の行位置とは違うところに表示されます。このメッセージは表示されている行の番号から実際の文書上の行番号を求めて返します。<code>displayLine</code> が 0 以下の時は 0 を返します。可視行数以上の値が指定されたときは、文書の実際の行数を返します。</p>
    <p class="eng"><b>SCI_DOCLINEFROMVISIBLE(int displayLine)</b><br />
     When some lines are hidden, then a particular line in the document may be displayed at a
    different position to its document position. This message returns the document line number that
    corresponds to a display line (counting the display line of the first line in the document as
    0). If <code>displayLine</code> is less than or equal to 0, the result is 0. If
    <code>displayLine</code> is greater than or equal to the number of displayed lines, the result
    is the number of lines in the document.</p>
<h3 id="SCI_SHOWLINES">SCI_SHOWLINES(int lineStart, int lineEnd)<br /><span id="SCI_HIDELINES">SCI_HIDELINES(int lineStart, int lineEnd)</span><br /><span id="SCI_GETLINEVISIBLE">SCI_GETLINEVISIBLE(int line)</span></h3>
    <p>最初の二つは指定範囲の行を可視化もしくは不可視化するものです。画面の再描画も行います。三つ目のメッセージは指定行の表示状態を返すもので、可視であれば 1 、不可視であれば 0 を返します。これらのメッセージは折りたたみ階層数や折りたたみフラグに影響を与えません。</p>
    <p class="eng"><b>SCI_SHOWLINES(int lineStart, int lineEnd)</b><br />
     <b>SCI_HIDELINES(int lineStart, int lineEnd)</b><br />
     <b>SCI_GETLINEVISIBLE(int line)</b><br />
     The first two messages mark a range of lines as visible or invisible and then redraw the
    display. The third message reports on the visible state of a line and returns 1 if it is
    visible and 0 if it is not visible. These messages have no effect on fold levels or fold
    flags.</p>
<h3 id="SCI_SETFOLDLEVEL">SCI_SETFOLDLEVEL(int line, int level)<br />
     <span id="SCI_GETFOLDLEVEL">SCI_GETFOLDLEVEL(int line)</span></h3>
    <p>指定行の折りたたみ階層数や関連フラグを含む 32 ビット値を設定または取得します。折りたたみ階層数は 0 〜 <code>SC_FOLDLEVELNUMBERMASK</code> (4095) の値を取りますが、初期状態では <code>SC_FOLDLEVELBASE</code> (1024) が上限となっています。追加のフラグが 2 ビットあります。<code>SC_FOLDLEVELWHITEFLAG</code> は空行であって少し異なる扱いにすることを示します。この結果、空行には文字がないにもかかわらず階層数が示されていることになります。たとえば、空行は通常折りたたみ点にすべきではありません。<code>SC_FOLDLEVELHEADERFLAG</code> は折りたたみ点を示すヘッダとなります。</p>
    <p class="eng"><b>SCI_SETFOLDLEVEL(int line, int level)</b><br />
     <b>SCI_GETFOLDLEVEL(int line)</b><br />
     These two messages set and get a 32-bit value that contains the fold level of a line and some
    flags associated with folding. The fold level is a number in the range 0 to
    <code>SC_FOLDLEVELNUMBERMASK</code> (4095). However, the initial fold level is set to
    <code>SC_FOLDLEVELBASE</code> (1024) to allow unsigned arithmetic on folding levels. There are
    two addition flag bits. <code>SC_FOLDLEVELWHITEFLAG</code> indicates that the line is blank and
    allows it to be treated slightly different then its level may indicate. For example, blank
    lines should generally not be fold points. <code>SC_FOLDLEVELHEADERFLAG</code> indicates that
    the line is a header (fold point).</p>

    <p><code>SCI_GETFOLDLEVEL(line) &amp; SC_FOLDLEVELNUMBERMASK</code> というコードで指定行の折りたたみ階層数を取得できます。同様に <code>SCI_GETFOLDLEVEL(line) &amp; SC_FOLDLEVEL*FLAG</code> でフラグを取得できます。折りたたみ階層を設定するときは関連フラグも一度に設定しなくてはなりません。階層数 <code>thisLevel</code> と折りたたみ点であることを示すフラグを設定するときは <code>SCI_SETFOLDLEVEL(line, thisLevel | SC_FOLDLEVELHEADERFLAG)</code> といったコードになります。</p>
    <p class="eng">Use <code>SCI_GETFOLDLEVEL(line) &amp; SC_FOLDLEVELNUMBERMASK</code> to get the fold level
    of a line. Likewise, use <code>SCI_GETFOLDLEVEL(line) &amp; SC_FOLDLEVEL*FLAG</code> to get the
    state of the flags. To set the fold level you must or in the associated flags. For instance, to
    set the level to <code>thisLevel</code> and mark a line as being a fold point use:
    <code>SCI_SETFOLDLEVEL(line, thisLevel | SC_FOLDLEVELHEADERFLAG)</code>.</p>
	<p>解析器を使っているときは <code>SCI_SETFOLDLEVEL</code> を使う必要がないようにすべきです。解析器に任せたほうがずっといい処理をすると思われるからです。ユーザの折りたたみ要求を決めるために <code>SCI_GETFOLDLEVEL</code> を使う必要があります。折りたたみ階層数を変更したら、折りたたみ余白もその変更に合わせて更新されます。</p>
    <p class="eng">If you use a lexer, you should not need to use <code>SCI_SETFOLDLEVEL</code> as this is far
    better handled by the lexer. You will need to use <code>SCI_GETFOLDLEVEL</code> to decide how
    to handle user folding requests. If you do change the fold levels, the folding margin will
    update to match your changes.</p>
<h3 id="SCI_SETFOLDFLAGS">SCI_SETFOLDFLAGS(int flags)</h3>
    <p>折りたたみ余白のマーカ表示に加えて、テキスト区画に線を引くことで折りたたみを表現することができます。この線は <a
    class="message" href="#StyleDefinition"><code>STYLE_DEFAULT</code></a> における文字色で引かれます。<code>flags</code> に設定されたビットでどこに折りたたみ表現線を引くかを指定します。</p>
    <p class="eng"><b>SCI_SETFOLDFLAGS(int flags)</b><br />
     In addition to showing markers in the folding margin, you can indicate folds to the user by
    drawing lines in the text area. The lines are drawn in the foreground colour set for <a
    class="message" href="#StyleDefinition"><code>STYLE_DEFAULT</code></a>. Bits set in
    <code>flags</code> determine where folding lines are drawn:<br />
    </p>
    <table cellpadding="1" cellspacing="2" border="0" summary="折りたたみフラグ">
      <tbody>
        <tr>
          <th align="center">値</th>

          <th align="left">効果</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="center">1</td>

          <td align="left">展開しているときに矩形で囲む。(動作試験中)</td>
        </tr>

        <tr>
          <td align="center">2</td>

          <td align="left">展開しているときに上に引く。</td>
        </tr>

        <tr>
          <td align="center">4</td>

          <td align="left">折りたたまれているときに上に引く。</td>
        </tr>

        <tr>
          <td align="center">8</td>

          <td align="left">展開しているときに下に引く。</td>
        </tr>

        <tr>
          <td align="center">16</td>

          <td align="left">折りたたまれているときに下に引く。</td>
        </tr>

        <tr>
          <td align="center">64</td>

          <td align="left">16 進数で行の余白に折りたたみ階層数を表示する。折りたたみのデバッグ用。この機能は理解しやすいように再設計する必要がある。</td>
        </tr>
      </tbody>
    </table>
    <p>このメッセージは画面の再描画を促します。</p>

    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Fold flags">
      <tbody>
        <tr>
          <th align="center">Value</th>

          <th align="left">Effect</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="center">1</td>

          <td align="left">Experimental - draw boxes if expanded</td>
        </tr>

        <tr>
          <td align="center">2</td>

          <td align="left">Draw above if expanded</td>
        </tr>

        <tr>
          <td align="center">4</td>

          <td align="left">Draw above if not expanded</td>
        </tr>

        <tr>
          <td align="center">8</td>

          <td align="left">Draw below if expanded</td>
        </tr>

        <tr>
          <td align="center">16</td>

          <td align="left">Draw below if not expanded</td>
        </tr>

        <tr>
          <td align="center">64</td>

          <td align="left">display hexadecimal fold levels in line margin to aid debugging of
          folding. This feature needs to be redesigned to be sensible.</td>
        </tr>
      </tbody>
    </table>

    <p class="eng">This message causes the display to redraw.</p>
<h3 id="SCI_GETLASTCHILD">SCI_GETLASTCHILD(int startLine, int level)</h3>
    <p><code>startLine</code> の行以降に折りたたみ階層数が <code>level</code> 以下の行を探します。見つけた場合はその一行前の行番号を返します。<code>level</code> に -1 を指定したときは、<code>startLine</code> と同じ折りたたみ階層数とみなします。<code>SCI_GETLASTCHILD(from,
    -1)</code> というコードで <code>from</code> が折りたたみ点であるときに返される行番号は、可視行もしくは折りたたみによって不可視にされている行のうちの最後の行になります。</p>
    <p class="eng"><b>SCI_GETLASTCHILD(int startLine, int level)</b><br />
     This message searches for the next line after <code>startLine</code>, that has a folding level
    that is less than or equal to <code>level</code> and then returns the previous line number. If
    you set <code>level</code> to -1, <code>level</code> is set to the folding level of line
    <code>startLine</code>. If <code>from</code> is a fold point, <code>SCI_GETLASTCHILD(from,
    -1)</code> returns the last line that would be in made visible or hidden by toggling the fold
    state.</p>
<h3 id="SCI_GETFOLDPARENT">SCI_GETFOLDPARENT(int startLine)</h3>
    <p><code>startLine</code> より文書先頭方向にあり、<code>startLine</code> より折りたたみ階層数が小さく、<code>SC_FOLDLEVELHEADERFLAG</code> で折りたたみ点として印づけられている行のうち最初の行の番号を返します。該当行がない場合や、ヘッダフラグと折りたたみ階層数に齟齬がある場合は -1 を返します。</p>
    <p class="eng"><b>SCI_GETFOLDPARENT(int startLine)</b><br />
     This message returns the line number of the first line before <code>startLine</code> that is
    marked as a fold point with <code>SC_FOLDLEVELHEADERFLAG</code> and has a fold level less than
    the <code>startLine</code>. If no line is found, or if the header flags and fold levels are
    inconsistent, the return value is -1.</p>
<h3 id="SCI_TOGGLEFOLD">SCI_TOGGLEFOLD(int line)</h3>
    <p>各折りたたみ点は展開時にすべての子孫階層を表示したり、閉じたときにすべての子孫階層を隠したりできます。このメッセージは指定行が <code>SC_FOLDLEVELHEADERFLAG</code> を設定されていればその折りたたみ状態を切り替えます。折りたたみもしくは展開の状態が指定行に依存する行の状態も制御します。このメッセージの後表示は更新されます。</p>
    <p class="eng"><b>SCI_TOGGLEFOLD(int line)</b><br />
     Each fold point may be either expanded, displaying all its child lines, or contracted, hiding
    all the child lines. This message toggles the folding state of the given line as long as it has
    the <code>SC_FOLDLEVELHEADERFLAG</code> set. This message takes care of folding or expanding
    all the lines that depend on the line. The display updates after this message.</p>
<h3 id="SCI_SETFOLDEXPANDED">SCI_SETFOLDEXPANDED(int line, bool expanded)</h3>
    <p>指定行一行の展開状態を設定または取得します。このメッセージは行の可視状態や指定行に依存する行には影響を与えません。折りたたみ余白のマーカは変更されます。文書の外を指すような行番号を指定すると <code>false</code> (0) が返されます。</p>
    <p class="eng"><b>SCI_SETFOLDEXPANDED(int line, bool expanded)</b><br />
     <b>SCI_GETFOLDEXPANDED(int line)</b><br />
     These messages set and get the expanded state of a single line. The set message has no effect
    on the visible state of the line or any lines that depend on it. It does change the markers in
    the folding margin. If you ask for the expansion state of a line that is outside the document,
    the result is <code>false</code> (0).</p>

    <p>単にある行の折りたたみ状態を変更し、それに依存する行もまとめて変更したい場合は <code>SCI_TOGGLEFOLD</code> を使うほうが簡単です。<code>SCI_SETFOLDEXPANDED</code> はまとめて折りたたみを処理し終わるまで表示更新を待たせる場合に使うことがあります。使い方については <code>SciTEBase::FoldAll()</code> と <code>SciTEBase::Expand()</code> を参照してください。</p>
    <p class="eng">If you just want to toggle the fold state of one line and handle all the lines that are
    dependent on it, it is much easier to use <code>SCI_TOGGLEFOLD</code>. You would use the
    <code>SCI_SETFOLDEXPANDED</code> message to process many folds without updating the display
    until you had finished. See <code>SciTEBase::FoldAll()</code> and
    <code>SciTEBase::Expand()</code> for examples of the use of these messages.</p>
<h3 id="SCI_ENSUREVISIBLE">SCI_ENSUREVISIBLE(int line)<br />
     <span id="SCI_ENSUREVISIBLEENFORCEPOLICY">SCI_ENSUREVISIBLEENFORCEPOLICY(int line)</span></h3>
    <p>ある行がその祖先階層の行を折りたたまれる事により隠されてしまうことがあります。これらのメッセージは折りたたみ階層構造を上位にたどり、閉じられている折りたたみを最上位階層まで開いていきます。結果、指定行は可視になります。<code>SCI_ENSUREVISIBLEENFORCEPOLICY</code> を使うと、<a class="message"
    href="#SCI_SETVISIBLEPOLICY"><code>SCI_SETVISIBLEPOLICY</code></a> で使う垂直方向のキャレットポリシーが適用されます。</p>
    <p class="eng"><b>SCI_ENSUREVISIBLE(int line)</b><br />
     <b>SCI_ENSUREVISIBLEENFORCEPOLICY(int line)</b><br />
     A line may be hidden because more than one of its parent lines is contracted. Both these
    message travels up the fold hierarchy, expanding any contracted folds until they reach the top
    level. The line will then be visible. If you use <code>SCI_ENSUREVISIBLEENFORCEPOLICY</code>,
    the vertical caret policy set by <a class="message"
    href="#SCI_SETVISIBLEPOLICY"><code>SCI_SETVISIBLEPOLICY</code></a> is then applied.</p>

    <h2 id="LineWrapping"><span>行クリップ</span><span class="eng">Line wrapping</span></h2>

    <code><a class="message" href="#SCI_SETWRAPMODE">SCI_SETWRAPMODE(int wrapMode)</a><br />
     <a class="message" href="#SCI_GETWRAPMODE">SCI_GETWRAPMODE</a><br />
     <a class="message" href="#SCI_SETWRAPVISUALFLAGS">SCI_SETWRAPVISUALFLAGS(int wrapVisualFlags)</a><br />
     <a class="message" href="#SCI_GETWRAPVISUALFLAGS">SCI_GETWRAPVISUALFLAGS</a><br />
     <a class="message" href="#SCI_SETWRAPSTARTINDENT">SCI_SETWRAPSTARTINDENT(int indent)</a><br />
     <a class="message" href="#SCI_GETWRAPSTARTINDENT">SCI_GETWRAPSTARTINDENT</a><br />
     <a class="message" href="#SCI_SETLAYOUTCACHE">SCI_SETLAYOUTCACHE(int cacheMode)</a><br />
     <a class="message" href="#SCI_GETLAYOUTCACHE">SCI_GETLAYOUTCACHE</a><br />
     <a class="message" href="#SCI_LINESSPLIT">SCI_LINESSPLIT</a><br />
     <a class="message" href="#SCI_LINESJOIN">SCI_LINESJOIN</a><br />
    </code>

    <p>初期状態では Scintilla は行クリップを行いません。行クリップを有効にするとウィンドウ幅より長い行は次の行以降に折り返して表示されるようになります。空白文字、タブ文字、あるいは装飾の異なる位置を機会にそのような行を折り返そうとします。単一装飾の単語がウィンドウ幅より長いために折り返すことができない場合は、ウィンドウ幅で強制的に折り返します。行クリップが有効の時は水平スクロールバーは表示されません。</p>
    <p class="eng">By default, Scintilla does not wrap lines of text. If you enable line wrapping, lines wider
    than the window width are continued on the following lines. Lines are broken after space or tab
    characters or between runs of different styles. If this is not possible because a word in one
    style is wider than the window then the break occurs after the last character that completely
    fits on the line. The horizontal scroll bar does not appear when wrap mode is on.</p>

	<p>Scintilla は折り返された行について、その折り返しで継続される位置に小さな矢印を表示することができます。これらは個々に有効にできますが、二行目以降の行頭に矢印を描画する場合は一字字下げを行います。また、この矢印とは別に折り返しの二行目以降を字下げさせることができます。</p>
    <p class="eng">For wrapped lines Scintilla can draw visual flags (little arrows) at end of a a subline of a
	wrapped line and at begin of the next subline. These can be enabled individually, but if Scintilla
	draws the visual flag at begin of the next subline this subline will be indented by one char.
	Independent from drawing a visual flag at the begin the subline can have an indention.</p>

    <p>Scintilla はテキストの配置と描画に多くの時間を割きます。計算結果が変化しないものであっても同じテキストの配置計算が何度も行われます。この不必要な再計算を避けるために、行配置キャッシュに計算結果を格納することができます。キャッシュはその行の文字や装飾が変更されたときに無効化されます。文書全体をキャッシュすれば最大の効果が得られ、動的行クリップが 20 倍の速さで処理される一方、文書内容そのものに 7 倍のメモリと一行あたり 80 バイトのメモリが消費されます。</p>
    <p class="eng">Much of the time used by Scintilla is spent on laying out and drawing text. The same text
    layout calculations may be performed many times even when the data used in these calculations
    does not change. To avoid these unnecessary calculations in some circumstances, the line layout
    cache can store the results of the calculations. The cache is invalidated whenever the
    underlying data, such as the contents or styling of the document changes. Caching the layout of
    the whole document has the most effect, making dynamic line wrap as much as 20 times faster but
    this requires 7 times the memory required by the document contents plus around 80 bytes per
    line.</p>

    <p>行クリップは文書の変更直後ではなく再描画の時点で実行されます。この遅れにより全体の処理速度が上がります。まとまった変更ができるようになり、それに対する行クリップと再表示も一度だけでよくなります。このため、いくつかの処理が思ったように動作しないことがあります。ファイルを読み出してスクロール位置を移動すると、スクロール位置は行クリップの前に決められてしまうため表示されるテキスト範囲がスクロールバーと違うところになります。これはセッションの復帰の際などに起こります。正しいスクロール位置にするには、行クリップが実行されるまでスクロールさせないことです。これは最初の <a class="message" href="#SCN_PAINTED">SCN_PAINTED</a> 通知を待つことで実現できます。</p>
    <p class="eng">Wrapping is not performed immediately there is a change but is delayed until the display
    is redrawn. This delay improves peformance by allowing a set of changes to be performed
    and then wrapped and displayed once. Because of this, some operations may not occur as
    expected. If a file is read and the scroll position moved to a particular line in the text,
    such as occurs when a container tries to restore a previous editing session, then
    the scroll position will have been determined before wrapping so an unexpected range
    of text will be displayed. To scroll to the position correctly, delay the scroll until the
    wrapping has been performed by waiting for an initial
    <a class="message" href="#SCN_PAINTED">SCN_PAINTED</a> notification.</p>
<h3 id="SCI_SETWRAPMODE">SCI_SETWRAPMODE(int wrapMode)<br />
     <span id="SCI_GETWRAPMODE">SCI_GETWRAPMODE</span></h3>
    <p><code>wrapMode</code> に <code>SC_WRAP_WORD</code> (1) を指定すると行クリップが有効となり、<code>SC_WRAP_NONE</code> (0) を指定すると無効になります。</p>
    <p>SC_WRAP_CHAR (2) は SC_WRAP_WORD と異なり行クリップのために空白文字列を検索せず、必要な場所で文字を問わずに折り返すようになります。日本語のように空白文字類を原則的に利用しない自然言語を使うときのために訳者が実装したものです。</p>
    <p class="eng"><b>SCI_SETWRAPMODE(int wrapMode)</b><br />
     <b>SCI_GETWRAPMODE</b><br />
     Set wrapMode to <code>SC_WRAP_WORD</code> (1) to enable line wrapping and to
    <code>SC_WRAP_NONE</code> (0) to disable line wrapping.</p>
<h3 id="SCI_SETWRAPVISUALFLAGS">SCI_SETWRAPVISUALFLAGS(int wrapVisualFlags)<br />
     <span id="SCI_GETWRAPVISUALFLAGS">SCI_GETWRAPVISUALFLAGS</span></h3>
    <p>行クリップが行われていることを示す印を描画することができます。<code>wrapVisualFlags</code> に設定されたビットでどの印が秒がされるかが決まります。</p>
    <p class="eng"><b>SCI_SETWRAPVISUALFLAGS(int wrapVisualFlags)</b><br />
     <b>SCI_GETWRAPVISUALFLAGS</b><br />
		You can enable the drawing of visual flags to indicate a line is wrapped. Bits set in
		wrapVisualFlags determine which visual flags are drawn.</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="行クリップの印">
      <tbody>
        <tr>
          <th align="left">定数</th>
          <th>値</th>
          <th align="left">効果</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAG_NONE</code></td>
          <td align="center">0</td>
          <td>何も表示しません。</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAG_END</code></td>
          <td align="center">1</td>
          <td>二行目以降の行末に表示します。</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAG_START</code></td>
          <td align="center">2</td>
          <td>二行目以降の先頭に表示します。<br />表示される行はその印のために少なくとも 1 文字分字下げします。</td>
        </tr>
      </tbody>
    </table>


    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Wrap visual flags">
      <tbody>
        <tr>
          <th align="left">Symbol</th>
          <th>Value</th>
          <th align="left">Effect</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAG_NONE</code></td>
          <td align="center">0</td>
          <td>No visual flags</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAG_END</code></td>
          <td align="center">1</td>
          <td>Visual flag at end of subline of a wrapped line.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAG_START</code></td>
          <td align="center">2</td>
          <td>Visual flag at begin of subline of a wrapped line.<br />
					     Subline is indented by at least 1 to make room for the flag.<br />
				</td>
        </tr>
      </tbody>
    </table>


<h3 id="SCI_SETWRAPVISUALFLAGSLOCATION">SCI_SETWRAPVISUALFLAGSLOCATION(int wrapVisualFlagsLocation)<br />
     <span id="SCI_GETWRAPVISUALFLAGSLOCATION">SCI_GETWRAPVISUALFLAGSLOCATION</span></h3>
	 <p>行クリップが行われていることを示すフラグを枠の近くに表示するかテキストの近くに表示するかを設定することができます。<code>wrapVisualFlagsLocation</code> にはテキストに対応するフラグの位置を設定します。</p>
    <p class="eng"><b>SCI_SETWRAPVISUALFLAGSLOCATION(int wrapVisualFlagsLocation)</b><br />
     <b>SCI_GETWRAPVISUALFLAGSLOCATION</b><br />
		You can set wether the visual flags to indicate a line is wrapped are drawn near the border or near the text.
		Bits set in wrapVisualFlagsLocation set the location to near the text for the corresponding visual flag.</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="行クリップフラグの表示位置">
      <tbody>
        <tr>
          <th align="left">定数</th>
          <th>値</th>
          <th align="left">効果</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAGLOC_DEFAULT</code></td>
          <td align="center">0</td>
          <td>枠の近くに表示します。</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAGLOC_END_BY_TEXT</code></td>
          <td align="center">1</td>
          <td>二行目以降の行末、テキスト寄りに表示します。</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAGLOC_START_BY_TEXT</code></td>
          <td align="center">2</td>
          <td>二行目以降の行頭、テキスト寄りに表示します。</td>
        </tr>
      </tbody>
    </table>


    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Wrap visual flags locations">
      <tbody>
        <tr>
          <th align="left">Symbol</th>
          <th>Value</th>
          <th align="left">Effect</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAGLOC_DEFAULT</code></td>
          <td align="center">0</td>
          <td>Visual flags drawn near border</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAGLOC_END_BY_TEXT</code></td>
          <td align="center">1</td>
          <td>Visual flag at end of subline drawn near text</td>
        </tr>

        <tr>
          <td align="left"><code>SC_WRAPVISUALFLAGLOC_START_BY_TEXT</code></td>
          <td align="center">2</td>
          <td>Visual flag at begin of subline drawn near text</td>
        </tr>
      </tbody>
    </table>

    <br />
<h3 id="SCI_SETWRAPSTARTINDENT">SCI_SETWRAPSTARTINDENT(int indent)<br />
     <span id="SCI_GETWRAPSTARTINDENT">SCI_GETWRAPSTARTINDENT</span></h3>
    <p> 行クリップ発生時の二行目以降の字下げ量を <code>SCI_SETWRAPSTARTINDENT</code> で設定します。<a class="message" href="#StyleDefinition"><code>STYLE_DEFAULT</code></a> の空白文字の幅が単位です。字下げ量に制限はありませんが、0 以下や大きすぎる値は想定外の効果を起こすことがあります。二行目以降の字下げは字下げを示す印とは独立した設定ですが、<code>SC_WRAPVISUALFLAG_START</code> が設定されているときは、少なくとも一字分字下げが行われます。</p>
    <p class="eng"><b>SCI_SETWRAPSTARTINDENT(int indent)</b><br />
     <b>SCI_GETWRAPSTARTINDENT</b><br />
     <code>SCI_SETWRAPSTARTINDENT</code> sets the size of indentation of sublines for
		 wrapped lines in terms of the width of a space in
		<a class="message" href="#StyleDefinition"><code>STYLE_DEFAULT</code></a>.
		There are no limits on indent sizes, but values	less than 0 or large values may have
		undesirable effects.<br />
		The indention of sublines is independent of visual flags, but if
		<code>SC_WRAPVISUALFLAG_START</code> is set an indent of at least 1 is used.
     </p>
<h3 id="SCI_SETLAYOUTCACHE">SCI_SETLAYOUTCACHE(int cacheMode)<br />
     <span id="SCI_GETLAYOUTCACHE">SCI_GETLAYOUTCACHE</span></h3>
    <p><code>cacheMode</code> に次表の定数のうち一つを設定できます。</p>
    <p class="eng"><b>SCI_SETLAYOUTCACHE(int cacheMode)</b><br />
     <b>SCI_GETLAYOUTCACHE</b><br />
     You can set <code>cacheMode</code> to one of the symbols in the table:</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="行キャッシュの手法">
      <tbody>
        <tr>
          <th align="left">定数</th>

          <th>値</th>

          <th align="left">行配置キャッシュの種類</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_CACHE_NONE</code></td>

          <td align="center">0</td>

          <td>キャッシュは取りません。</td>
        </tr>

        <tr>
          <td align="left"><code>SC_CACHE_CARET</code></td>

          <td align="center">1</td>

          <td>キャレットのある行がキャッシュされます。初期設定です。</td>
        </tr>

        <tr>
          <td align="left"><code>SC_CACHE_PAGE</code></td>

          <td align="center">2</td>

          <td>現在見えている行とキャレットのある行がキャッシュされます。</td>
        </tr>

        <tr>
          <td align="left"><code>SC_CACHE_DOCUMENT</code></td>

          <td align="center">3</td>

          <td>文書内のすべての行がキャッシュされます。</td>
        </tr>
      </tbody>
    </table>

    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Line caching styles">
      <tbody>
        <tr>
          <th align="left">Symbol</th>

          <th>Value</th>

          <th align="left">Layout cached for these lines</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_CACHE_NONE</code></td>

          <td align="center">0</td>

          <td>No lines are cached.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_CACHE_CARET</code></td>

          <td align="center">1</td>

          <td>The line containing the text caret. This is the default.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_CACHE_PAGE</code></td>

          <td align="center">2</td>

          <td>Visible lines plus the line containing the caret.</td>
        </tr>

        <tr>
          <td align="left"><code>SC_CACHE_DOCUMENT</code></td>

          <td align="center">3</td>

          <td>All lines in the document.</td>
        </tr>
      </tbody>
    </table>
    <br />
<h3 id="SCI_LINESSPLIT">SCI_LINESSPLIT(int pixelWidth)</h3>
    <p>対象として示された範囲内の行を、最大幅が <code>pixelWidth</code> の行へ分割します。可能な限り行クリップと同じ手法で単語の境界における分割が発生します。<code>pixelWidth</code> が 0 の場合はウィンドウ幅が用いられます。</p>
    <p class="eng"><b>SCI_LINESSPLIT(int pixelWidth)</b><br />
     Split a range of lines indicated by the target into lines that are at most pixelWidth wide.
     Splitting occurs on word boundaries wherever possible in a similar manner to line wrapping.
     When <code>pixelWidth</code> is 0 then the width of the window is used.
     </p>
<h3 id="SCI_LINESJOIN">SCI_LINESJOIN</h3>
    <p>対象として示された範囲内の行を、行末文字を除くことにより一行にまとめます。単語間に空白が無くなってしまう場合は空白文字が追加挿入されます。</p>
    <p class="eng"><b>SCI_LINESJOIN</b><br />
     Join a range of lines indicated by the target into one line by
     removing line end characters.
     Where this would lead to no space between words, an extra space is inserted.
     </p>

    <h2 id="Zooming"><span>拡大縮小</span><span class="eng">Zooming</span></h2>

    <p>Scintilla には“拡大係数”が組み込まれており、文書内の文字列を 1 ポイント単位で大きくしたり小さくしたりできます。係数の値にかかわらず、2 ポイント未満にはなりません。拡大係数は -10 〜 +20 ポイントの範囲で指定できます。</p>
    <p class="eng">Scintilla incorporates a "zoom factor" that lets you make all the text in the document
    larger or smaller in steps of one point. The displayed point size never goes below 2, whatever
    zoom factor you set. You can set zoom factors in the range -10 to +20 points.</p>
    <code><a class="message" href="#SCI_ZOOMIN">SCI_ZOOMIN</a><br />
     <a class="message" href="#SCI_ZOOMOUT">SCI_ZOOMOUT</a><br />
     <a class="message" href="#SCI_SETZOOM">SCI_SETZOOM(int zoomInPoints)</a><br />
     <a class="message" href="#SCI_GETZOOM">SCI_GETZOOM</a><br />
    </code>
<h3 id="SCI_ZOOMIN">SCI_ZOOMIN<br />
     <span id="SCI_ZOOMOUT">SCI_ZOOMOUT</span></h3>
    <p><code>SCI_ZOOMIN</code> は拡大係数を 1 ポイント加え、<code>SCI_ZOOMOUT</code> は 1 ポイント減らします。20 ポイントを越えたり -10 ポイントを下回ったりすることはありません。</p>
    <p class="eng"><b>SCI_ZOOMIN</b><br />
     <b>SCI_ZOOMOUT</b><br />
     <code>SCI_ZOOMIN</code> increases the zoom factor by one point if the current zoom factor is
    less than 20 points. <code>SCI_ZOOMOUT</code> decreases the zoom factor by one point if the
    current zoom factor is greater than -10 points.</p>
<h3 id="SCI_SETZOOM">SCI_SETZOOM(int zoomInPoints)<br />
     <span id="SCI_GETZOOM">SCI_GETZOOM</span></h3>
    <p><code>SCI_SETZOOM</code> は直接拡大係数を指定します。指定値に制限がありませんので、自分で -10 〜 +20 に制限する加算拡大関数を作るのはよい方法です。</p>
    <p class="eng"><b>SCI_SETZOOM(int zoomInPoints)</b><br />
     <b>SCI_GETZOOM</b><br />
     These messages let you set and get the zoom factor directly. There is no limit set on the
    factors you can set, so limiting yourself to -10 to +20 to match the incremental zoom functions
    is a good idea.</p>

    <h2 id="LongLines"><span>超過桁境界線</span><span class="eng">Long lines</span></h2>

    <p>指定桁数を超えた行を示すために垂直線を引いたり、越えた部分の背景色を変えたりすることができます。</p>
    <p class="eng">You can choose to mark lines that exceed a given length by drawing a vertical line or by
    colouring the background of characters that exceed the set length.</p>
    <code><a class="message" href="#SCI_SETEDGEMODE">SCI_SETEDGEMODE(int mode)</a><br />
     <a class="message" href="#SCI_GETEDGEMODE">SCI_GETEDGEMODE</a><br />
     <a class="message" href="#SCI_SETEDGECOLUMN">SCI_SETEDGECOLUMN(int column)</a><br />
     <a class="message" href="#SCI_GETEDGECOLUMN">SCI_GETEDGECOLUMN</a><br />
     <a class="message" href="#SCI_SETEDGECOLOUR">SCI_SETEDGECOLOUR(int colour)</a><br />
     <a class="message" href="#SCI_GETEDGECOLOUR">SCI_GETEDGECOLOUR</a><br />
    </code>
<h3 id="SCI_SETEDGEMODE">SCI_SETEDGEMODE(int edgeMode)<br />
     <span id="SCI_GETEDGEMODE">SCI_GETEDGEMODE</span></h3>
    <p>超過桁境界線の表示方法を設定または取得します。次表に挙げた値のうち一つを設定できます。</p>
    <p class="eng"><b>SCI_SETEDGEMODE(int edgeMode)</b><br />
     <b>SCI_GETEDGEMODE</b><br />
     These two messages set and get the mode used to display long lines. You can set one of the
    values in the table:</p>

<table cellpadding="1" cellspacing="2" border="0" summary="超過桁境界線">
      <tbody>
        <tr>
          <th align="left">定数</th>

          <th>値</th>

          <th align="left">境界線の表現</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>EDGE_NONE</code></td>

          <td align="center">0</td>

          <td>境界線は表示されません。初期状態値です。</td>
        </tr>

        <tr>
          <td align="left"><code>EDGE_LINE</code></td>

          <td align="center">1</td>

          <td><code>SCI_SETEDGECOLUMN</code> で設定された桁に垂直線が引かれます。固定幅フォントを使っているときに正しく動作します。<a class="message"
          href="#StyleDefinition"><code>STYLE_DEFAULT</code></a> における空白文字の幅を基準にして線の位置を計算しますので、プロポーショナルフォントを使ったり装飾毎に異なる大きさのフォントを使ったり、あるいは太字・斜体・通常フォントを混ぜて使ったりするとあまりいい位置には来ません。</td>
        </tr>

        <tr>
          <td align="left"><code>EDGE_BACKGROUND</code></td>

          <td align="center">2</td>

          <td>桁境界以降の文字の背景色を <code>SCI_SETEDGECOLOUR</code> で指定した色に変更します。プロポーショナルフォントにはこちらをおすすめします。</td>
        </tr>
      </tbody>
    </table>

    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Long line styles">
      <tbody>
        <tr>
          <th align="left">Symbol</th>

          <th>Value</th>

          <th align="left">Long line display mode</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>EDGE_NONE</code></td>

          <td align="center">0</td>

          <td>Long lines are not marked. This is the default state.</td>
        </tr>

        <tr>
          <td align="left"><code>EDGE_LINE</code></td>

          <td align="center">1</td>

          <td>A vertical line is drawn at the column number set by <code>SCI_SETEDGECOLUMN</code>.
          This works well for monospaced fonts. The line is drawn at a position based on the width
          of a space character in <a class="message"
          href="#StyleDefinition"><code>STYLE_DEFAULT</code></a>, so it may not work very well if
          your styles use proportional fonts or if your style have varied font sizes or you use a
          mixture of bold, italic and normal text. .</td>
        </tr>

        <tr>
          <td align="left"><code>EDGE_BACKGROUND</code></td>

          <td align="center">2</td>

          <td>The background colour of characters after the column limit is changed to the colour
          set by <code>SCI_SETEDGECOLOUR</code>. This is recommended for proportional fonts.</td>
        </tr>
      </tbody>
    </table>
<h3 id="SCI_SETEDGECOLUMN">SCI_SETEDGECOLUMN(int column)<br />
     <span id="SCI_GETEDGECOLUMN">SCI_GETEDGECOLUMN</span></h3>
	<p>超過桁境界線を表示する桁位置を設定または取得します。線を引く場合は  <code>STYLE_DEFAULT</code> における空白文字の幅を単位として位置を計算します。背景色が変更されるときは、タブも考慮した文字数単位で数えます。</p>
    <p class="eng"><b>SCI_SETEDGECOLUMN(int column)</b><br />
     <b>SCI_GETEDGECOLUMN</b><br />
     These messages set and get the column number at which to display the long line marker. When
    drawing lines, the column sets a position in units of the width of a space character in
    <code>STYLE_DEFAULT</code>. When setting the background colour, the column is a character count
    (allowing for tabs) into the line.</p>
<h3 id="SCI_SETEDGECOLOUR">SCI_SETEDGECOLOUR(int <a class="jump"
    href="#colour">colour</a>)<br />
     <span id="SCI_GETEDGECOLOUR">SCI_GETEDGECOLOUR</span></h3>
    <p><code>SCI_SETEDGECOLUMN</code> の桁数を越えた行における印の背景色を設定または取得します。</p>
    <p class="eng"><b>SCI_SETEDGECOLOUR(int <a class="jump"
    href="#colour">colour</a>)</b><br />
     <b>SCI_GETEDGECOLOUR</b><br />
     These messages set and get the colour of the marker used to show that a line has exceeded the
    length set by <code>SCI_SETEDGECOLUMN</code>.</p>

    <h2 id="Lexer"><span>解析器</span><span class="eng">Lexer</span></h2>

    <p>Scintilla の構築の際に <code>SCI_LEXER</code> シンボルを定義しておくと、広範囲のプログラミング言語解析および本節のメッセージに対応できるようになります。これは時に SciLexer 版の Scintilla と呼ばれます。未対応の言語に装飾や折りたたみ点を設定したい場合でもコンテナの中でそれができますし、今でもよりよい方法として、既存の解析器のパターンを応用して自身の解析器を作ることができます。</p>
    <p class="eng">If you define the symbol <code>SCI_LEXER</code> when building Scintilla, (this is sometimes
    called the SciLexer version of Scintilla), lexing support for a wide range programming
    languages is included and the messages in this section are supported. If you want to set
    styling and fold points for an unsupported language you can either do this in the container or
    better still, write your own lexer following the pattern of one of the existing ones.</p>

    <p>Scintilla は外部の解析器にも対応します。Windows では DLL、GTK+/Linux では .so モジュールの形で、次の四関数をエクスポートしたものを使います。<code>GetLexerCount</code>, <code>GetLexerName</code>, <code>Lex</code>, <code>Fold</code>.</p>
	<p>詳しくは <code>externalLexer.cxx</code> を参照してください。</p>
    <p class="eng">Scintilla also supports external lexers. These are DLLs (on Windows) or .so modules (on GTK+/Linux) that export four
    functions: <code>GetLexerCount</code>, <code>GetLexerName</code>, <code>Lex</code> and
    <code>Fold</code>. See <code>externalLexer.cxx</code> for more.</p>
    <code><a class="message" href="#SCI_SETLEXER">SCI_SETLEXER(int lexer)</a><br />
     <a class="message" href="#SCI_GETLEXER">SCI_GETLEXER</a><br />
     <a class="message" href="#SCI_SETLEXERLANGUAGE">SCI_SETLEXERLANGUAGE(&lt;unused&gt;, char
    *name)</a><br />
     <a class="message" href="#SCI_LOADLEXERLIBRARY">SCI_LOADLEXERLIBRARY(&lt;unused&gt;, char
    *path)</a><br />
     <a class="message" href="#SCI_COLOURISE">SCI_COLOURISE(int start, int end)</a><br />
     <a class="message" href="#SCI_SETPROPERTY">SCI_SETPROPERTY(const char *key, const char *value)</a><br />
     <a class="message" href="#SCI_SETKEYWORDS">SCI_SETKEYWORDS(int keyWordSet, const char
    *keyWordList)</a><br />
    </code>
<h3 id="SCI_SETLEXER">SCI_SETLEXER(int lexer)<br />
     <span id="SCI_GETLEXER">SCI_GETLEXER</span></h3>
    <p><code>Scintilla.h</code> に列挙されている <code>SCLEX_*</code> を使うことで解析器を選択できます。このうち二つは解析器を使わないことを示すものです。<code>SCLEX_NULL</code> は解析そのものを行いません。<code>SCLEX_CONTAINER</code> は装飾情報を必要とするテキストがある時に通知 <code><a class="message" href="#SCN_STYLENEEDED">SCN_STYLENEEDED</a></code> をコンテナに送信します。<code>SCLEX_AUTOMATIC</code> は使用することができません。これは外部の追加解析器を示し、Scintilla が未使用の解析器番号を割り当てていくものです。</p>
    <p class="eng"><b>SCI_SETLEXER(int lexer)</b><br />
     <b>SCI_GETLEXER</b><br />
     You can select the lexer to use with an integer code from the <code>SCLEX_*</code> enumeration
    in <code>Scintilla.h</code>. There are two codes in this sequence that do not use lexers:
    <code>SCLEX_NULL</code> to select no lexing action and <code>SCLEX_CONTAINER</code> which sends
    the <code><a class="message" href="#SCN_STYLENEEDED">SCN_STYLENEEDED</a></code> notification to
    the container whenever a range of text needs to be styled. You cannot use the
    <code>SCLEX_AUTOMATIC</code> value; this identifies additional external lexers that Scintilla
    assigns unused lexer numbers to.</p>
<h3 id="SCI_SETLEXERLANGUAGE">SCI_SETLEXERLANGUAGE(&lt;unused&gt;, const char *name)</h3>
    <p>名称を元に解析器を選択します。またこれは、外部解析器を使っている場合あるいは独自の解析器を使っていてそれに明示的な番号を割り当てたくない場合の唯一の方法です。既存の解析器を選択する場合は <code>name</code> にモジュールが与えられている名前を指定します。大文字小文字を区別しますので "ada" や "python" と指定してください。"Ada", "Python" は使えません。組み込み済み解析器の名前は、対応する <code>Lex*.cxx</code> の中で <code>LexerModule</code> を検索してください。<code>LexerModule</code> のコンストラクタの第三引数がその名前です。</p>
    <p class="eng"><b>SCI_SETLEXERLANGUAGE(&lt;unused&gt;, const char *name)</b><br />
     This message lets you select a lexer by name, and is the only method if you are using an
    external lexer or if you have written a lexer module for a language of your own and do not wish
    to assign it an explicit lexer number. To select an existing lexer, set <code>name</code> to
    match the (case sensitive) name given to the module, for example "ada" or "python", not "Ada"
    or "Python". To locate the name for the built-in lexers, open the relevant
    <code>Lex*.cxx</code> file and search for <code>LexerModule</code>. The third argument in the
    <code>LexerModule</code> constructor is the name to use.</p>

    <p>解析器の割り当てが動作するかどうかは、新しい解析器を設定する前後に <a class="message"
    href="#SCI_GETLEXER"><code>SCI_GETLEXER</code></a> を使って解析器番号が変化するかどうかを見てください。</p>
    <p class="eng">To test if your lexer assignment worked, use <a class="message"
    href="#SCI_GETLEXER"><code>SCI_GETLEXER</code></a> before and after setting the new lexer to
    see if the lexer number changed.</p>
<h3 id="SCI_LOADLEXERLIBRARY">SCI_LOADLEXERLIBRARY(&lt;unused&gt;, const char *path)</h3>
    <p>共有ライブラリに実装されている解析器を読み出します。GTK+/Linux では .so 、Windows では .DLL ファイルです。</p>
    <p class="eng"><b>SCI_LOADLEXERLIBRARY(&lt;unused&gt;, const char *path)</b><br />
     Load a lexer implemented in a shared library. This is a .so file on GTK+/Linux or a .DLL file on Windows.
     </p>
<h3 id="SCI_COLOURISE">SCI_COLOURISE(int startPos, int endPos)</h3>
    <p>文書の <code>startPos</code> と <code>endPos</code> の間のテキスト装飾を現在の解析器かコンテナに実行させます。解析器が <code>SCLEX_CONTAINER</code> である場合にコンテナ任せになります。</p>
	<p><code>endPos</code> が -1 の場合、<code>startPos</code> から文書末までが対象となります。<code>"fold"</code> 特性が <code>"1"</code> に設定されていて、かつ解析器またはコンテナが折りたたみに対応している場合は折りたたみ階層数も設定されます。このメッセージは画面再描画を起こします。</p>
    <p class="eng"><b>SCI_COLOURISE(int startPos, int endPos)</b><br />
     This forces the current lexer or the container (if the lexer is set to
    <code>SCLEX_CONTAINER</code>) to style the document between <code>startPos</code> and
    <code>endPos</code>. If <code>endPos</code> is -1, the document is styled from
    <code>startPos</code> to the end. If the <code>"fold"</code> property is set to
    <code>"1"</code> and your lexer or container supports folding, fold levels are also set. This
    message causes a redraw.</p>
<h3 id="SCI_SETPROPERTY">SCI_SETPROPERTY(const char *key, const char *value)</h3>
    <p>キーワードと値から成る文字列の組で解析器と対話をします。キーワードの組数に制限はなく、メモリの許す限り使えます。<code>key</code> はキーワードで、大文字小文字を区別します。<code>value</code> はキーワードに関係づけられた文字列です。すでに指定キーワードに値が設定されているときは、置換されます。長さ 0 の文字列を指定した場合は何もしません。<code>key</code> と <code>value</code> は修正なしで使用されます。<code>key</code> で指定した文字列の先頭や末尾の空白文字も意味を持ちます。</p>
    <p class="eng"><b>SCI_SETPROPERTY(const char *key, const char *value)</b><br />
     You can communicate settings to lexers with keyword:value string pairs. There is no limit to
    the number of keyword pairs you can set, other than available memory. <code>key</code> is a
    case sensitive keyword, <code>value</code> is a string that is associated with the keyword. If
    there is already a value string associated with the keyword, it is replaced. If you pass a zero
    length string, the message does nothing. Both <code>key</code> and <code>value</code> are used
    without modification; extra spaces at the beginning or end of <code>key</code> are
    significant.</p>

    <p><code>value</code> は他のキーワードを参照することができます。<code>SCI_SETPROPERTY("foldTimes10", "$(fold)0")</code> は <code>"$(fold)0"</code> を格納しますが、取得しようとすると <code>$(fold)</code> が <code>"fold"</code> キーワードの値に置換されます。置換されるキーワードが存在しないときはその部分の文字列はありません。</p>
    <p class="eng">The <code>value</code> string can refer to other keywords. For example,
    <code>SCI_SETPROPERTY("foldTimes10", "$(fold)0")</code> stores the string
    <code>"$(fold)0"</code>, but when this is accessed, the <code>$(fold)</code> is replaced by the
    value of the <code>"fold"</code> keyword (or by nothing if this keyword does not exist).</p>

    <p>現在、"fold" 特性は大部分の解析器で "1" の時に折りたたみ構造を指定するように定義されています。<code>SCLEX_PYTHON</code> では <code>"tab.timmy.whinge.level"</code> を不正な字下げの表示方法の指定として扱います。大部分のキーワードは整数に通訳されます。解析器のソースで <code>GetPropertyInt</code> の部分を探すと特性の使い方がわかります。</p>
    <p class="eng">Currently the "fold" property is defined for most of the lexers to set the fold structure if
    set to "1". <code>SCLEX_PYTHON</code> understands <code>"tab.timmy.whinge.level"</code> as a
    setting that determines how to indicate bad indentation. Most keywords have values that are
    interpreted as integers. Search the lexer sources for <code>GetPropertyInt</code> to see how
    properties are used.</p>
<h3 id="SCI_SETKEYWORDS">SCI_SETKEYWORDS(int keyWordSet, const char *keyWordList)</h3>
    <p>現在使用中の解析器に対して最大 9 つのキーワード項目群を設定できます(版 1.50 号で 6 から 9 になりました)。<code>keyWordSet</code> は 0 〜 8(<code>KEYWORDSET_MAX</code>) で、設定する項目群番号を指定します。<code>keyWordList</code> は空白文字、タブ文字、<code>"\n"</code>、<code>"\r"</code>またはこの組み合わせで区切られたキーワード群です。キーワードは ASCII 標準印刷可能文字から成ることを期待した設計になっていますが、コード番号 1 〜 255 の区切り文字ではない文字を弾くような処理はしていません。</p>
	<p>(訳注: 原文は「常識以外に 1 〜 255 の文字を止めるものはない」と読めるが、そうだとしたらずいぶん失礼な話だと思う。)</p>
    <p class="eng"><b>SCI_SETKEYWORDS(int keyWordSet, const char *keyWordList)</b><br />
     You can set up to 9 lists of keywords for use by the current lexer. This was increased from 6
    at revision 1.50. <code>keyWordSet</code> can be 0 to 8 (actually 0 to <code>KEYWORDSET_MAX</code>)
    and selects which keyword list to replace. <code>keyWordList</code> is a list of keywords
    separated by spaces, tabs, <code>"\n"</code> or <code>"\r"</code> or any combination of these.
    It is expected that the keywords will be composed of standard ASCII printing characters,
    but there is nothing to stop you using any non-separator character codes from 1 to 255
    (except common sense).</p>

    <p>キーワードをどのように使うかは完全に解析器側に任されています。一部の言語は、他の埋め込み言語を含んでいることがあり、たとえば HTML では VBScript, JavaScript などがよく埋め込まれています。HTML の場合は項目群 0 がHTML, 1 が JavaScript, 2 が VBScript, 3 が Python, 4 が PHP, 5 が SGML と DTD のキーワード集合を持っています。キーワード項目群の例は解析器のコードを見てください。完全に仕様を満たした解析器では <code>LexerModule</code> コンストラクタの第四引数が各キーワード群の用途を記述した項目群の文字列となっています。</p>
    <p class="eng">How these keywords are used is entirely up to the lexer. Some languages, such as HTML may
    contain embedded languages, VBScript and JavaScript are common for HTML. For HTML, key word set
    0 is for HTML, 1 is for JavaScript and 2 is for VBScript, 3 is for Python, 4 is for PHP and 5
    is for SGML and DTD keywords. Review the lexer code to see examples of keyword list. A fully
    conforming lexer sets the fourth argument of the <code>LexerModule</code> constructor to be a
    list of strings that describe the uses of the keyword lists.</p>

    <p>項目群 0 に一般キーワード、項目群 1 に字下げを起こすキーワード、項目群 2 に字下げを解除するキーワード、という使い方もできます。また、キーワードに色を付けるだけの簡単な解析器を使い、キーワード項目群 0 を差し替えることで言語の切り替えを表すということもできます。解析器自身にキーワード項目群を組み込んでしまうことも可能ですが、この場合キーワードが増えたときには解析器を再構築しなくてはなりません。</p>
    <p class="eng">Alternatively, you might use set 0 for general keywords, set 1 for keywords that cause
    indentation and set 2 for keywords that cause unindentation. Yet again, you might have a simple
    lexer that colours keywords and you could change languages by changing the keywords in set 0.
    There is nothing to stop you building your own keyword lists into the lexer, but this means
    that the lexer must be rebuilt if more keywords are added.</p>

    <h2 id="Notifications"><span>通知</span><span class="eng">Notifications</span></h2>

    <p>通知は Scintilla コントロールからそのコンテナへ、コンテナが関わってくるようなイベントが発生したときに送信されます。Windows では <code>WM_NOTIFY</code> メッセージで、GTK+ では "notify" シグナルで通知が送られてきます。コンテナはイベント情報を持っている <code>SCNotification</code> を渡されることになります。</p>
    <p class="eng">Notifications are sent (fired) from the Scintilla control to its container when an event has
    occurred that may interest the container. Notifications are sent using the
    <code>WM_NOTIFY</code> message on Windows and the "notify" signal on GTK+. The container is
    passed a <code>SCNotification</code> structure containing information about the event.</p>
<pre id="SCNotification">
struct NotifyHeader {   // Win32 の NMHDR 構造体と同じ形です。<span class="eng">This matches the Win32 NMHDR structure</span>
    void *hwndFrom;     // 環境依存のウィンドウハンドルもしくはポインタ。<span class="eng">environment specific window handle/pointer</span>
    unsigned int idFrom;// 通知を出すウィンドウの CtrlID。<span class="eng">CtrlID of the window issuing the notification</span>
    unsigned int code;  // SCN_* 通知コードが入ります。<span class="eng">The SCN_* notification code</span>
};

struct SCNotification {
    struct NotifyHeader nmhdr;
    int position;
    // SCN_STYLENEEDED, SCN_MODIFIED, SCN_DWELLSTART,
    // SCN_DWELLEND, SCN_CALLTIPCLICK,
    // SCN_HOTSPOTCLICK, SCN_HOTSPOTDOUBLECLICK
    int ch;             // SCN_CHARADDED, SCN_KEY
    int modifiers;      // SCN_KEY, SCN_HOTSPOTCLICK, SCN_HOTSPOTDOUBLECLICK
    int modificationType; // SCN_MODIFIED
    const char *text;   // SCN_MODIFIED
    int length;         // SCN_MODIFIED
    int linesAdded;     // SCN_MODIFIED
    int message;        // SCN_MACRORECORD
    uptr_t wParam;      // SCN_MACRORECORD
    sptr_t lParam;      // SCN_MACRORECORD
    int line;           // SCN_MODIFIED
    int foldLevelNow;   // SCN_MODIFIED
    int foldLevelPrev;  // SCN_MODIFIED
    int margin;         // SCN_MARGINCLICK
    int listType;       // SCN_USERLISTSELECTION
    int x;              // SCN_DWELLSTART, SCN_DWELLEND
    int y;              // SCN_DWELLSTART, SCN_DWELLEND
};
</pre>

    <p>コンテナが操作できる通知メッセージあるいは関連するメッセージは次の通りです。</p>
    <p class="eng">The notification messages that your container can choose to handle and the messages
    associated with them are:</p>
    <code><a class="message" href="#SCN_STYLENEEDED">SCN_STYLENEEDED</a><br />
     <a class="message" href="#SCN_CHARADDED">SCN_CHARADDED</a><br />
     <a class="message" href="#SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</a><br />
     <a class="message" href="#SCN_SAVEPOINTLEFT">SCN_SAVEPOINTLEFT</a><br />
     <a class="message" href="#SCN_MODIFYATTEMPTRO">SCN_MODIFYATTEMPTRO</a><br />
     <a class="message" href="#SCN_KEY">SCN_KEY</a><br />
     <a class="message" href="#SCN_DOUBLECLICK">SCN_DOUBLECLICK</a><br />
     <a class="message" href="#SCN_UPDATEUI">SCN_UPDATEUI</a><br />
     <a class="message" href="#SCN_MODIFIED">SCN_MODIFIED</a><br />
     <a class="message" href="#SCN_MACRORECORD">SCN_MACRORECORD</a><br />
     <a class="message" href="#SCN_MARGINCLICK">SCN_MARGINCLICK</a><br />
     <a class="message" href="#SCN_NEEDSHOWN">SCN_NEEDSHOWN</a><br />
     <a class="message" href="#SCN_PAINTED">SCN_PAINTED</a><br />
     <a class="message" href="#SCN_USERLISTSELECTION">SCN_USERLISTSELECTION</a><br />
     <a class="message" href="#SCN_URIDROPPED">SCN_URIDROPPED</a><br />
     <a class="message" href="#SCN_DWELLSTART">SCN_DWELLSTART</a><br />
     <a class="message" href="#SCN_DWELLEND">SCN_DWELLEND</a><br />
     <a class="message" href="#SCN_ZOOM">SCN_ZOOM</a><br />
     <a class="message" href="#SCN_HOTSPOTCLICK">SCN_HOTSPOTCLICK</a><br />
     <a class="message" href="#SCN_HOTSPOTDOUBLECLICK">SCN_HOTSPOTDOUBLECLICK</a><br />
     <a class="message" href="#SCN_CALLTIPCLICK">SCN_CALLTIPCLICK</a><br />
    </code>

    <p>次の <code>SCI_*</code> メッセージはこれらの通知と関係しています。</p>
    <p class="eng">The following <code>SCI_*</code> messages are associated with these notifications:</p>
    <code><a class="message" href="#SCI_SETMODEVENTMASK">SCI_SETMODEVENTMASK(int
    eventMask)</a><br />
     <a class="message" href="#SCI_GETMODEVENTMASK">SCI_GETMODEVENTMASK</a><br />
     <a class="message" href="#SCI_SETMOUSEDWELLTIME">SCI_SETMOUSEDWELLTIME</a><br />
     <a class="message" href="#SCI_GETMOUSEDWELLTIME">SCI_GETMOUSEDWELLTIME</a><br />
    </code>

    <p>次の通知は Windows では<code>WM_COMMAND</code>  を、GTK+ では "Command" シグナルを通して送信され、Windows のエディットコントロールを模倣することに使われます。</p>
    <p class="eng">The following additional notifications are sent using the <code>WM_COMMAND</code> message on
    Windows and the "Command" signal on GTK+ to emulate the Windows Edit control:</p>
    <code><a class="message" href="#SCEN_CHANGE">SCEN_CHANGE</a><br />
     <a class="message" href="#SCEN_SETFOCUS">SCEN_SETFOCUS</a><br />
     <a class="message" href="#SCEN_KILLFOCUS">SCEN_KILLFOCUS</a><br />
    </code>
<h3 id="SCN_STYLENEEDED">SCN_STYLENEEDED</h3>
    <p><code><a class="message"
    href="#SCI_SETLEXER">SCI_SETLEXER</a>(SCLEX_CONTAINER)</code> によりコンテナが解析器の役割をも担うように設定するとこの通知が送られるようになります。装飾が必要なテキスト表示もしくは印刷を行おうとするとき発光されます。<a class="message" href="#SCI_GETENDSTYLED"><code>SCI_GETENDSTYLED</code></a> の戻り値を含んでいる行から <code>SCNotification.position</code> で渡される位置までの装飾を要求されていることになります。端的には次のようなコードが必要となります。</p>

<p class="eng"><b>SCN_STYLENEEDED</b><br />
     If you used <code><a class="message"
    href="#SCI_SETLEXER">SCI_SETLEXER</a>(SCLEX_CONTAINER)</code> to make the container act as the
    lexer, you will receive this notification when Scintilla is about to display or print text that
    requires styling. You are required to style the text from the line that contains the position
    returned by <a class="message" href="#SCI_GETENDSTYLED"><code>SCI_GETENDSTYLED</code></a> up to
    the position passed in <code>SCNotification.position</code>. Symbolically, you need code of the
    form:</p>
<pre>
    startPos = <a class="message" href="#SCI_GETENDSTYLED">SCI_GETENDSTYLED</a>()
    lineNumber = <a class="message"
href="#SCI_LINEFROMPOSITION">SCI_LINEFROMPOSITION</a>(startPos);
    startPos = <a class="message"
href="#SCI_POSITIONFROMLINE">SCI_POSITIONFROMLINE</a>(lineNumber);
    MyStyleRoutine(startPos, SCNotification.position);
</pre>
<h3 id="SCN_CHARADDED">SCN_CHARADDED</h3>
    <p>ユーザが通常の(コマンド文字ではない、と言う意味での)テキスト文字をタイプしたときに送られるメッセージです。メッセージを受け取ったコンテナは<a
    class="jump" href="#CallTips">コールチップ</a>や<a class="jump" href="#Autocompletion">自動補完候補項目</a>を表示するかどうかなどを決めることができます。タイプされた文字は <code>SCNotification.ch</code> に入っています。</p>
    <p class="eng"><b>SCN_CHARADDED</b><br />
     This is sent when the user types an ordinary text character (as opposed to a command
    character) that is entered into the text. The container can use this to decide to display a <a
    class="jump" href="#CallTips">call tip</a> or an <a class="jump" href="#Autocompletion">auto
    completion list</a>. The character is in <code>SCNotification.ch</code>.</p>
<h3 id="SCN_SAVEPOINTREACHED">SCN_SAVEPOINTREACHED</h3>
    <p>保存点に戻ってきたかそこから変化していくときに送られてくるメッセージです。コンテナはこれにより「文書変更済み」のサインを表示し、関連メニューを変更できます。</p>
	<p>参照: <a class="message" href="#SCI_SETSAVEPOINT"><code>SCI_SETSAVEPOINT</code></a>, <a
    class="message" href="#SCI_GETMODIFY"><code>SCI_GETMODIFY</code></a></p>
    <p class="eng"><b>SCN_SAVEPOINTREACHED</b><br />
     <b>SCN_SAVEPOINTLEFT</b><br />
     Sent to the container when the save point is entered or left, allowing the container to
    display a "document dirty" indicator and change its menus.<br />
     See also: <a class="message" href="#SCI_SETSAVEPOINT"><code>SCI_SETSAVEPOINT</code></a>, <a
    class="message" href="#SCI_GETMODIFY"><code>SCI_GETMODIFY</code></a></p>
<h3 id="SCN_MODIFYATTEMPTRO">SCN_MODIFYATTEMPTRO</h3>
    <p>読み出し専用モードの時にユーザがテキストの変更を試みた場合に送信されるメッセージです。版管理系からの文書を調べることに利用できます。文書を読み出し専用にするには <code><a class="message"
    href="#SCI_SETREADONLY">SCI_SETREADONLY</a></code> を使います。</p>
    <p class="eng"><b>SCN_MODIFYATTEMPTRO</b><br />
     When in read-only mode, this notification is sent to the container if the user tries to change
    the text. This can be used to check the document out of a version control system. You can set
    the read-only state of a document with <code><a class="message"
    href="#SCI_SETREADONLY">SCI_SETREADONLY</a></code>.</p>
<h3 id="SCN_KEY">SCN_KEY</h3>
    <p>あらゆるキーの押下を報告するメッセージです。GTK+ のキーボードフォーカスの問題から、GTK+ でのみ使われます。Windows 版では送信されません。<code>SCNotification.ch</code> にキーコード、<code>SCNotification.modifiers</code> に修飾キー情報が入っています。この通知は修飾キーに <code>SCMOD_ALT</code> もしくは <code>SCMOD_CTRL</code> が含まれていて、キーコードが 256 未満の場合に送信されます。</p>
    <p class="eng"><b>SCN_KEY</b><br />
     Reports all keys pressed. Used on GTK+ because of some problems with keyboard focus and is not
    sent by the Windows version. <code>SCNotification.ch</code> holds the key code and
    <code>SCNotification.modifiers</code> holds the modifiers. This notification is sent if the
    modifiers include <code>SCMOD_ALT</code> or <code>SCMOD_CTRL</code> and the key code is less
    than 256.</p>
<h3 id="SCN_DOUBLECLICK">SCN_DOUBLECLICK</h3>
    <p>エディタの中でマウスボタンがダブルクリックされたときに送信されます。付加情報はありません。</p>
    <p class="eng"><b>SCN_DOUBLECLICK</b><br />
     The mouse button was double clicked in editor. There is no additional information.</p>
<h3 id="SCN_UPDATEUI">SCN_UPDATEUI</h3>
    <p>文書内のテキストもしくは装飾が変更されたり、選択範囲が変化したりしたときに送信されます。文書や表示状態に依存するユーザインタフェイス要素を更新する機会となります。かつては <code><a class="message"
    href="#SCN_CHECKBRACE">SCN_CHECKBRACE</a></code> として使われていたもので、主な利用方法が括弧の隣にキャレットがあるかどうかの調査、またあるのであればその括弧及び対応する括弧の強調にあったからです。このメッセージは <a class="message" href="#SCN_POSCHANGED"><code>SCN_POSCHANGED</code></a> をも廃止統合しています。</p>
    <p class="eng"><b>SCN_UPDATEUI</b><br />
     Either the text or styling of the document has changed or the selection range has changed. Now
    would be a good time to update any container UI elements that depend on document or view state.
    This was previously called <code><a class="message"
    href="#SCN_CHECKBRACE">SCN_CHECKBRACE</a></code> because a common use is to check whether the
    caret is next to a brace and set highlights on this brace and its corresponding matching brace.
    This also replaces <a class="message" href="#SCN_POSCHANGED"><code>SCN_POSCHANGED</code></a>,
    which is now deprecated.</p>
<h3 id="SCN_MODIFIED">SCN_MODIFIED</h3>
    <p>テキストや装飾が変更されたか、あるいはされようとしているときに発行される通知です。コンテナに送信される通知は <a
    class="message" href="#SCI_SETMODEVENTMASK"><code>SCI_SETMODEVENTMASK</code></a> によって選別することができます。何がどのように変化するか、また総行数を変更したかどうかが通知構造体に収められています。<code>SCN_MODIFIED</code> イベントが起きている間は実際の変化は起こりません。<code>SCNotification</code> の使われ肩は次の通りです。</p>
    <p class="eng"><b>SCN_MODIFIED</b><br />
     This notification is sent when the text or styling of the document changes or is about to
    change. You can set a mask for the notifications that are sent to the container with <a
    class="message" href="#SCI_SETMODEVENTMASK"><code>SCI_SETMODEVENTMASK</code></a>. The
    notification structure contains information about what changed, how the change occurred and
    whether this changed the number of lines in the document. No modifications may be performed
    while in a <code>SCN_MODIFIED</code> event. The <code>SCNotification</code> fields used
    are:</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="変更通知の種別">
      <tbody>
        <tr>
          <th align="left">項目</th>

          <th align="left">用途</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>modificationType</code></td>

          <td align="left">変更内容を示すフラグの論理和。次の表を参照してください。</td>
        </tr>

        <tr>
          <td align="left"><code>position</code></td>

          <td align="left">テキストまたは装飾が変更される開始点。使われない場合は 0。</td>
        </tr>

        <tr>
          <td align="left"><code>length</code></td>

          <td align="left">テキストか装飾が変更される場合の装飾セル数もしくは文字数。使われない場合は 0。</td>
        </tr>

        <tr>
          <td align="left"><code>linesAdded</code></td>

          <td align="left">追加行数。負の値の場合は削除行数。増減がない場合は 0。</td>
        </tr>

        <tr>
          <td align="left"><code>text</code></td>

          <td align="left">テキストの変化に関する場合のみ有効、装飾の変更の場合は使われません。やり直しに関する情報を収集していたときはその処理へ渡すテキストへのポインタを格納しています。そうでなければ 0 です。</td>
        </tr>

        <tr>
          <td align="left"><code>line</code></td>

          <td align="left">折りたたみ階層数もしくはマーカの変化が起きた行番号。使われない場合は 0。</td>
        </tr>

        <tr>
          <td align="left"><code>foldLevelNow</code></td>

          <td align="left">当該行に新しく割り当てられる折りたたみ階層数。使われない場合は 0。</td>
        </tr>

        <tr>
          <td align="left"><code>foldLevelPrev</code></td>

          <td align="left">当該行の以前の折りたたみ階層数。使われない場合は 0。</td>
        </tr>
      </tbody>
    </table>


    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Modify notification types">
      <tbody>
        <tr>
          <th align="left">Field</th>

          <th align="left">Usage</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>modificationType</code></td>

          <td align="left">A set of flags that identify the change(s) made. See the next
          table.</td>
        </tr>

        <tr>
          <td align="left"><code>position</code></td>

          <td align="left">Start position of a text or styling change. Set to 0 if not used.</td>
        </tr>

        <tr>
          <td align="left"><code>length</code></td>

          <td align="left">Length of the change in cells or characters when the text or styling
          changes. Set to 0 if not used.</td>
        </tr>

        <tr>
          <td align="left"><code>linesAdded</code></td>

          <td align="left">Number of added lines. If negative, the number of deleted lines. Set to
          0 if not used or no lines added or deleted.</td>
        </tr>

        <tr>
          <td align="left"><code>text</code></td>

          <td align="left">Valid for text changes, not for style changes. If we are collecting undo
          information this holds a pointer to the text that is handed to the Undo system, otherwise
          it is zero.</td>
        </tr>

        <tr>
          <td align="left"><code>line</code></td>

          <td align="left">The line number at which a fold level or marker change occurred. This is
          0 if unused.</td>
        </tr>

        <tr>
          <td align="left"><code>foldLevelNow</code></td>

          <td align="left">The new fold level applied to the line or 0 if this field is
          unused.</td>
        </tr>

        <tr>
          <td align="left"><code>foldLevelPrev</code></td>

          <td align="left">The previous folding level of the line or 0 if this field is
          unused.</td>
        </tr>
      </tbody>
    </table>

    <p><code>SCNotification.modificationType</code> は何が行われたかを示すビット集合となっています。<code>SC_MOD_*</code> が行動と関連づけられています。<code>SC_PREFORMED_*</code> ビットでユーザの操作によるものか、またはやり直し・再実行の結果によるものかが示されます。</p>
    <p class="eng">The <code>SCNotification.modificationType</code> field has bits set to tell you what has
    been done. The <code>SC_MOD_*</code> bits correspond to actions. The
    <code>SC_PREFORMED_*</code> bits tell you if the action was done by the user, or the result of
    Undo or Redo of a previous action.</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="変更通知種別フラグ">
      <tbody>
        <tr>
          <th align="left">定数</th>

          <th>値</th>

          <th align="left">意味</th>

          <th align="left">SCNotification 上の有効項目</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_MOD_INSERTTEXT</code></td>

          <td align="center">0x01</td>

          <td>文書にテキストが挿入されました。</td>

          <td><code>position, length, linesAdded</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_DELETETEXT</code></td>

          <td align="center">0x02</td>

          <td>テキストが文書から取り除かれました。</td>

          <td><code>position, length, linesAdded</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_CHANGESTYLE</code></td>

          <td align="center">0x04</td>

          <td>装飾の変更が起きました。</td>

          <td><code>position, length</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_CHANGEFOLD</code></td>

          <td align="center">0x08</td>

          <td>折りたたみの変更が起きました。</td>

          <td><code>line, foldLevelNow, foldLevelPrev</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_PERFORMED_USER</code></td>

          <td align="center">0x10</td>

          <td>情報: ユーザによって行われました。</td>

          <td>なし</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PERFORMED_UNDO</code></td>

          <td align="center">0x20</td>

          <td>情報: やり直しによって起きました。</td>

          <td>なし</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PERFORMED_REDO</code></td>

          <td align="center">0x40</td>

          <td>情報: 再実行によって起きました。</td>

          <td>なし</td>
        </tr>

        <tr>
          <td align="left"><code>SC_LASTSTEPINUNDOREDO</code></td>

          <td align="center">0x100</td>

          <td>複数セクションを持つやり直し・再実行の最後の一処理です。</td>

          <td>なし</td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_CHANGEMARKER</code></td>

          <td align="center">0x200</td>

          <td>マーカが変更されました。</td>

          <td><code>line</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_BEFOREINSERT</code></td>

          <td align="center">0x400</td>

          <td>文書の中にテキストが挿入されようとしています。</td>

          <td><code>position, length</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_BEFOREDELETE</code></td>

          <td align="center">0x800</td>

          <td>文書からテキストが取り除かれようとしています。</td>

          <td><code>position, length</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MODEVENTMASKALL</code></td>

          <td align="center">0xf77</td>

          <td>すべての有効なフラグを重ねたマスクです。<a
          class="message" href="#SCI_SETMODEVENTMASK"><code>SCI_SETMODEVENTMASK</code></a> の初期設定値です。</td>

          <td>なし</td>
        </tr>
      </tbody>
    </table>


    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Modify notification type flags">
      <tbody>
        <tr>
          <th align="left">Symbol</th>

          <th>Value</th>

          <th align="left">Meaning</th>

          <th align="left">SCNotification fields</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>SC_MOD_INSERTTEXT</code></td>

          <td align="center">0x01</td>

          <td>Text has been inserted into the document.</td>

          <td><code>position, length, linesAdded</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_DELETETEXT</code></td>

          <td align="center">0x02</td>

          <td>Text has been removed from the document.</td>

          <td><code>position, length, linesAdded</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_CHANGESTYLE</code></td>

          <td align="center">0x04</td>

          <td>A style change has occurred.</td>

          <td><code>position, length</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_CHANGEFOLD</code></td>

          <td align="center">0x08</td>

          <td>A folding change has occurred.</td>

          <td><code>line, foldLevelNow, foldLevelPrev</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_PERFORMED_USER</code></td>

          <td align="center">0x10</td>

          <td>Information: the operation was done by the user.</td>

          <td>None</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PERFORMED_UNDO</code></td>

          <td align="center">0x20</td>

          <td>Information: this was the result of an Undo.</td>

          <td>None</td>
        </tr>

        <tr>
          <td align="left"><code>SC_PERFORMED_REDO</code></td>

          <td align="center">0x40</td>

          <td>Information: this was the result of a Redo.</td>

          <td>None</td>
        </tr>

        <tr>
          <td align="left"><code>SC_LASTSTEPINUNDOREDO</code></td>

          <td align="center">0x100</td>

          <td>This is the final step in an Undo or Redo that has several sections.</td>

          <td>None</td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_CHANGEMARKER</code></td>

          <td align="center">0x200</td>

          <td>One or more markers has changed in a line.</td>

          <td><code>line</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_BEFOREINSERT</code></td>

          <td align="center">0x400</td>

          <td>Text is about to be inserted into the document.</td>

          <td><code>position, length</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MOD_BEFOREDELETE</code></td>

          <td align="center">0x800</td>

          <td>Text is about to be deleted from the document.</td>

          <td><code>position, length</code></td>
        </tr>

        <tr>
          <td align="left"><code>SC_MODEVENTMASKALL</code></td>

          <td align="center">0xf77</td>

          <td>This is a mask for all valid flags. This is the default mask state set by <a
          class="message" href="#SCI_SETMODEVENTMASK"><code>SCI_SETMODEVENTMASK</code></a>.</td>

          <td>None</td>
        </tr>
      </tbody>
    </table>

<h3 id="SCEN_CHANGE">SCEN_CHANGE</h3>
<p><code>SCEN_CHANGE</code> (768) は文書内のテキストが変更されたときに発行されます。装飾の変更では発行されません。この通知は Windows では <code>WM_COMMAND</code> を、GTK+ では "Command" シグナルを用いて送られます。標準のエディットコントロールと同じ挙動を行うために発行されているもので、Windows では <code>SCEN_CHANGE</code> と <code>EN_CHANGE</code> が同じ値を持っています。他の情報は送られてきません。詳細を知る場合は <a class="message" href="#SCN_MODIFIED"><code>SCN_MODIFIED</code></a> を用いてください。<a class="message"
    href="#SCI_SETMODEVENTMASK"><code>SCI_SETMODEVENTMASK</code></a> によって通知をあらかじめ選別することができます。</p>
    <p class="eng"><b>SCEN_CHANGE</b><br />
     <code>SCEN_CHANGE</code> (768) is fired when the text (not the style) of the document changes.
    This notification is sent using the <code>WM_COMMAND</code> message on Windows and the
    "Command" signal on GTK+ as this is the behavior of the standard Edit control
    (<code>SCEN_CHANGE</code> has the same value as the Windows Edit control
    <code>EN_CHANGE</code>). No other information is sent. If you need more detailed information
    use <a class="message" href="#SCN_MODIFIED"><code>SCN_MODIFIED</code></a>. You can filter the
    types of changes you are notified about with <a class="message"
    href="#SCI_SETMODEVENTMASK"><code>SCI_SETMODEVENTMASK</code></a>.</p>
<h3 id="SCI_SETMODEVENTMASK">SCI_SETMODEVENTMASK(int eventMask)<br />
     <span id="SCI_GETMODEVENTMASK">SCI_GETMODEVENTMASK</span></h3>
    <p><a class="message"
    href="#SCN_MODIFIED"><code>SCN_MODIFIED</code></a> と <a class="message"
    href="#SCEN_CHANGE"><code>SCEN_CHANGE</code></a> において、文書の変更に関しどの情報をコンテナに通知するかを設定あるいは取得します。たとえば装飾変更情報を不要とし、テキストの変更があったときだけ通知をもらう場合は <code>SCI_SETMODEVENTMASK(SC_MOD_INSERTTEXT|SC_MOD_DELETETEXT)</code> というコードを使います。</p>
    <p class="eng"><b>SCI_SETMODEVENTMASK(int eventMask)</b><br />
     <b>SCI_GETMODEVENTMASK</b><br />
     These messages set and get an event mask that determines which document change events are
    notified to the container with <a class="message"
    href="#SCN_MODIFIED"><code>SCN_MODIFIED</code></a> and <a class="message"
    href="#SCEN_CHANGE"><code>SCEN_CHANGE</code></a>. For example, a container may decide to see
    only notifications about changes to text and not styling changes by calling
    <code>SCI_SETMODEVENTMASK(SC_MOD_INSERTTEXT|SC_MOD_DELETETEXT)</code>.</p>

    <p>通知の種別は <code>SCN_MODIFIED</code> で使われている <code>modificationType</code> ビットフラグと同じです。具体的には次の通りです。<code>SC_MOD_INSERTTEXT</code>,
    <code>SC_MOD_DELETETEXT</code>, <code>SC_MOD_CHANGESTYLE</code>,
    <code>SC_MOD_CHANGEFOLD</code>, <code>SC_PERFORMED_USER</code>, <code>SC_PERFORMED_UNDO</code>,
    <code>SC_PERFORMED_REDO</code>, <code>SC_LASTSTEPINUNDOREDO</code>,
    <code>SC_MOD_CHANGEMARKER</code>, <code>SC_MOD_BEFOREINSERT</code>,
    <code>SC_MOD_BEFOREDELETE</code>, <code>SC_MODEVENTMASKALL</code>.</p>
    <p class="eng">The possible notification types are the same as the <code>modificationType</code> bit flags
    used by <code>SCN_MODIFIED</code>: <code>SC_MOD_INSERTTEXT</code>,
    <code>SC_MOD_DELETETEXT</code>, <code>SC_MOD_CHANGESTYLE</code>,
    <code>SC_MOD_CHANGEFOLD</code>, <code>SC_PERFORMED_USER</code>, <code>SC_PERFORMED_UNDO</code>,
    <code>SC_PERFORMED_REDO</code>, <code>SC_LASTSTEPINUNDOREDO</code>,
    <code>SC_MOD_CHANGEMARKER</code>, <code>SC_MOD_BEFOREINSERT</code>,
    <code>SC_MOD_BEFOREDELETE</code>, and <code>SC_MODEVENTMASKALL</code>.</p>
<h3 id="SCEN_SETFOCUS">SCEN_SETFOCUS<br />
     <span id="SCEN_KILLFOCUS">SCEN_KILLFOCUS</span></h3>
    <p>Scintilla がフォーカスを得たときに <code>SCEN_SETFOCUS</code> (512) が、フォーカスを失ったときに <code>SCEN_KILLFOCUS</code> (256) が発行されます。Windows では <code>WM_COMMAND</code> を、GTK+ では "Command" シグナルを用いて通知されます。これらは標準エディットコントロールと同じ挙動を行うために発行されます。残念ながら Windows の通知コード <code>EN_SETFOCUS</code> (256) および <code>EN_KILLFOCUS</code> (512) とは一致していません。現在の値で Scintilla を利用しているものがあるため、Scintilla を変更するにはすでに手遅れでした。</p>
    <p class="eng"><b>SCEN_SETFOCUS</b><br />
     <b>SCEN_KILLFOCUS</b><br />
     <code>SCEN_SETFOCUS</code> (512) is fired when Scintilla receives focus and
    <code>SCEN_KILLFOCUS</code> (256) when it loses focus. These notifications are sent using the
    <code>WM_COMMAND</code> message on Windows and the "Command" signal on GTK+ as this is the
    behavior of the standard Edit control. Unfortunately, these codes do not match the Windows Edit
    notification codes <code>EN_SETFOCUS</code> (256) and <code>EN_KILLFOCUS</code> (512). It is
    now too late to change the Scintilla codes as clients depend on the current values.</p>
<h3 id="SCN_MACRORECORD">SCN_MACRORECORD</h3>
    <p><code><a class="message" href="#SCI_STARTRECORD">SCI_STARTRECORD</a></code> と <a
    class="message" href="#SCI_STOPRECORD"><code>SCI_STOPRECORD</code></a> はマクロの記録を開始・停止します。開始された場合、記録できる変更がある度に通知 <code>SCN_MACRORECORD</code> がコンテナに送られます。記録はコンテナの責任になります。記録可能な <code>SCI_*</code> メッセージの完全な一覧は Scintilla のソースファイル <code>Editor.cxx</code> で <code>Editor::NotifyMacroRecord</code> を検索してください。この通知で設定される <code>SCNotification</code> の項目は次の通りです。</p>
    <p class="eng"><b>SCN_MACRORECORD</b><br />
     The <code><a class="message" href="#SCI_STARTRECORD">SCI_STARTRECORD</a></code> and <a
    class="message" href="#SCI_STOPRECORD"><code>SCI_STOPRECORD</code></a> messages enable and
    disable macro recording. When enabled, each time a recordable change occurs, the
    <code>SCN_MACRORECORD</code> notification is sent to the container. It is up to the container
    to record the action. To see the complete list of <code>SCI_*</code> messages that are
    recordable, search the Scintilla source <code>Editor.cxx</code> for
    <code>Editor::NotifyMacroRecord</code>. The fields of <code>SCNotification</code> set in this
    notification are:</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="マクロ記録の通知情報">
      <tbody>
        <tr>
          <th align="left">項目</th>

          <th align="left">用途</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>message</code></td>

          <td align="left">通知の元となった <code>SCI_*</code> メッセージです。</td>
        </tr>

        <tr>
          <td align="left"><code>wParam</code></td>

          <td align="left"><code>SCI_*</code> メッセージの <code>wParam</code> 値です。</td>
        </tr>

        <tr>
          <td align="left"><code>lParam</code></td>

          <td align="left"><code>SCI_*</code> メッセージの <code>lParam</code> 値です。</td>
        </tr>
      </tbody>
    </table>

    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Macro record notification data">
      <tbody>
        <tr>
          <th align="left">Field</th>

          <th align="left">Usage</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>message</code></td>

          <td align="left">The <code>SCI_*</code> message that caused the notification.</td>
        </tr>

        <tr>
          <td align="left"><code>wParam</code></td>

          <td align="left">The value of <code>wParam</code> in the <code>SCI_*</code> message.</td>
        </tr>

        <tr>
          <td align="left"><code>lParam</code></td>

          <td align="left">The value of <code>lParam</code> in the <code>SCI_*</code> message.</td>
        </tr>
      </tbody>
    </table>
<h3 id="SCN_MARGINCLICK">SCN_MARGINCLICK</h3>
    <p>マウスクリックに反応するように指定されたマーカのある<a class="jump"
    href="#Margins">余白</a>部分でマウスがクリックされたことをコンテナに伝えます。<a class="message"
    href="#SCI_SETMARGINSENSITIVEN"><code>SCI_SETMARGINSENSITIVEN</code></a> を参照ください。<code>SCNotification</code> 内の次の項目が使われます。</p>
    <p class="eng"><b>SCN_MARGINCLICK</b><br />
     This notification tells the container that the mouse was clicked inside a <a class="jump"
    href="#Margins">margin</a> that was marked as sensitive (see <a class="message"
    href="#SCI_SETMARGINSENSITIVEN"><code>SCI_SETMARGINSENSITIVEN</code></a>). This can be used to
    perform folding or to place breakpoints. The following <code>SCNotification</code> fields are
    used:</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="余白クリックの通知">
      <tbody>
        <tr>
          <th align="left">項目</th>

          <th align="left">用途</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>modifiers</code></td>

          <td align="left">余白部がクリックされた時点で押下されていた修飾キーの情報を <code>SCI_SHIFT</code>, <code>SCI_CTRL</code>, <code>SCI_ALT</code>の組み合わせで表します。</td>
        </tr>

        <tr>
          <td align="left"><code>position</code></td>

          <td align="left">クリックされた余白に対応する行の先頭を、文書内の位置で示します。</td>
        </tr>

        <tr>
          <td align="left"><code>margin</code></td>

          <td align="left">クリックされた余白の番号を示します。</td>
        </tr>
      </tbody>
    </table>

    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Margin click notification">
      <tbody>
        <tr>
          <th align="left">Field</th>

          <th align="left">Usage</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>modifiers</code></td>

          <td align="left">The appropriate combination of <code>SCI_SHIFT</code>,
          <code>SCI_CTRL</code> and <code>SCI_ALT</code> to indicate the keys that were held down
          at the time of the margin click.</td>
        </tr>

        <tr>
          <td align="left"><code>position</code></td>

          <td align="left">The position of the start of the line in the document that corresponds
          to the margin click.</td>
        </tr>

        <tr>
          <td align="left"><code>margin</code></td>

          <td align="left">The margin number that was clicked.</td>
        </tr>
      </tbody>
    </table>
<h3 id="SCN_NEEDSHOWN">SCN_NEEDSHOWN</h3>
    <p>Scintilla が現在見えていない複数行の一部を見えるようにしようとしていることを通知します。折りたたまれている省略部が削除された場合などに発行されます。文書全体を可視とするような、通常の方法とは違うやり方で行を見えるようにしつつあるときもコンテナに送信されます。多くの場合、コンテナは単に <a class="message"
    href="#SCI_ENSUREVISIBLE"><code>SCI_ENSUREVISIBLE</code></a> を呼び出して通知範囲の各行を可視にすればよいのです。<code>SCNotification</code> の二項目 <code>position</code> および <code>length</code> で文書内のどの範囲を可視にすべきかを表しています。コンテナは次のようなコードになるでしょう。</p>
    <p class="eng"><b>SCN_NEEDSHOWN</b><br />
     Scintilla has determined that a range of lines that is currently invisible should be made
    visible. An example of where this may be needed is if the end of line of a contracted fold
    point is deleted. This message is sent to the container in case it wants to make the line
    visible in some unusual way such as making the whole document visible. Most containers will
    just ensure each line in the range is visible by calling <a class="message"
    href="#SCI_ENSUREVISIBLE"><code>SCI_ENSUREVISIBLE</code></a>. The <code>position</code> and
    <code>length</code> fields of <code>SCNotification</code> indicate the range of the document
    that should be made visible. The container code will be similar to the following code
    skeleton:</p>
<code>
firstLine = SCI_LINEFROMPOSITION(scn.position)
lastLine = SCI_LINEFROMPOSITION(scn.position+scn.length-1)
for line = lineStart to lineEnd do SCI_ENSUREVISIBLE(line) next
</code>
<h3 id="SCN_PAINTED">SCN_PAINTED</h3>
    <p>描画が終了したことを通知します。Scintilla 内の変更に基づいて他のウィジェットを更新したいときでなおかつ、描画を先に終わらせて反応の良い表示に見せたい場合に有用です。<code>SCNotification</code> に設定される情報はありません。</p>
    <p class="eng"><b>SCN_PAINTED</b><br />
     Painting has just been done. Useful when you want to update some other widgets based on a
    change in Scintilla, but want to have the paint occur first to appear more responsive. There is
    no other information in <code>SCNotification</code>.</p>
<h3 id="SCN_USERLISTSELECTION">SCN_USERLISTSELECTION</h3>
    <p>ユーザが<a class="jump" href="#UserLists">ユーザ項目群</a>からある項目を選択したことを通知します。<code>SCNotification</code> で使用される項目は次の通りです。 </p>
    <p class="eng"><b>SCN_USERLISTSELECTION</b><br />
     The user has selected an item in a <a class="jump" href="#UserLists">user list</a>. The
    <code>SCNotification</code> fields used are:</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="ユーザ項目群に関する通知">
      <tbody>
        <tr>
          <th align="left">項目</th>

          <th align="left">用途</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>wParam</code></td>

          <td align="left">項目群を初期化した時の <a
          class="message" href="#SCI_USERLISTSHOW"><code>SCI_USERLISTSHOW</code></a> で指定した <code>listType</code> 引数です。</td>
        </tr>

        <tr>
          <td align="left"><code>text</code></td>

          <td align="left">選択範囲のテキストです。</td>
        </tr>
      </tbody>
    </table>

    <table cellpadding="1" cellspacing="2" border="0" summary="User list notification">
      <tbody>
        <tr>
          <th align="left">Field</th>

          <th align="left">Usage</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>wParam</code></td>

          <td align="left">This is set to the <code>listType</code> parameter from the <a
          class="message" href="#SCI_USERLISTSHOW"><code>SCI_USERLISTSHOW</code></a> message that
          initiated the list.</td>
        </tr>

        <tr>
          <td align="left"><code>text</code></td>

          <td align="left">The text of the selection.</td>
        </tr>
      </tbody>
    </table>

<h3 id="SCN_URIDROPPED">SCN_URIDROPPED</h3>
    <p>GTK+ 版でのみ使います。ファイル名やウェブアドレスが Scintilla 内へドラッグされたことを通知します。コンテナはこれをファイルを開く要求として会食できます。<code>SCNotification</code> 構造体の <code>text</code> 項目が URI 文字列を指しています。</p>
    <p class="eng"><b>SCN_URIDROPPED</b><br />
     Only on the GTK+ version. Indicates that the user has dragged a URI such as a file name or Web
    address onto Scintilla. The container could interpret this as a request to open the file. The
    <code>text</code> field of <code>SCNotification</code> points at the URI text.</p>
<h3 id="SCN_DWELLSTART">SCN_DWELLSTART<br />
     <span id="SCN_DWELLEND">SCN_DWELLEND</span></h3>
    <p>ある点でマウスを一定時間停止させていると <code>SCN_DWELLSTART</code> が発行されます。<code><a class="message"
    href="#SCI_SETMOUSEDWELLTIME">SCI_SETMOUSEDWELLTIME</a></code> を参照してください。<code>SCN_DWELLSTART</code> の発行された後、マウスが動かされたりするほか、キーの押下などでマウスの停留状態が終了したときに <code>SCN_DWELLEND</code> が発行されます。<code>SCNotification</code> の用途は双方に共通しています。以下の通りです。</p>
    <p class="eng"><b>SCN_DWELLSTART</b><br />
     <b>SCN_DWELLEND</b><br />
     <code>SCN_DWELLSTART</code> is generated when the user keeps the mouse in one position for the
    dwell period (see <code><a class="message"
    href="#SCI_SETMOUSEDWELLTIME">SCI_SETMOUSEDWELLTIME</a></code>). <code>SCN_DWELLEND</code> is
    generated after a <code>SCN_DWELLSTART</code> and the mouse is moved or other activity such as
    key press indicates the dwell is over. Both notifications set the same fields in
    <code>SCNotification</code>:</p>
    <table cellpadding="1" cellspacing="2" border="0" summary="マウスの停留通知">
      <tbody>
        <tr>
          <th align="left">項目</th>

          <th align="left">用途</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>position</code></td>

          <td align="left">マウスが停留しているところから一番近い文書上の位置です。</td>
        </tr>

        <tr>
          <td align="left"><code>x, y</code></td>

          <td align="left">マウスポインタが停留している位置です。<code><a class="message"
          href="#SCI_POSITIONFROMPOINTCLOSE">SCI_POSITIONFROMPOINTCLOSE</a>(x, y)</code> によって設定されています。</td>
        </tr>
      </tbody>
    </table>

    <table class="eng" cellpadding="1" cellspacing="2" border="0" summary="Mouse dwell notification">
      <tbody>
        <tr>
          <th align="left">Field</th>

          <th align="left">Usage</th>
        </tr>
      </tbody>

      <tbody valign="top">
        <tr>
          <td align="left"><code>position</code></td>

          <td align="left">This is the nearest position in the document to the position where the
          mouse pointer was lingering.</td>
        </tr>

        <tr>
          <td align="left"><code>x, y</code></td>

          <td align="left">Where the pointer lingered. The <code>position</code> field is set to
          <code><a class="message"
          href="#SCI_POSITIONFROMPOINTCLOSE">SCI_POSITIONFROMPOINTCLOSE</a>(x, y)</code>.</td>
        </tr>
      </tbody>
    </table>

<h3 id="SCI_SETMOUSEDWELLTIME">SCI_SETMOUSEDWELLTIME<br />
     <span id="SCI_GETMOUSEDWELLTIME">SCI_GETMOUSEDWELLTIME</span></h3>
    <p>ミリ秒単位でマウスの停留とみなす時間を指定または取得します。マウス停留が検出されると <code><a class="message" href="#SCN_DWELLSTART">SCN_DWELLSTART</a></code> が発行されます。初期状態では停留イベントは発行されません。</p>
    <p class="eng"><b>SCI_SETMOUSEDWELLTIME</b><br />
     <b>SCI_GETMOUSEDWELLTIME</b><br />
     These two messages set and get the time the mouse must sit still, in milliseconds, to generate
    a <code><a class="message" href="#SCN_DWELLSTART">SCN_DWELLSTART</a></code> notification. If
    set to <code>SC_TIME_FOREVER</code>, the default, no dwell events are generated.</p>
<h3 id="SCN_ZOOM">SCN_ZOOM</h3>
    <p>ユーザが表示の拡大縮小を行おうとしている場合に発行されます。キーボード操作によるものか <code><a class="message" href="#SCI_SETZOOM">SCI_SETZOOM</a></code> によるものです。行番号余白の幅のやピクセル単位でなく文字単位の大きさの管理といった場合の位置の再計算に用いることが出来ます。<code>SCNotification</code> 構造体は用いられていません。</p>
    <p class="eng"><b>SCN_ZOOM</b><br />
     This notification is generated when the user zooms the display using the keyboard or the
    <code><a class="message" href="#SCI_SETZOOM">SCI_SETZOOM</a></code> method is called. This
    notification can be used to recalculate positions, such as the width of the line number margin
    to maintain sizes in terms of characters rather than pixels. <code>SCNotification</code> has no
    additional information.</p>
<h3 id="SCN_HOTSPOTCLICK">SCN_HOTSPOTCLICK<br />
    <span id="SCN_HOTSPOTDOUBLECLICK">SCN_HOTSPOTDOUBLECLICK</span></h3>
    <p>ホットスポット特性を設定されたテキスト上でクリックあるいはダブルクリックされたときに発行されます。当該変数の定義部やウェブサイトへのリンクに用いることができます。項目 <code>position</code> にクリックされた位置、<code>modifiers</code> にクリック時に押下されていた修飾キーの情報が入っています。修飾キー情報は <a class="message" href="#SCN_KEY">SCN_KEY</a> と同様のものです。</p>
    <p class="eng">
    <b>SCN_HOTSPOTCLICK</b><br />
    <b>SCN_HOTSPOTDOUBLECLICK</b><br />
     These notifications are generated when the user clicks or double clicks on
     text that is in a style with the hotspot attribute set.
    This notification can be used to link to variable definitions or web pages.
    The <code>position</code> field is set the text position of the click or
    double click and the <code>modifiers</code> field set to the key modifiers
    held down in a similar manner to <a class="message" href="#SCN_KEY">SCN_KEY</a>.</p>
<h3 id="SCN_CALLTIPCLICK">SCN_CALLTIPCLICK</h3>
    <p>コールチップ上でクリックされたときに発行されます。関数名が異なる引数でオーバロードされているときに、現在表示しているものとは違う引数の雛形を表示することに用いられます。項目 <code>position</code> には上向き矢印をクリックされたときに 1, 下向き矢印の時に 2, そうでなければ 0 が収められています。</p>
    <p class="eng"><b>SCN_CALLTIPCLICK</b><br />
     This notification is generated when the user clicks on a calltip.
    This notification can be used to display the next function prototype when a
    function name is overloaded with different arguments.
    The <code>position</code> field is set to 1 if the click is in an up arrow,
    2 if in a down arrow, and 0 if elsewhere.</p>

    <h2 id="DeprecatedMessages"><span>非推奨のメッセージと通知</span><span class="eng">Deprecated messages and notifications</span></h2>

    <p>次のメッセージは現在既存の Windows コントロールを模倣するために対応していますが、将来の版の Scintilla では削除される予定のものです。これらのメッセージを使っている場合は現行の等価なものに置き換えてください。</p>
    <p class="eng">The following messages are currently supported to emulate existing Windows controls, but
    they will be removed in future versions of Scintilla. If you use these messages you should
    replace them with the Scintilla equivalent.</p>
<pre>
WM_GETTEXT(int length, char *text)
WM_SETTEXT(&lt;unused&gt;, const char *text)
EM_GETLINE(int line, char *text)
EM_REPLACESEL(&lt;unused&gt;, const char *text)
EM_SETREADONLY
EM_GETTEXTRANGE(&lt;unused&gt;, TEXTRANGE *tr)
WM_CUT
WM_COPY
WM_PASTE
WM_CLEAR
WM_UNDO
EM_CANUNDO
EM_EMPTYUNDOBUFFER
WM_GETTEXTLENGTH
EM_GETFIRSTVISIBLELINE
EM_GETLINECOUNT
EM_GETMODIFY
EM_SETMODIFY(bool isModified)
EM_GETRECT(RECT *rect)
EM_GETSEL(int *start, int *end)
EM_EXGETSEL(&lt;unused&gt;, CHARRANGE *cr)
EM_SETSEL(int start, int end)
EM_EXSETSEL(&lt;unused&gt;, CHARRANGE *cr)
EM_GETSELTEXT(&lt;unused&gt;, char *text)
EM_LINEFROMCHAR(int position)
EM_EXLINEFROMCHAR(int position)
EM_LINEINDEX(int line)
EM_LINELENGTH(int position)
EM_SCROLL(int line)
EM_LINESCROLL(int column, int line)
EM_SCROLLCARET()
EM_CANPASTE
EM_CHARFROMPOS(&lt;unused&gt;, POINT *location)
EM_POSFROMCHAR(int position, POINT *location)
EM_SELECTIONTYPE
EM_HIDESELECTION(bool hide)
EM_FINDTEXT(int flags, FINDTEXTEX *ft)
EM_FINDTEXTEX(int flags, FINDTEXTEX *ft)
EM_GETMARGINS
EM_SETMARGINS(EC_LEFTMARGIN or EC_RIGHTMARGIN or EC_USEFONTINFO, int val)
EM_FORMATRANGE
</pre>

    <p>次の二つは <code>Scintilla.h</code> で <code>INCLUDE_DEPRECATED_FEATURES</code> を定義したときのみ実装されます。将来との互換性を確実にするためには各々の説明に従ってください。</p>
    <p class="eng">The following are features that are only included if you define
    <code>INCLUDE_DEPRECATED_FEATURES</code> in <code>Scintilla.h</code>. To ensure future
    compatibility you should change them as indicated.</p>
<h3 id="SCN_POSCHANGED">SCN_POSCHANGED() 【非推奨】</h3>
    <p>テキストの違う位置へカーソルが動かされたときに送信されます。<a
    class="message" href="#SCN_UPDATEUI"><code>SCN_UPDATEUI</code></a> を代わりに使ってください。</p>
    <p class="eng"><b>SCN_POSCHANGED()</b> Deprecated<br />
     Fired when the user moves the cursor to a different position in the text. Use <a
    class="message" href="#SCN_UPDATEUI"><code>SCN_UPDATEUI</code></a> instead.</p>
<h3 id="SCN_CHECKBRACE">SCN_CHECKBRACE 【非推奨】</h3>
    <p>文書の文字か装飾が変化した場合、あるいは選択範囲が変更された場合に送信されます。現在は <a class="message" href="#SCN_UPDATEUI"><code>SCN_UPDATEUI</code></a> に置き換わりました。<code><a class="message" href="#SCN_MODIFIED">SCN_MODIFIED</a></code> を用いて変化の詳細を知ることができます。</p>
    <p class="eng"><b>SCN_CHECKBRACE</b> Deprecated<br />
     Either the text or styling of the document has changed or the selection range has changed.
    This is replaced by <a class="message" href="#SCN_UPDATEUI"><code>SCN_UPDATEUI</code></a>. You
    can also use <code><a class="message" href="#SCN_MODIFIED">SCN_MODIFIED</a></code> for more
    detailed information on text and styling changes,</p>

    <h2 id="EditMessagesNeverSupportedByScintilla"><span>Scintilla で対応しないエディットメッセージ</span><span class="eng">Edit messages never supported by Scintilla</span></h2>
<pre>
EM_GETWORDBREAKPROC EM_GETWORDBREAKPROCEX
EM_SETWORDBREAKPROC EM_SETWORDBREAKPROCEX
EM_GETWORDWRAPMODE EM_SETWORDWRAPMODE
EM_LIMITTEXT EM_EXLIMITTEXT
EM_SETRECT EM_SETRECTNP
EM_FMTLINES
EM_GETHANDLE EM_SETHANDLE
EM_GETPASSWORDCHAR EM_SETPASSWORDCHAR
EM_SETTABSTOPS
EM_FINDWORDBREAK
EM_GETCHARFORMAT EM_SETCHARFORMAT
EM_GETOLEINTERFACE EM_SETOLEINTERFACE
EM_SETOLECALLBACK
EM_GETPARAFORMAT EM_SETPARAFORMAT
EM_PASTESPECIAL
EM_REQUESTRESIZE
EM_GETBKGNDCOLOR EM_SETBKGNDCOLOR
EM_STREAMIN EM_STREAMOUT
EM_GETIMECOLOR EM_SETIMECOLOR
EM_GETIMEOPTIONS EM_SETIMEOPTIONS
EM_GETOPTIONS EM_SETOPTIONS
EM_GETPUNCTUATION EM_SETPUNCTUATION
EM_GETTHUMB
EM_GETEVENTMASK
EM_SETEVENTMASK
EM_DISPLAYBAND
EM_SETTARGETDEVICE
</pre>

    <p>Scintilla は意味を持っている限りの標準のエディットウィンドウコントロールやリッチエディットコントロールの上位互換であろうとします。ただし、ワープロとしての利用を考えていないため、いくつかのメッセージは相応に扱うことができません。対応していないメッセージは何ら実行に影響を与えません。</p>
    <p class="eng">Scintilla tries to be a superset of the standard windows Edit and RichEdit controls wherever
    that makes sense. As it is not intended for use in a word processor, some edit messages can not
    be sensibly handled. Unsupported messages have no effect.</p>

    <h2 id="BuildingScintilla"><span>Scintilla の構築</span><span class="eng">Building Scintilla</span></h2>

    <p>Scintilla や SciTE を構築するにはそれぞれのディレクトリにある README ファイルをお読みください。Windows では GCC 3.2, Borland C++, Microsoft Visual Studio .NET でビルドすることができます。Visual C++ 6 については、Scintilla 用の makefile はあります(scintilla/win32/scintilla_vc6.mak)が、SciTE 用がありません。GTK+ 用では GCC 3.1 を使うべきです。GTK+ 1.2x と 2.0x に対応しています。コンパイル環境の GTK+ の版は自動的に検出されます。両方がある場合は、コマンドラインで GTK1 を定義しないと GTK+ 1.x 用の構築ができません。</p>
    <p class="eng">To build Scintilla or SciTE, see the README file present in both the Scintilla and SciTE
    directories. For Windows, GCC 3.2, Borland C++ or Microsoft Visual Studio .NET can be used
    for building. There is a make file for building Scintilla but not SciTE with Visual C++ 6 at
    scintilla/win32/scintilla_vc6.mak. For GTK+, GCC 3.1 should be used. GTK+ 1.2x and 2.0x are
    supported. The version of GTK+ installed should be detected automatically.
    When both GTK+ 1 and GTK+ 2 are present, building for GTK+ 1.x requires defining GTK1
    on the command line.</p>

    <h3><span>静的リンク</span><span class="eng">Static linking</span></h3>

    <p>Windows では Scintilla は通常 .DLL ファイルとして動的ライブラリの形で使われます。Scintilla を直接各自の .EXE あるいは .DLL ファイルの中に結合してしまいたい場合は、プリプロセッサシンボル <code>STATIC_BUILD</code>  を定義し、<code>Scintilla_RegisterClasses</code> を呼び出します。<code>STATIC_BUILD</code> は Scintilla 側で <code>DllMain</code> 関数が生成されるのを防ぎます。<code>Scintilla_RegisterClasses</code> は 各自のアプリケーションの <code>HINSTANCE</code> をとり、ウィンドウクラス "Scintilla" を確実に登録します。Scintilla にその余白区域へ右向きの矢印カーソルを確実に表示させるようにするには、<code>scintilla/win32/Margin.cur</code> をアプリケーションのリソースに加え、その識別子 <code>IDC_MARGIN</code> とします。これは <code>scintilla/win32/platfromRes.h</code> で 400 に定義されています。</p>
    <p class="eng">On Windows, Scintilla is normally used as a dynamic library as a .DLL file. If you want to
    link Scintilla directly into your application .EXE or .DLL file, then the
    <code>STATIC_BUILD</code> preprocessor symbol should be defined and
    <code>Scintilla_RegisterClasses</code> called. <code>STATIC_BUILD</code> prevents compiling the
    <code>DllMain</code> function which will conflict with any <code>DllMain</code> defined in your
    code. <code>Scintilla_RegisterClasses</code> takes the <code>HINSTANCE</code> of your
    application and ensures that the "Scintilla" window class is registered. To make sure that the
    right pointing arrow cursor used in the margin is displayed by Scintilla add the
    <code>scintilla/win32/Margin.cur</code> file to your application's resources with the ID
    <code>IDC_MARGIN</code> which is defined in <code>scintilla/win32/platfromRes.h</code> as
    400.</p>

    <h3><span>Scintilla に解析器を確実にリンクする</span><span class="eng">Ensuring lexers are linked into Scintilla</span></h3>

    <p>使用するコンパイラとリンカによっては解析器が切り捨てられてしまいます。この現象の大部分は静的ライブラリの構築に置いて発生します。<code>Scintilla_LinkLexers()</code> 関数を呼び出しておくと解析器を確実にリンクさせることができます。</p>
    <p class="eng">Depending on the compiler and linker used, the lexers may be stripped out. This is most
    often caused when building a static library. To ensure the lexers are linked in, the
    <code>Scintilla_LinkLexers()</code> function may be called.</p>

    <h3><span>解析器集合の変更</span><span class="eng">Changing set of lexers</span></h3>

    <p>Scintilla の解析器の集合を変更するには、まずディレクトリ <code>scintilla/src</code> から解析器のソースファイル(<code>Lex*.cxx</code>)を追加・削除してください。次に <code>scintilla/src</code> から <code>src/LexGen.py</code> スクリプトを実行し、makefile と <code>KeyWords.cxx</code> を更新します。<code>LexGen.py</code> は Python 2.1 以降が必要です。Python が使えない環境の場合は、手動により他の解析器の形に従う形で <code>KeyWords.cxx</code> を書き換えることができます。解析器のソースコードで <code>LINK_LEXER(lmMyLexer);</code> を含むことにより <code>LexerModule lmMyLexer(...);</code> に合致させることが重要です。</p>
    <p class="eng">To change the set of lexers in Scintilla, add and remove lexer source files
    (<code>Lex*.cxx</code>) from the <code>scintilla/src directory</code> and run the
    <code>src/LexGen.py</code> script from the <code>src</code> directory to update the make files
    and <code>KeyWords.cxx</code>. <code>LexGen.py</code> requires Python 2.1 or later. If you do
    not have access to Python, you can hand edit <code>KeyWords.cxx</code> in a simple-minded way,
    following the patterns of other lexers. The important thing is to include
    <code>LINK_LEXER(lmMyLexer);</code> to correspond with the <code>LexerModule
    lmMyLexer(...);</code> in your lexer source code.</p>
  </body>
</html>

